<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chambers个人博客</title>
  
  <subtitle>记录点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-22T08:42:47.689Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chambers</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>css世界学习笔记</title>
    <link href="http://yoursite.com/2018/04/02/css%E4%B8%96%E7%95%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/02/css世界学习笔记/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-04-22T08:42:47.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-盒子双重性"><a href="#1-盒子双重性" class="headerlink" title="1.盒子双重性"></a>1.盒子双重性</h3><p>按照 display 的属性值不同，值为 block 的元素的盒子实际由外在的“块级盒子” 和内在的“块级容器盒子”组成，值为 inline-block 的元素则由外在的“内联盒子”和内 在的“块级容器盒子”组成，值为 inline 的元素则内外均是“内联盒子”。实际上，如果遵循这种理解，display:block 应该脑补成 display:block-block，display:table 应该脑补成 display:block-table，我们平时的写法实际上是一种简写。<br>下面问题来了：元素都有内外两个盒子， 我们平常设置的 width/height 属性是作用在哪个盒子上的？这个问题也是很简单的，因为在解释内外盒子的时候就已经提到过了：是内在盒子，也就 是“容器盒子”。</p><h3 id="2-默认宽度width-auto的表现特性（即不设置宽度的表现）"><a href="#2-默认宽度width-auto的表现特性（即不设置宽度的表现）" class="headerlink" title="2.默认宽度width:auto的表现特性（即不设置宽度的表现）"></a>2.默认宽度width:auto的表现特性（即不设置宽度的表现）</h3><p><strong>（1）</strong>充分利用可用空间。比方说块级block元素的宽度默认是 100%于父级容器的。</p><p><strong>（2）</strong>收缩与包裹。典型代表就是浮动、绝对定位、inline-block 元素或 table 元素，意为“收缩到合适”，有那么点儿意思，但不够形象，我一直把这种现 象称为“包裹性”。元素尺寸由内部元素决定，但永远小于“包含块”容器的 尺寸。因此，对于一个元素，如果其 display 属性值是 inline-block，那么即使其里面内容 再多，只要是正常文本，宽度也不会超过容器。<br>包裹性例子：<a href="http://demo.cssworld.cn/3/2-5.php" target="_blank" rel="noopener">http://demo.cssworld.cn/3/2-5.php</a></p><p><strong>（3）</strong>收缩到最小。这个最容易出现在 table-layout 为 auto 的表格中。</p><p><strong>（4）</strong>超出容器限制。除非有明确的 width 相关设置，否则上面 3 种情况尺寸都不会主动 超过父级容器宽度的，但是存在一些特殊情况。例如，内容很长的连续的英文和数字，或者内联 元素被设置了 white-space:nowrap。</p><h3 id="3-min-width和max-width"><a href="#3-min-width和max-width" class="headerlink" title="3.min-width和max-width"></a>3.min-width和max-width</h3><p>min-width初始值为auto，max-width初始值为none。<br>max-width：<br><img src="/2018/04/02/css世界学习笔记/0.png" alt="css世界学习笔记"><br>上图答案是 256px。style、!important 通通靠边站！因为 max-width 会覆盖 width。<br>ps：如果元素height是auto不确定，那么可以巧用max-width实现“展开收起”效果：<br><img src="/2018/04/02/css世界学习笔记/1.png" alt="css世界学习笔记"><br>min-width：<br><img src="/2018/04/02/css世界学习笔记/2.png" alt="css世界学习笔记"><br>上图中min-width 活下来，max-width 被忽略， 于是，.container 元素表现为至少 1400 像素宽。</p><h3 id="4-幽灵空白节点"><a href="#4-幽灵空白节点" class="headerlink" title="4.幽灵空白节点"></a>4.幽灵空白节点</h3><p>“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在 HTML5 文档声明 中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这 个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样， 但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。<br><img src="/2018/04/02/css世界学习笔记/3.png" alt="css世界学习笔记"></p><h3 id="5-input-type-’button’-和button的区别"><a href="#5-input-type-’button’-和button的区别" class="headerlink" title="5.input[type=’button’]和button的区别"></a>5.input[type=’button’]和button的区别</h3><p>区别在什么地方？区别在于两种按钮默认的 white-space 值不一样，前者是 pre，后者是 normal，所表示出来的现象差异就是：当按钮文字足够多的时候，input按钮不会自动换行，button则会。</p><h3 id="6-margin-left和margin-right设为auto"><a href="#6-margin-left和margin-right设为auto" class="headerlink" title="6.margin-left和margin-right设为auto"></a>6.margin-left和margin-right设为auto</h3><p><img src="/2018/04/02/css世界学习笔记/4.png" alt="css世界学习笔记"><br>如果想让某个块状元素右对齐，脑子里不要就一个 float:right，很多时候，marginleft:auto 才是最佳的实践，浮动毕竟是个“小魔鬼”。我甚至可以这么说：margin 属性的 auto 计算就是为块级元素左中右对齐而设计的，和内联元素使用 text-align 控制左中右对 齐正好遥相呼应！ 居中对齐左右同时 auto 计算即可，CSS 如下：<br><img src="/2018/04/02/css世界学习笔记/5.png" alt="css世界学习笔记"></p><h3 id="7-尺寸单位ex了解一下"><a href="#7-尺寸单位ex了解一下" class="headerlink" title="7.尺寸单位ex了解一下"></a>7.尺寸单位ex了解一下</h3><p>ex 是 CSS 中的一个相对单位，指的是小写字母 x 的高度，没错，就是指 x-height。ex 是 CSS 中的一个相对单位，指的是小写字母 x 的高度，没错，就是指 x-height。<br>我们都知道，内联元素默认是基线对齐的，而基线就是 x 的底部，而 1ex 就是一个 x 的高 度。设想一下，假如图标高度就是 1ex，同时背景图片居中，岂不是图标和文字天然垂直居中， 而且完全不受字体和字号的影响？因为 ex 就是一个相对于字体和字号的单位。<br>现在，要让该图标和文字中间位置对齐，你会如 何实现？设定好尺寸，然后使用 vertical-align:middle？这 样虽然也有效果，但是，实际上啰嗦了，借助 ex 单位，我们直接 利用默认的 baseline 基线对齐就可以实现这个效果。<br><img src="/2018/04/02/css世界学习笔记/6.png" alt="css世界学习笔记"><br><img src="/2018/04/02/css世界学习笔记/7.png" alt="css世界学习笔记"></p><h3 id="8-多行文字垂直居中"><a href="#8-多行文字垂直居中" class="headerlink" title="8.多行文字垂直居中"></a>8.多行文字垂直居中</h3><p><img src="/2018/04/02/css世界学习笔记/8.png" alt="css世界学习笔记"><br><img src="/2018/04/02/css世界学习笔记/9.png" alt="css世界学习笔记"></p><h3 id="9-line-height的属性值"><a href="#9-line-height的属性值" class="headerlink" title="9.line-height的属性值"></a>9.line-height的属性值</h3><p><strong>1.数值</strong>，如 line-height:1.5，其最终的计算值是和当前 font-size 相乘后的值。 例如，假设我们此时的 font-size 大小为 14px，则 line-height 计算值是 1.5<em>14px=21px。<br><strong>2.百分比值</strong>，如 line-height:150%，其最终的计算值是和当前 font-size 相乘后 的值。例如，假设我们此时的 font-size 大小为 14px，则 line-height 计算值是 150%</em>14px=21px。<br><strong>3.长度值</strong>，也就是带单位的值，如 line-height:21px 或者 line-height:1.5em 等，此处 em 是一个相对于 font-size 的相对单位，因此，line-height:1.5em 最终的计算值也是和当前font-size相乘后的值。例如，假设我们此时的font-size 大小为 14px，则 line-height 计算值是 1.5*14px=21px。<br>乍一看，似乎 line-height:1.5、line-height:150%和 line-height:1.5em 这 3 种 用法是一模一样的，最终的行高大小都是和font-size计算值，但是，实际上，line-height:1.5 和另外两个有一点儿不同，那就是继承细节有所差别。如果使用数值作为 line-height 的属性值， 那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。<br><img src="/2018/04/02/css世界学习笔记/10.png" alt="css世界学习笔记"><br>如果我们做的是一个重图文内容展示的网页或者网站，如博客、论坛、 公众号之类的，那一定要使用数值作为单位，考虑到文章阅读的舒适度，line-height 值可 以设置在 1.6～1.8。</p><h3 id="10-word-break-break-all和word-wrap-break-word的区别"><a href="#10-word-break-break-all和word-wrap-break-word的区别" class="headerlink" title="10.word-break:break-all和word-wrap:break-word的区别"></a>10.word-break:break-all和word-wrap:break-word的区别</h3><p>word-break:break-all 的作用是所有的都换行，毫不留情，一点儿空 隙都不放过，而 word-wrap:break-word 则带有怜悯之心，如果这一行文字有可以换 行的点，如空格或 CJK（中文/日文/韩文）之类的，就不打英文单词或字符的主意了，在 这些换行点换行，至于对不对齐、好不好看则不关心，因此，很容易出现一片一片空白区域的情况。<br><img src="/2018/04/02/css世界学习笔记/11.png" alt="css世界学习笔记"></p><h3 id="11-隐藏元素的-background-image-到底加不加载呢？"><a href="#11-隐藏元素的-background-image-到底加不加载呢？" class="headerlink" title="11.隐藏元素的 background-image 到底加不加载呢？"></a>11.隐藏元素的 background-image 到底加不加载呢？</h3><p>想必这是一个很多人都感兴趣的问题。 根据我的测试，一个元素如果 display 计算值为 none，在 IE 浏览器下（IE8～IE11，更 高版本不确定）依然会发送图片请求，Firefox 浏览器不会，至于 Chrome 和 Safari 浏览器则似 乎更加智能一点：如果隐藏元素同时又设置了 background-image，则图片依然会去加载； 如果是父元素的 display 计算值为 none，则背景图不会请求，此时浏览器或许放心地认为这 个背景图暂时是不会使用的。</p><h3 id="12-outline"><a href="#12-outline" class="headerlink" title="12.outline"></a>12.outline</h3><p>万万不可在全局设置 outline:0 none！这样的错误会造成部分场景 下的部分用户产生使用障碍！ 国内很多大站也会犯类似的错误，注意千万不要学习，千万不要模仿！<br>outline 是不占据任何空间的属性。<br>ps:用outline自动填满屏幕剩余空间的应用技巧。<br><img src="/2018/04/02/css世界学习笔记/12.png" alt="css世界学习笔记"></p><p><img src="/2018/04/02/css世界学习笔记/13.png" alt="css世界学习笔记"></p><h3 id="13-direction-rtl十分有用"><a href="#13-direction-rtl十分有用" class="headerlink" title="13.direction:rtl十分有用"></a>13.direction:rtl十分有用</h3><p>ltr 是初始值，表示 left-to-right，就是从左往右的意思。目前东亚以及欧美文字书写就 是从左往右的；rtl 表示 right-to-left，就是从右往左的意思。配合text-align来用在某些场景很有用！另外，配合unicode-bidi 属性也了解一下。</p><h3 id="14-writing-mode实现纵向文字"><a href="#14-writing-mode实现纵向文字" class="headerlink" title="14.writing-mode实现纵向文字"></a>14.writing-mode实现纵向文字</h3><p>配合text-indent可以实现以下效果：<br><img src="/2018/04/02/css世界学习笔记/14.png" alt="css世界学习笔记"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-盒子双重性&quot;&gt;&lt;a href=&quot;#1-盒子双重性&quot; class=&quot;headerlink&quot; title=&quot;1.盒子双重性&quot;&gt;&lt;/a&gt;1.盒子双重性&lt;/h3&gt;&lt;p&gt;按照 display 的属性值不同，值为 block 的元素的盒子实际由外在的“块级盒子” 和内在的
      
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css揭秘学习笔记</title>
    <link href="http://yoursite.com/2017/10/17/css%E6%8F%AD%E7%A7%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/10/17/css揭秘学习笔记/</id>
    <published>2017-10-16T16:00:00.000Z</published>
    <updated>2018-04-22T08:47:58.521Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、关于自适应媒体查询</strong></p><p>下面还有一些建议，可能会帮你避免不必要的媒体查询。</p><p>1.尝试使用与视口相关的单位（vw、vh、vmin和vmax），它们的值解析为视口宽度或高度的百分比。</p><p>2.当你需要在较大分辨率下得到固定宽度时，使用max-width而不是width，因为它可以适应较小的分辨率，而无需使用媒体查询。</p><p>3.不要忘记为替换元素（比如img、object、video、iframe等）设置一个max-width，值为100%。</p><p>4.假如背景图片需要完整地铺满一个容器，不管容器的尺寸如何变化，background-size:cover这个属性都可以做到。但是，我们也要时刻牢记——带宽并不是无限的，因此在移动网页中通过CSS把一张大图缩小显示往往是不太明智的。</p><p>5.当图片（或其他元素）以行列式进行布局时，让视口的宽度来决定列的数量。弹性盒布局（即Flexbox）或者display:inline-block加上常规的文本折行行为，都可以实现这一点。</p><p>6.在 使 用 多 列 文 本 时，指定column-width（列 宽）而 不 是 指 定column-count（列数），这样它就可以在较小的屏幕上自动显示为单列布局。</p><hr><p><strong>二、半透明边框</strong></p><p>默认状态下，背景会延伸到边框的区域下层。</p><p>我们可以通过background-clip属性来调整上述默认行为所带来的不便。这个属性的初始值是border-box，意味着背景会被元素的border  box（边框的外沿框）裁切掉。如果不希望背景侵入边框所在的范围，我们要做的就是把它的值设为padding-box，这样浏览器就会用内边距的外沿来把背景裁切掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid hsla(0,0%,100%,.5);</span><br><span class="line">background:white;</span><br><span class="line">background-clip:padding-box;</span><br></pre></td></tr></table></figure></p><hr><p><strong>三、利用投影实现多重边框</strong></p><p>唯一需要注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依次类推。因此，你需要按此规律调整扩张半径。比如说，在前面的代码中，我们想在外圈再加一道5px的外框，那就需要指定扩张半径的值为15px（10px+5px）。如果你愿意，甚至还可以在这些“边框”的底下再加一层常规的投影：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background:yellowgreen;</span><br><span class="line">box-shadow:0 0 0 10px #655,</span><br><span class="line">0 0 0 15px deeppink,</span><br><span class="line">0 2px 5px 15px rgba(0,0,0,.6);</span><br></pre></td></tr></table></figure><p>投影的行为跟边框不完全一致，因为它不会影响布局，而且也不会受到box-sizing属性的影响。不过，你还是可以通过内边距或外边距（这取决于投影是内嵌和还是外扩的）来额外模拟出边框所需要占据的空间。</p><p>上述方法所创建出的假“边框”出现在元素的外圈。它们并不会响应鼠标事件，比如悬停或点击。如果这一点非常重要，你可以给box-shadow属性加上inset关键字，来使投影绘制在元素的内圈。请注意，此时你需要增加额外的内边距来腾出足够的空隙。</p><hr><p><strong>四、background-position</strong></p><p>举例来说，如果想让背景图片跟右边缘保持20px的偏移量，同时跟底边保持10px的偏移量，同时兼容不支持这一特性的浏览器时，可以这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background:url(code-pirate.svg) no-repeat bottom right #58a;</span><br><span class="line">background-position:right 20px bottom 10px;</span><br></pre></td></tr></table></figure><hr><p><strong>五、利用background-origin改变背景区域</strong></p><p>在网页开发生涯中，你很可能多次写过类似background-position: top  left;这样的代码。你是否曾经有过疑惑：这个top  left到底是哪个左上角？你可能知道，每个元素身上都存在三个矩形框：border box（边框的外沿框）、paddingbox（内边距的外沿框）和content box（内容区的外沿框）。那background-position这个属性指定的到底是哪个矩形框的左上角？</p><p>默认情况下，background-position是以paddingbox为准的，这样边框才不会遮住背景图片。因此，topleft默认指的是padding  box的左上角。不过，我们得到了一个新的属性background-origin，可以用它来改变这种行为。在默认情况下，它的值是（闭着眼睛也猜得到）padding-box。如果把它的值改成content-box（参见下面的代码），我们在background-position属性中使用的边角关键字将会以内容区的边缘作为基准（也就是说，此时背景图片距离边角的偏移量就跟内边距保持一致了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">padding:10px;</span><br><span class="line">background:url(&quot;code-pirate.svg&quot;) no-repeat #58a</span><br><span class="line">bottom right; /* 或100% 100% */</span><br><span class="line">background-origin:content-box;</span><br></pre></td></tr></table></figure><p>这样就可以实现跟第四点一样的效果。</p><hr><p><strong>六、calc()</strong></p><p>请不要忘记在calc()函数内部的-和+运算符的两侧各加一个空白符，否则会产生解析错误！这个规则如此怪异，是为了向前兼容：未来，在calc()内部可能会允许使用关键字，而这些关键字可能会包含连字符。</p><p>让我们回顾一下本节开头的挑战：把背景图片定位到距离底边10px且距离右边20px的位置。如果我们仍然以左上角偏移的思路来考虑，其实就是希望它有一个100%  -20px的水平偏移量，以及100%  -  10px的垂直偏移量。谢天谢地，calc()函数允许我们执行此类运算，它可以完美地在background-position属性中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background:url(&quot;code-pirate.svg&quot;) no-repeat;</span><br><span class="line">background-position:calc(100% - 20px)calc(100% - 10px);</span><br></pre></td></tr></table></figure><hr><p><strong>七、利用linear-gradient实现多色条纹背景</strong></p><p>如果我们把第二个色标的位置值设置为0，那它的位置就总是会被浏览器调整为前一个色标的位置值。</p><p>水平条纹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background:linear-gradient(#fb3 33.3%,#58a 0,#58a 66.6%,yellowgreen 0);</span><br><span class="line">background-size:100% 45px;</span><br></pre></td></tr></table></figure><p>垂直条纹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background:linear-gradient(to right, /* 或90deg */</span><br><span class="line">#fb3 50%,#58a 0);</span><br><span class="line">background-size:30px 100%;</span><br></pre></td></tr></table></figure><p>斜向条纹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background:linear-gradient(45deg,</span><br><span class="line">#fb3 25%,#58a 0,#58a 50%,</span><br><span class="line">#fb3 0,#fb3 75%,#58a 0);</span><br><span class="line">background-size:30px 30px;</span><br></pre></td></tr></table></figure><hr><p><strong>八、border-radius</strong></p><p>说到border-radius，有一个鲜为人知的真相：它可以单独指定水平和垂直半径，只要用一个斜杠（/）分隔这两个值即可。这个特性允许我们在拐角处创建椭圆圆角（参见图3-3）。因此，如果我们有一个尺寸为200px×150px的元素，就可以把它圆角的两个半径值分别指定为元素宽高的一半，从而得到一个精确的椭圆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-radius:100px /75px;</span><br></pre></td></tr></table></figure><hr><p><strong>九、平行四边形</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;button&quot;&gt;按钮1&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.button &#123;</span><br><span class="line">position:relative;</span><br><span class="line">display:inline-block;</span><br><span class="line">/* 其他的文字颜色、内边距等样式……*/</span><br><span class="line">&#125;</span><br><span class="line">.button::before &#123;</span><br><span class="line">content: &apos;&apos;; /* 用伪元素来生成一个矩形*/</span><br><span class="line">position:absolute;</span><br><span class="line">top:0; right:0; bottom:0; left:0;</span><br><span class="line">z-index: -1;</span><br><span class="line">background:#58a;</span><br><span class="line">transform:skew(45deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>十、菱形相册</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.picture &#123;</span><br><span class="line">width:400px;</span><br><span class="line">transform:rotate(45deg);</span><br><span class="line">overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.picture &gt;img &#123;</span><br><span class="line">max-width:100%;</span><br><span class="line">transform: rotate(-45deg)scale(1.42);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，可以用clip-path的方法来实现，它还可以参与动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img &#123;</span><br><span class="line">clip-path:polygon(50% 0,100% 50%,</span><br><span class="line">50% 100%,0 50%);</span><br><span class="line">transition:1s clip-path;</span><br><span class="line">&#125;</span><br><span class="line">img:hover &#123;</span><br><span class="line">clip-path:polygon(0 0,100% 0,</span><br><span class="line">100% 100%,0 100%);</span><br></pre></td></tr></table></figure><hr><p><strong>十一、切角实现</strong></p><p>四个角都是切角：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">background:#58a;</span><br><span class="line">background:</span><br><span class="line">linear-gradient(135deg,transparent 15px,#58a 0)</span><br><span class="line">top left,</span><br><span class="line">linear-gradient(-135deg,transparent 15px,#58a 0)</span><br><span class="line">top right,</span><br><span class="line">linear-gradient(-45deg,transparent 15px,#58a 0)</span><br><span class="line">bottom right,</span><br><span class="line">linear-gradient(45deg,transparent 15px,#58a 0)</span><br><span class="line">bottom left;</span><br><span class="line">background-size:50% 50%;</span><br><span class="line">background-repeat:no-repeat;</span><br></pre></td></tr></table></figure><hr><p><strong>十二、单行打字动画</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@keyframes typing &#123;</span><br><span class="line">    from &#123; width: 0 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes caret &#123;</span><br><span class="line">    50% &#123; border-right-color: transparent; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">    font: bold 200% Consolas, Monaco, monospace;</span><br><span class="line">    /*width: 8.25em;*/</span><br><span class="line">    width: 15ch;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    border-right: .05em solid;</span><br><span class="line">    animation: typing 8s steps(15),</span><br><span class="line">               caret 1s steps(1) infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、关于自适应媒体查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面还有一些建议，可能会帮你避免不必要的媒体查询。&lt;/p&gt;
&lt;p&gt;1.尝试使用与视口相关的单位（vw、vh、vmin和vmax），它们的值解析为视口宽度或高度的百分比。&lt;/p&gt;
&lt;p&gt;2.当你需要在较大
      
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>web缓存</title>
    <link href="http://yoursite.com/2017/09/12/web%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2017/09/12/web缓存/</id>
    <published>2017-09-11T16:00:00.000Z</published>
    <updated>2018-03-18T12:29:40.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。"><a href="#Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。" class="headerlink" title="Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存 。"></a>Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存 。</h2><p>浏览器HTTP缓存可以分为强缓存和协商缓存。强缓存和协商缓存最大也是最根本的区别是：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache），协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。简略流程图如下：</p><p><img src="/2017/09/12/web缓存/1.png" alt="web缓存流程图1"></p><p><img src="/2017/09/12/web缓存/2.png" alt="web缓存流程图2"></p><p>浏览器HTTP缓存由HTTP报文的首部字段决定</p><h2 id="控制强缓存的字段按优先级介绍："><a href="#控制强缓存的字段按优先级介绍：" class="headerlink" title="控制强缓存的字段按优先级介绍："></a>控制强缓存的字段按优先级介绍：</h2><h3 id="1-Pragma"><a href="#1-Pragma" class="headerlink" title="1.Pragma"></a>1.Pragma</h3><p>Pragma是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。虽然它是一个通用首部，但是它在响应报文中时的行为没有规范，依赖于浏览器的实现。RFC中该字段只有no-cache一个可选值，会通知浏览器不直接使用缓存，要求向服务器发请求校验新鲜度。因为它优先级最高，当存在时一定不会命中强缓存。</p><h3 id="2-Expires"><a href="#2-Expires" class="headerlink" title="2.Expires"></a>2.Expires</h3><p>Expires是一个响应首部字段，它指定了一个日期/时间，在这个时间/日期之前，HTTP缓存被认为是有效的。无效的日期比如0，表示这个资源已经过期了。如果同时设置了Cache-Control响应首部字段的max-age，则Expires会被忽略。它也是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。</p><h3 id="3-Cache-Control"><a href="#3-Cache-Control" class="headerlink" title="3.Cache-Control"></a>3.Cache-Control</h3><p>Cache-Control是一个通用首部字段，也是HTTP/1.1控制浏览器缓存的主流字段。和浏览器缓存相关的是如下几个响应指令：</p><p>指令 参数 说明</p><p>private 无 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）</p><p>public 可省略 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存</p><p>no-cache 可省略 缓存前必需确认其有效性</p><p>no-store 无 不缓存请求或响应的任何内容</p><p>max-age=[s] 必需 响应的最大值</p><p>max-age（单位为s）设置缓存的存在时间，相对于发送请求的时间。只有响应报文首部设置Cache-Control为非0的max-age或者设置了大于请求日期的Expires（下文会讲）才有可能命中强缓存。当满足这个条件，同时响应报文首部中Cache-Control不存在no-cache、no-store且请求报文首部不存在Pragma字段，才会真正命中强缓存。max-age=0相当于no-cache。</p><p>no-cache 表示请求必须先与服务器确认缓存的有效性，如果有效才能使用缓存（协商缓存），无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存。Chrome硬性重新加载（Command+shift+R）会在请求的首部加上Pragma：no-cache和Cache-Control：no-cache。会缓存，但是使用这份缓存之前先到服务器上确认这份缓存是不是最新的，是最新的才使用。</p><p>no-store 表示禁止浏览器以及所有中间缓存存储任何版本的返回响应，一定不会出现强缓存和协商缓存，适合个人隐私数据或者经济类数据。绝对不缓存。</p><p>public 表明响应可以被浏览器、CDN等等缓存。</p><p>private 响应只作为私有的缓存，不能被CDN等缓存。如果要求HTTP认证，响应会自动设置为private。</p><h2 id="控制协商缓存的字段："><a href="#控制协商缓存的字段：" class="headerlink" title="控制协商缓存的字段："></a>控制协商缓存的字段：</h2><h3 id="1-Last-Modified-If-Modified-Since"><a href="#1-Last-Modified-If-Modified-Since" class="headerlink" title="1.Last-Modified/If-Modified-Since"></a>1.Last-Modified/If-Modified-Since</h3><p>If-Modified-Since是一个请求首部字段，并且只能用在GET或者HEAD请求中。Last-Modified是一个响应首部字段，包含服务器认定的资源作出修改的日期及时间。当带着If-Modified-Since头访问服务器请求资源时，服务器会检查Last-Modified，如果Last-Modified的时间早于或等于If-Modified-Since则会返回一个不带主体的304响应，否则将重新返回资源。</p><h3 id="2-ETag-If-None-Match"><a href="#2-ETag-If-None-Match" class="headerlink" title="2.ETag/If-None-Match"></a>2.ETag/If-None-Match</h3><p>ETag是一个响应首部字段，它是根据实体内容生成的一段hash字符串，标识资源的状态，由服务端产生。If-None-Match是一个条件式的请求首部。如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的ETag，则当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的200响应，否则服务器会返回不带实体的304响应。ETag优先级比Last-Modified高，同时存在时会以ETag为准。</p><h3 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h3><p>在有效期内更新资源可以用资源加时间戳命名的方式，如下图的<img>。<br>按F5相当于no-cache，按ctrl+f5相当于强制刷新，拉取新资源。</p><h3 id="缓存策略："><a href="#缓存策略：" class="headerlink" title="缓存策略："></a>缓存策略：</h3><p>html文件用no-cache的方式设置，css,js文件用max-age设置.</p><p>首先对静态资源进行版本控制（比如给静态资源的文件名加上hash值），其次对网页设置合适时长的缓存时间（长短取决于实际场景）。这样就兼顾了版本升级和性能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。&quot;&gt;&lt;a href=&quot;#Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。&quot; class=&quot;headerlink&quot; title=&quot;Web缓存可以分为这几种
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="web缓存" scheme="http://yoursite.com/tags/web%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Three.js开发指南笔记</title>
    <link href="http://yoursite.com/2017/08/12/Three.js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/12/Three.js开发指南笔记/</id>
    <published>2017-08-11T16:00:00.000Z</published>
    <updated>2018-04-22T08:14:06.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-渲染器初始化"><a href="#1-渲染器初始化" class="headerlink" title="1.渲染器初始化"></a>1.渲染器初始化</h2><p>渲染器将和Canvas元素进行绑定，如果之前在HTML中手动定义了id为mainCanvas的Canvas元素，那么Renderer可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var renderer = new THREE.WebGLRenderer(&#123;</span><br><span class="line">    canvas: document.getElementById(&apos;mainCanvas&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而如果想要Three.js生成Canvas元素，在HTML中就不需要定义Canvas元素，在JavaScript代码中可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var renderer = new THREE.WebGLRenderer();</span><br><span class="line">renderer.setSize(400, 300);</span><br><span class="line">document.getElementsByTagName(&apos;body&apos;)[0].appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure><p>背景色（清除色）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.setClearColor(0x000000);</span><br></pre></td></tr></table></figure></p><h2 id="2-场景相关API"><a href="#2-场景相关API" class="headerlink" title="2.场景相关API"></a>2.场景相关API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scene.add();    //添加东西</span><br><span class="line">scene.remove();    //移除东西</span><br><span class="line">scene.children();    //获取场景中所有子对象</span><br><span class="line">scene.getChildByName();    //利用name属性，获取场景中某个特定物体</span><br><span class="line">scene.traverse();   //参数接受一个函数，场景中每个子对象都会执行的，相当于forEach</span><br><span class="line"></span><br><span class="line">scene.fog = new THREE.Fog(0xffffff,0.015,100);  //雾化(两个参数时1是雾的颜色，2是雾的浓度；三个参数时1是雾的颜色，2是near值，3是far值)</span><br><span class="line"></span><br><span class="line">scene.overrideMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;);   //设置场景中所有物体的材质</span><br></pre></td></tr></table></figure><h2 id="3-正交投影vs透视投影"><a href="#3-正交投影vs透视投影" class="headerlink" title="3.正交投影vs透视投影"></a>3.正交投影vs透视投影</h2><p>使用透视投影照相机获得的结果是类似人眼在真实世界中看到的有“近大远小”的效果；而使用正交投影照相机获得的结果就像我们在数学几何学课上老师教我们画的效果，对于在三维空间内平行的线，投影到二维空间中也一定是平行的。</p><p>一般说来，对于制图、建模软件通常使用正交投影，这样不会因为投影而改变物体比例；而对于其他大多数应用，通常使用透视投影，因为这更接近人眼的观察效果。</p><h2 id="4-正交投影照相机"><a href="#4-正交投影照相机" class="headerlink" title="4.正交投影照相机"></a>4.正交投影照相机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.OrthographicCamera(left, right, top, bottom, near, far)</span><br></pre></td></tr></table></figure><p>这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，这六个面围成一个长方体，我们称其为视景体（Frustum）。只有在视景体内部（下图中的灰色部分）的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉。</p><p>为了保持照相机的横竖比例，需要保证(right - left)与(top - bottom)的比例与Canvas宽度与高度的比例一致。</p><p>near与far都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般near的值设置得较小，far的值设置得较大，具体值视场景中物体的位置等决定。</p><p><img src="http://www.ituring.com.cn/download/01YiZI4zr57Q.small" alt="camera"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//分别设置照相机的x,y,z位置</span><br><span class="line">camera.position.set(0,0,5);</span><br></pre></td></tr></table></figure><p>另外，因为照相机默认是看向z的负方向，所以要想照相机往其他方向看，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这样照相机就会看着(0,0,0)这个点（无论照相机在哪个位置）</span><br><span class="line">camera.lookAt(new THREE.Vector3(0,0,0));</span><br></pre></td></tr></table></figure><h2 id="5-透视投影照相机"><a href="#5-透视投影照相机" class="headerlink" title="5.透视投影照相机"></a>5.透视投影照相机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.PerspectiveCamera(fov, aspect, near, far);</span><br><span class="line">var camera = new THREE.PerspectiveCamera(45, 400 / 300, 1, 10);</span><br></pre></td></tr></table></figure><p><img src="http://www.ituring.com.cn/download/01YYrMaASOzm.small" alt="camera"></p><p>透视图中，灰色的部分是视景体，是可能被渲染的物体所在的区域。fov是视景体竖直方向上的张角（是角度制而非弧度制），如侧视图所示。</p><p>aspect等于width / height，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。</p><p>near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near。</p><h2 id="6-立方体"><a href="#6-立方体" class="headerlink" title="6.立方体"></a>6.立方体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)</span><br></pre></td></tr></table></figure><p>width是x方向上的长度；height是y方向上的长度；depth是z方向上的长度；后三个参数分别是在三个方向上的分段数，如widthSegments为3的话，代表x方向上水平分为三份。一般情况下不需要分段的话，可以不设置后三个参数，后三个参数的缺省值为1。其他几何形状中的分段也是类似的，下面不做说明。</p><h2 id="7-平面"><a href="#7-平面" class="headerlink" title="7.平面"></a>7.平面</h2><p>这里的平面（PlaneGeometry）其实是一个长方形，而不是数学意义上无限大小的平面。其构造函数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.PlaneGeometry(width, height, widthSegments, heightSegments)</span><br></pre></td></tr></table></figure></p><p>其中，width是x方向上的长度；height是y方向上的长度；后两个参数同样表示分段。</p><h2 id="8-球体"><a href="#8-球体" class="headerlink" title="8.球体"></a>8.球体</h2><p>其中，radius是半径；segmentsWidth表示经度上的切片数；segmentsHeight表示纬度上的切片数；phiStart表示经度开始的弧度；phiLength表示经度跨过的弧度；thetaStart表示纬度开始的弧度；thetaLength表示纬度跨过的弧度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure><h2 id="9-圆形"><a href="#9-圆形" class="headerlink" title="9.圆形"></a>9.圆形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure><h2 id="10-圆柱体"><a href="#10-圆柱体" class="headerlink" title="10.圆柱体"></a>10.圆柱体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)</span><br></pre></td></tr></table></figure><p>其中，radiusTop与radiusBottom分别是顶面和底面的半径，由此可知，当这两个参数设置为不同的值时，实际上创建的是一个圆台；height是圆柱体的高度；radiusSegments与heightSegments可类比球体中的分段；openEnded是一个布尔值，表示是否没有顶面和底面，缺省值为false，表示有顶面和底面。</p><h2 id="11-正n面体"><a href="#11-正n面体" class="headerlink" title="11.正n面体"></a>11.正n面体</h2><p>正四面体（TetrahedronGeometry）、正八面体（OctahedronGeometry）、正二十面体（IcosahedronGeometry）的构造函数较为类似，分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">THREE.TetrahedronGeometry(radius, detail)</span><br><span class="line">THREE.OctahedronGeometry(radius, detail)</span><br><span class="line">THREE.IcosahedronGeometry(radius, detail)</span><br></pre></td></tr></table></figure><p>其中，radius是半径；detail是细节层次（Level of Detail）的层数，对于大面片数模型，可以控制在视角靠近物体时，显示面片数多的精细模型，而在离物体较远时，显示面片数较少的粗略模型。这里我们不对detail多作展开，一般可以对这个值缺省。</p><h2 id="12-圆环面"><a href="#12-圆环面" class="headerlink" title="12.圆环面"></a>12.圆环面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc)</span><br></pre></td></tr></table></figure><p>其中，radius是圆环半径；tube是管道半径；radialSegments与tubularSegments分别是两个分段数，详见上图；arc是圆环面的弧度，缺省值为Math.PI * 2。</p><p><img src="http://www.ituring.com.cn/download/01YZGqQBQI0k" alt="pt"></p><h2 id="13-圆环结"><a href="#13-圆环结" class="headerlink" title="13.圆环结"></a>13.圆环结</h2><p>如果说圆环面是甜甜圈，那么圆环结（TorusKnotGeometry）就是打了结的甜甜圈，其构造参数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments, p, q, heightScale)</span><br></pre></td></tr></table></figure></p><p>前四个参数在圆环面中已经有所介绍，p和q是控制其样式的参数，一般可以缺省，如果需要详细了解，请学习圆环结的相关知识；heightScale是在z轴方向上的缩放。</p><h2 id="14-文字形状"><a href="#14-文字形状" class="headerlink" title="14.文字形状"></a>14.文字形状</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TextGeometry(text, parameters);</span><br></pre></td></tr></table></figure><p>其中，text是文字字符串，parameters是以下参数组成的对象：</p><p>size：字号大小，一般为大写字母的高度</p><p>height：文字的厚度</p><p>curveSegments：弧线分段数，使得文字的曲线更加光滑</p><p>font：字体，默认是’helvetiker’，需对应引用的字体文件</p><p>weight：值为’normal’或’bold’，表示是否加粗</p><p>style：值为’normal’或’italics’，表示是否斜体</p><p>bevelEnabled：布尔值，是否使用倒角，意为在边缘处斜切</p><p>bevelThickness：倒角厚度</p><p>bevelSize：倒角宽度</p><p>ps:加载字体示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.FontLoader();</span><br><span class="line">loader.load(&apos;../lib/helvetiker_regular.typeface.json&apos;, function(font) &#123;</span><br><span class="line">    var mesh = new THREE.Mesh(new THREE.TextGeometry(&apos;Hello&apos;, &#123;</span><br><span class="line">        font: font,</span><br><span class="line">        size: 1,</span><br><span class="line">        height: 1</span><br><span class="line">    &#125;), material);</span><br><span class="line">    scene.add(mesh);</span><br><span class="line"></span><br><span class="line">    // render</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="15-自定义形状"><a href="#15-自定义形状" class="headerlink" title="15.自定义形状"></a>15.自定义形状</h2><p>由于自定义形状需要手动指定每个顶点位置，以及顶点连接情况，如果该形状非常复杂，程序员的计算量就会比较大。在这种情况下，建议在3ds Max之类的建模软件中创建模型，然后使用Three.js导入到场景中，这样会更高效方便。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 初始化几何形状</span><br><span class="line">var geometry = new THREE.Geometry();</span><br><span class="line"></span><br><span class="line">// 设置顶点位置</span><br><span class="line">// 顶部4顶点</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-1, 2, -1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(1, 2, -1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(1, 2, 1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-1, 2, 1));</span><br><span class="line">// 底部4顶点</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-2, 0, -2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(2, 0, -2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(2, 0, 2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-2, 0, 2));</span><br><span class="line"></span><br><span class="line">// 设置顶点连接情况</span><br><span class="line">// 顶面</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 1, 3));</span><br><span class="line">geometry.faces.push(new THREE.Face3(1, 2, 3));</span><br><span class="line">// 底面</span><br><span class="line">geometry.faces.push(new THREE.Face3(4, 5, 6));</span><br><span class="line">geometry.faces.push(new THREE.Face3(5, 6, 7));</span><br><span class="line">// 四个侧面</span><br><span class="line">geometry.faces.push(new THREE.Face3(1, 5, 6));</span><br><span class="line">geometry.faces.push(new THREE.Face3(6, 2, 1));</span><br><span class="line">geometry.faces.push(new THREE.Face3(2, 6, 7));</span><br><span class="line">geometry.faces.push(new THREE.Face3(7, 3, 2));</span><br><span class="line">geometry.faces.push(new THREE.Face3(3, 7, 0));</span><br><span class="line">geometry.faces.push(new THREE.Face3(7, 4, 0));</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 4, 5));</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 5, 1));</span><br></pre></td></tr></table></figure></p><p>需要注意的是，new THREE.Vector3(-1, 2, -1)创建一个矢量，作为顶点位置追加到geometry.vertices数组中。</p><p>而由new THREE.Face3(0, 1, 3)创建一个三个顶点组成的面片，追加到geometry.faces数组中。三个参数分别是四个顶点在geometry.vertices中的序号。</p><h2 id="16-简单材质"><a href="#16-简单材质" class="headerlink" title="16.简单材质"></a>16.简单材质</h2><h3 id="1-基础材质"><a href="#1-基础材质" class="headerlink" title="1.基础材质"></a>1.基础材质</h3><p>对于基本材质，即使改变场景中的光源，使用该材质的物体也始终为颜色处处相同的效果。当然，这不是很具有真实感。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    color: 0xffff00,</span><br><span class="line">    opacity: 0.75</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可以设置以下属性：</p><p>visible：是否可见，默认为true</p><p>side：渲染面片正面或是反面，默认为正面THREE.FrontSide，可设置为反面THREE.BackSide，或双面THREE.DoubleSide</p><p>wireframe：是否渲染线而非面，默认为false</p><p>color：十六进制RGB颜色，如红色表示为0xff0000</p><p>map：使用纹理贴图</p><h3 id="2-深度材质"><a href="#2-深度材质" class="headerlink" title="2.深度材质"></a>2.深度材质</h3><p>其外观不由光照或某个材质属性决定，而是由物体到相机的距离决定。</p><p>可以将这种材质与其他材质相结合，很容易创建出逐渐消失的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var depthMaterial = new THREE.MeshDepthMaterial();</span><br><span class="line">depthMaterial.wireframe = true;  //是否显示线框</span><br><span class="line">depthMaterial.wireframeLineWidth = 10;  //线框线的宽度</span><br></pre></td></tr></table></figure><h3 id="3-联合材质"><a href="#3-联合材质" class="headerlink" title="3.联合材质"></a>3.联合材质</h3><p>把材质结合起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cube = new THREE.SceneUtils.createMultiMaterialObject(geometry,[basicMaterial,depthMaterial]);</span><br></pre></td></tr></table></figure><h3 id="4-每个面材质"><a href="#4-每个面材质" class="headerlink" title="4.每个面材质"></a>4.每个面材质</h3><p>相当于一个材质容器，为几何体每一个面制定不同的材质</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var matArray = [</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0x009e60&#125;),</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0x0051ba&#125;),</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0xffd500&#125;),</span><br><span class="line">];</span><br><span class="line">var faceMaterial = new THREE.MeshFaceMaterial(matArray);</span><br></pre></td></tr></table></figure><p>ps:要创建一种透明的材质，仅仅设置opacity:0是不够的，还要将transparent设为0。为一个几何体赋予多种材质会复制几何体，从而创建出多个网格。</p><h2 id="17-Lambert材质"><a href="#17-Lambert材质" class="headerlink" title="17.Lambert材质"></a>17.Lambert材质</h2><p>Lambert材质（MeshLambertMaterial）是符合Lambert光照模型的材质。Lambert光照模型的主要特点是只考虑漫反射而不考虑镜面反射的效果，因而对于金属、镜子等需要镜面反射效果的物体就不适应，对于其他大部分物体的漫反射效果都是适用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xffff00</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>color是用来表现材质对散射光的反射能力，也是最常用来设置材质颜色的属性。除此之外，还可以用ambient和emissive控制材质的颜色。</p><p>ambient表示对环境光的反射能力，只有当设置了AmbientLight后，该值才是有效的，材质对环境光的反射能力与环境光强相乘后得到材质实际表现的颜色。</p><p>emissive是材质的自发光颜色，可以用来表现光源的颜色。</p><h2 id="18-Phong材质"><a href="#18-Phong材质" class="headerlink" title="18.Phong材质"></a>18.Phong材质</h2><p>Phong材质（MeshPhongMaterial）是符合Phong光照模型的材质。和Lambert不同的是，Phong模型考虑了镜面反射的效果，因此对于金属、镜面的表现尤为适合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">material = new THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color: 0xff0000,</span><br><span class="line">    specular: 0xffff00,</span><br><span class="line">    shininess: 100</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同样地，可以指定emissive和ambient值，这里不再说明。</p><p>可以通过shininess属性控制光照模型中的n值，当shininess值越大时，高光的光斑越小，默认值为30。</p><h2 id="19-法向材质"><a href="#19-法向材质" class="headerlink" title="19.法向材质"></a>19.法向材质</h2><p>法向材质可以将材质的颜色设置为其法向量的方向，有时候对于调试很有帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshNormalMaterial()</span><br></pre></td></tr></table></figure><p>材质的颜色与照相机与该物体的角度相关，我们只改变照相机位置，就可以观察两个角度的颜色变化。</p><h2 id="20-材质的纹理贴图"><a href="#20-材质的纹理贴图" class="headerlink" title="20.材质的纹理贴图"></a>20.材质的纹理贴图</h2><p>导入图像作为纹理贴图，并添加到相应的材质中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//单张图像应用于长方体</span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;);</span><br><span class="line"></span><br><span class="line">var material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    map: texture</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//可以用回调函数的方式来命令渲染：</span><br><span class="line"></span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;, &#123;&#125;, function() &#123;</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br><span class="line">var material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    map: texture</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>六个面应用不同的图像示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var materials = [];</span><br><span class="line">for (var i = 0; i &lt; 6; ++i) &#123;</span><br><span class="line">    materials.push(new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">        map: THREE.ImageUtils.loadTexture(&apos;../img/&apos; + i + &apos;.png&apos;,</span><br><span class="line">                &#123;&#125;, function() &#123;</span><br><span class="line">                    renderer.render(scene, camera);</span><br><span class="line">                &#125;),</span><br><span class="line">        overdraw: true</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cube = new THREE.Mesh(new THREE.CubeGeometry(5, 5, 5),</span><br><span class="line">        new THREE.MeshFaceMaterial(materials));</span><br><span class="line">scene.add(cube);</span><br></pre></td></tr></table></figure></p><p>棋盘格（复制渲染）：</p><p>原图片：<br><img src="http://www.ituring.com.cn/download/01YdRC86nAUx" alt="pt"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//导入材质</span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/chess.png&apos;, &#123;&#125;, function() &#123;</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可是，棋盘格是8横8纵64个小方格组成的，那应该怎么办呢？</span><br><span class="line"></span><br><span class="line">//首先，我们需要指定重复方式为两个方向（wrapS和wrapT）都重复：</span><br><span class="line">texture.wrapS = texture.wrapT = THREE.RepeatWrapping;</span><br><span class="line"></span><br><span class="line">//然后，设置两个方向上都重复4次，由于我们的图像本来是有2行2列，所以重复4次即为8行8列：</span><br><span class="line">texture.repeat.set(4, 4);</span><br></pre></td></tr></table></figure><p>最后就得到了棋盘格：<br><img src="http://www.ituring.com.cn/download/01YdRCMAK2Xq" alt="pt"></p><h2 id="21-网格"><a href="#21-网格" class="headerlink" title="21.网格"></a>21.网格</h2><p>而网格的创建非常简单，只要把几何形状与材质传入其构造函数。最常用的物体是网格（Mesh），它代表包含点、线、面的几何体，其构造函数是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mesh = new THREE.Mesh(geometry, material);</span><br></pre></td></tr></table></figure></p><p>在网格被创建后，也能对材质进行修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xff0000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>位置、缩放、旋转:</p><p>位置、缩放、旋转是物体三个常用属性。由于THREE.Mesh基础自THREE.Object3D，因此包含scale、rotation、position三个属性。它们都是THREE.Vector3实例，因此修改其值的方法是相同的，这里以位置为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.position.z = 1;</span><br><span class="line">或</span><br><span class="line">mesh.position.set(1.5, -0.5, 0);</span><br></pre></td></tr></table></figure><h2 id="22-动画"><a href="#22-动画" class="headerlink" title="22.动画"></a>22.动画</h2><p>setInterval方法与requestAnimationFrame方法的区别较为微妙。一方面，最明显的差别表现在setInterval可以手动设定FPS，而requestAnimationFrame则会自动设定FPS；但另一方面，即使是setInterval也不能保证按照给定的FPS执行，在浏览器处理繁忙时，很可能低于设定值。当浏览器达不到设定的调用周期时，requestAnimationFrame采用跳过某些帧的方式来表现动画，虽然会有卡滞的效果但是整体速度不会拖慢，而setInterval会因此使整个程序放慢运行，但是每一帧都会绘制出来；</p><p>总而言之，requestAnimationFrame适用于对于时间较为敏感的环境（但是动画逻辑更加复杂），而setInterval则可在保证程序的运算不至于导致延迟的情况下提供更加简洁的逻辑（无需自行处理时间）。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">    mesh.rotation.y = (mesh.rotation.y + 0.01) % (Math.PI * 2);</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">    id = requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ps:可以使用stat.js记录FPS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stats.setMode(0);//监测FPS</span><br><span class="line">stats.setMode(1);//监测渲染时间</span><br></pre></td></tr></table></figure><p>详情请见：(使用stat.js记录FPS)[<a href="http://www.ituring.com.cn/book/miniarticle/53353]" target="_blank" rel="noopener">http://www.ituring.com.cn/book/miniarticle/53353]</a></p><h2 id="23-外部导入"><a href="#23-外部导入" class="headerlink" title="23.外部导入"></a>23.外部导入</h2><p>Three.js有一系列导入外部文件的辅助函数，是在three.js之外的，使用前需要额外下载，在(loaders)[<a href="https://github.com/mrdoob/three.js/tree/master/examples/js/loaders]可以找到。" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders]可以找到。</a></p><p>.obj是最常用的模型格式，导入.obj文件需要OBJLoader.js；</p><p>导入带.mtl材质的.obj文件需要MTLLoader.js以及OBJMTLLoader.js。另有PLYLoader.js、STLLoader.js等分别对应不同格式的加载器，可以根据模型格式自行选择。</p><p>导入过程：<a href="http://www.ituring.com.cn/book/miniarticle/53865" target="_blank" rel="noopener">无材质的模型</a><br>         <a href="http://www.ituring.com.cn/book/miniarticle/53881" target="_blank" rel="noopener">有材质的模型</a></p><h2 id="24-环境光"><a href="#24-环境光" class="headerlink" title="24.环境光"></a>24.环境光</h2><p>环境光是指场景整体的光照效果，是由于场景内若干光源的多次反射形成的亮度一致的效果，通常用来为整个场景指定一个基础亮度。因此，环境光没有明确的光源位置，在各处形成的亮度也是一致的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var light = new THREE.AmbientLight(0xffffff);</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure></p><p>环境光并不在乎物体材质的color属性，而是在乎ambient属性。ambient属性的默认值是0xffffff。</p><p>ambient为0x00ff00的长方体被渲染成了黑色。这是因为不透明物体的颜色其实是其反射光的颜色，而ambient属性表示的是物体反射环境光的能力。对于0x00ff00的物体，红色通道是0，而环境光是完全的红光，因此该长方体不能反射任何光线，最终的渲染颜色就是黑色；而对于0xffffff的白色长方体，红色通道是0xff，因而能反射所有红光，渲染的颜色就是红色。</p><p>前面我们看到，当环境光不是白色或灰色的时候，渲染的效果往往会很奇怪。因此，环境光通常使用白色或者灰色，作为整体光照的基础。</p><h2 id="25-点光源"><a href="#25-点光源" class="headerlink" title="25.点光源"></a>25.点光源</h2><p>点光源是不计光源大小，可以看作一个点发出的光源。点光源照到不同物体表面的亮度是线性递减的，因此，离点光源距离越远的物体会显得越暗。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">THREE.PointLight(hex, intensity, distance);</span><br><span class="line"></span><br><span class="line">//应用示例：</span><br><span class="line"></span><br><span class="line">var light = new THREE.PointLight(0xffffff, 2, 100);</span><br><span class="line">light.color = &quot;#ccffcc&quot;;    //设置光源颜色</span><br><span class="line">light.intensity = 1;    //光的强度</span><br><span class="line">light.position.set(0, 1.5, 2);  //设置光源位置</span><br><span class="line">light.distance = 100;   //光源照射距离（默认为0，也就是说光线亮度不会随着距离增加而递减）</span><br><span class="line">light.visible = true;   //光源是否开启</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure><p>其中，hex是光源十六进制的颜色值；intensity是亮度，缺省值为1，表示100%亮度；distance是光源最远照射到的距离，缺省值为0。</p><h2 id="26-平行光"><a href="#26-平行光" class="headerlink" title="26.平行光"></a>26.平行光</h2><p>我们都知道，太阳光常常被看作平行光，这是因为相对地球上物体的尺度而言，太阳离我们的距离足够远。对于任意平行的平面，平行光照射的亮度都是相同的，而与平面所在位置无关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">THREE.DirectionalLight(hex, intensity);</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">var light = new THREE.DirectionalLight();</span><br><span class="line">light.position.set(2, 5, 3);</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure><p>注意，这里设置光源位置并不意味着所有光从(2, 5, 3)点射出（如果是的话，就成了点光源），而是意味着，平行光将以矢量(-2, -5, -3)的方向照射到所有平面。因此，平面亮度与平面的位置无关，而只与平面的法向量相关。只要平面是平行的，那么得到的光照也一定是相同的。</p><h2 id="27-聚光灯"><a href="#27-聚光灯" class="headerlink" title="27.聚光灯"></a>27.聚光灯</h2><p>可以看出，聚光灯是一种特殊的点光源，它能够朝着一个方向投射光线。聚光灯投射出的是类似圆锥形的光线，这与我们现实中看到的聚光灯是一致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.SpotLight(hex, intensity, distance, angle, exponent)</span><br></pre></td></tr></table></figure><p>相比点光源，多了angle和exponent两个参数。angle是聚光灯的张角，缺省值是Math.PI / 3，最大值是Math.PI / 2；exponent是光强在偏离target的衰减指数（target需要在之后定义，缺省值为(0, 0, 0)），缺省值是10。</p><p>在调用构造函数之后，除了设置光源本身的位置，一般还需要设置target：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">light.position.set(x1, y1, z1);</span><br><span class="line">light.target.position.set(x2, y2, z2);</span><br></pre></td></tr></table></figure><p>除了设置light.target.position的方法外，如果想让聚光灯跟着某一物体移动（就像真的聚光灯！），可以target指定为该物体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),</span><br><span class="line">                    new THREE.MeshLambertMaterial(&#123;color: 0x00ff00&#125;));</span><br><span class="line"></span><br><span class="line">var light = new THREE.SpotLight(0xffff00, 1, 100, Math.PI / 6, 25);</span><br><span class="line">light.target = cube;</span><br></pre></td></tr></table></figure><h2 id="28-半球光"><a href="#28-半球光" class="headerlink" title="28.半球光"></a>28.半球光</h2><p>创建出更加贴近自然的户外光照效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var hemiLight = new THREE.HemisphereLight(0x0000ff,0x00ff00,0.6);   //参数分别是天空发出的颜色、地面发出的颜色、光线照射强度</span><br><span class="line"></span><br><span class="line">hemiLight.position.set(0,500,0);</span><br><span class="line">scene.add(hemiLight);</span><br></pre></td></tr></table></figure><h2 id="29-平面光（略）"><a href="#29-平面光（略）" class="headerlink" title="29.平面光（略）"></a>29.平面光（略）</h2><p>定义一个发光的矩形</p><h2 id="30-镜头眩光"><a href="#30-镜头眩光" class="headerlink" title="30.镜头眩光"></a>30.镜头眩光</h2><p>当你直接朝着太阳拍照时就会出现镜头眩光</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var lensFlare = new THREE.LensFlare(texture,350,0.5,THREE.AdditiveBlending,flareColor);</span><br><span class="line">//参数分别是眩光的材质，眩光尺寸(-1就表示用材质本身的尺寸)，光源(0)到相机(1)的距离，融合模式，颜色</span><br><span class="line"></span><br><span class="line">lensFlare.add(texture,60,0.6,THREE.AdditiveBlending);</span><br><span class="line">//增加眩光</span><br></pre></td></tr></table></figure><h2 id="31-阴影"><a href="#31-阴影" class="headerlink" title="31.阴影"></a>31.阴影</h2><p>在Three.js中，能形成阴影的光源只有THREE.DirectionalLight与THREE.SpotLight；而相对地，能表现阴影效果的材质只有THREE.LambertMaterial与THREE.PhongMaterial。因而在设置光源和材质的时候，一定要注意这一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//首先，我们需要在初始化时，告诉渲染器渲染阴影：</span><br><span class="line">renderer.shadowMapEnabled = true;</span><br><span class="line"></span><br><span class="line">//然后，对于光源以及所有要产生阴影的物体调用：</span><br><span class="line">xxx.castShadow = true;</span><br><span class="line"></span><br><span class="line">//对于接收阴影的物体调用：</span><br><span class="line">xxx.receiveShadow = true;</span><br></pre></td></tr></table></figure><p>对于聚光灯，需要设置shadowCameraNear、shadowCameraFar、shadowCameraFov三个值，类比我们在第二章学到的透视投影照相机，只有介于shadowCameraNear与shadowCameraFar之间的物体将产生阴影，shadowCameraFov表示张角。</p><p>对于平行光，需要设置shadowCameraNear、shadowCameraFar、shadowCameraLeft、shadowCameraRight、shadowCameraTop以及shadowCameraBottom六个值，相当于正交投影照相机的六个面。同样，只有在这六个面围成的长方体内的物体才会产生阴影效果。</p><p>为了看到阴影照相机的位置，通常可以在调试时开启light.shadowCameraVisible = true。</p><p>至此，阴影效果已经能正常显示了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">light.shadowCameraNear = 2;</span><br><span class="line">light.shadowCameraFar = 10;</span><br><span class="line">light.shadowCameraFov = 30;</span><br><span class="line">light.shadowCameraVisible = true;</span><br><span class="line"></span><br><span class="line">light.shadowMapWidth = 1024;</span><br><span class="line">light.shadowMapHeight = 1024;</span><br><span class="line">light.shadowDarkness = 0.3;</span><br></pre></td></tr></table></figure><h2 id="32-通过拉伸创建几何体"><a href="#32-通过拉伸创建几何体" class="headerlink" title="32.通过拉伸创建几何体"></a>32.通过拉伸创建几何体</h2><p>把二维图形拉伸成三维图形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//沿着Z轴拉伸</span><br><span class="line">var options = &#123;</span><br><span class="line">    amount:10,//图形可以拉多高</span><br><span class="line">    bevelThickness:2,//斜角厚度</span><br><span class="line">    bevelSize:1,//斜角尺寸</span><br><span class="line">    bevelSegments:3,//斜角分段数</span><br><span class="line">    bevelEnabled:true,//是否用斜角</span><br><span class="line">    curveSegments:12,//曲线分段数</span><br><span class="line">    steps:1//拉伸体段数</span><br><span class="line">&#125;;</span><br><span class="line">shape = createMesh(new THREE.ExtrudeGeometry(drawShape(),options));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//SVG图像2d变3d</span><br><span class="line">function drawShape()&#123;</span><br><span class="line">    var svgStr = $(&apos;#svg1&apos;).attr(&apos;d&apos;);</span><br><span class="line">    var shape = transformSVGPathExposed(svgStr);    //transformSVGPathExposed这个函数是d3-ThreeD库提供的</span><br><span class="line">    return shape;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var options = &#123;</span><br><span class="line">    amount:10,//图形可以拉多高</span><br><span class="line">    bevelThickness:2,//斜角厚度</span><br><span class="line">    bevelSize:1,//斜角尺寸</span><br><span class="line">    bevelSegments:3,//斜角分段数</span><br><span class="line">    bevelEnabled:true,//是否用斜角</span><br><span class="line">    curveSegments:12,//曲线分段数</span><br><span class="line">    steps:1//拉伸体段数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">shape = createMesh(new THREE.ExtrudeGeometry(drawShape(),options));</span><br></pre></td></tr></table></figure><h2 id="33-粒子"><a href="#33-粒子" class="headerlink" title="33.粒子"></a>33.粒子</h2><h2 id="34-相机控件（详情参见THREE-JS开发指南p181）"><a href="#34-相机控件（详情参见THREE-JS开发指南p181）" class="headerlink" title="34.相机控件（详情参见THREE.JS开发指南p181）"></a>34.相机控件（详情参见THREE.JS开发指南p181）</h2><h2 id="35-为物品添加多种材质"><a href="#35-为物品添加多种材质" class="headerlink" title="35.为物品添加多种材质"></a>35.为物品添加多种材质</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mesh = THREE.SceneUtils.createMultiMaterialObject(geometry,materials);</span><br><span class="line">//参数1是几何体，参数2是一个包含多个材质对象的数组</span><br></pre></td></tr></table></figure><h2 id="36-着色器（略）"><a href="#36-着色器（略）" class="headerlink" title="36.着色器（略）"></a>36.着色器（略）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-渲染器初始化&quot;&gt;&lt;a href=&quot;#1-渲染器初始化&quot; class=&quot;headerlink&quot; title=&quot;1.渲染器初始化&quot;&gt;&lt;/a&gt;1.渲染器初始化&lt;/h2&gt;&lt;p&gt;渲染器将和Canvas元素进行绑定，如果之前在HTML中手动定义了id为mainCanvas
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="three.js" scheme="http://yoursite.com/tags/three-js/"/>
    
  </entry>
  
  <entry>
    <title>web性能优化</title>
    <link href="http://yoursite.com/2017/08/05/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/08/05/web性能优化/</id>
    <published>2017-08-04T16:00:00.000Z</published>
    <updated>2018-03-18T12:29:38.899Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web性能优化"><a href="#web性能优化" class="headerlink" title="web性能优化"></a>web性能优化</h3><p>1.CDN</p><p>2.CSS不要过多使用*，因为他的选择器匹配原则是从右到左</p><p>3.压缩代码</p><p>4.减少http请求</p><p>5.预加载，预渲染：增加 rel=”prefetch”,rel=”dns-prefetch”，或者 rel=”prerender” 标记，详情：（<a href="http://web.jobbole.com/84256/）" target="_blank" rel="noopener">http://web.jobbole.com/84256/）</a></p><p>6.WebAssembly</p><p>7.webpack打包优化</p><p>8.懒加载</p><p>9.合理使用缓存，localstorage,sessionstorage</p><p>10.启用Http2</p><p>11.同构，服务端渲染</p><p>12.service workers</p><p>13.Gzip</p><p>14.将 CSS 样式放在页面的上方，将脚本移动到底部（包括内联的）</p><p>15.雪碧图，字体图标</p><p>16.图像优化</p><p>17.防抖和节流</p><p>18.减少 DOM 操作的次数，避免不必要的重排和重绘</p><p>19.动画合理使用translate3d,opacity来启用单独图层渲染</p><p>20.使用 requestAnimationFrame 来更新页面</p><p>21.可以给 JavaScript 加上 async 标记，表示 JavaScript 的执行不会读取 DOM ，JavaScript 可以不被 CSS 阻塞，可以在空闲时间立刻执行。（正常来说在浏览器没有下载并解析完成使用 link 引入的 CSS 文件之前，JavaScript 是不会执行的）（defer 跟 async 非常相似，不会阻塞页面加载，但会等到 HTML 完成解析后再执行，并且会按出现的次序执行。）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;web性能优化&quot;&gt;&lt;a href=&quot;#web性能优化&quot; class=&quot;headerlink&quot; title=&quot;web性能优化&quot;&gt;&lt;/a&gt;web性能优化&lt;/h3&gt;&lt;p&gt;1.CDN&lt;/p&gt;
&lt;p&gt;2.CSS不要过多使用*，因为他的选择器匹配原则是从右到左&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码学习——笔记</title>
    <link href="http://yoursite.com/2017/08/02/jQuery%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/02/jQuery源码学习笔记/</id>
    <published>2017-08-01T16:00:00.000Z</published>
    <updated>2018-04-22T08:07:29.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-立即调用表达式"><a href="#1-立即调用表达式" class="headerlink" title="1.立即调用表达式"></a>1.立即调用表达式</h3><p>任何库与框架设计的第一个要点就是解决命名空间与变量污染的问题。jQuery就是利用了JavaScript函数作用域的特性，采用立即调用表达式包裹了自身的方法来解决这个问题。</p><p><strong>写法1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function(window,factory)&#123;</span><br><span class="line">    factory(window);</span><br><span class="line">&#125;(this,function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        //jQuery调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>写法1主要是为了判断jQuery在不同平台的下的加载逻辑，主流的库一般都有对 AMD 和 CommonJS 的支持代码。</p><p><strong>写法2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var factory = function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var jQuery = factory();</span><br></pre></td></tr></table></figure><p><strong>写法3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function(window,undefined)&#123;</span><br><span class="line">    var jQuery = function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    window.jQuery = window.$ = jQuery;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure><p>传递参数undefined的原因是：<br>Javascript 中的undefined并不是作为关键字，因此可以允许用户对其赋值，为了避免有人在外面给undefined赋了值，所以我们就把它设置为参数。设置undefined参数后，函数内部它默认就是undefined，不会产生歧义。</p><hr><h3 id="2-处理兼容性"><a href="#2-处理兼容性" class="headerlink" title="2.处理兼容性"></a>2.处理兼容性</h3><p>ie9以前的浏览器对xmlNode.method的存在检测有问题，如window.a == undefined达不到检测效果，而用typeof window.a == ‘undefined’能达到效果。</p><hr><h3 id="3-jq的面向对象的写法"><a href="#3-jq的面向对象的写法" class="headerlink" title="3.jq的面向对象的写法"></a>3.jq的面向对象的写法</h3><p>在jquery源码里面，面向对象的写法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function jQuery()&#123;</span><br><span class="line">    //这样写就能实现调用jQuery的时候，直接调用初始化方法，生成实例，这就省去了jq.init()这一步。</span><br><span class="line">    return new jQuery.prototype.init();</span><br><span class="line">&#125;</span><br><span class="line">jQuery.prototype.init = function()&#123;&#125;;</span><br><span class="line">jQuery.prototype.css = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//把init方法的原型指向jQuery的原型，使得它们共享一份原型，所以也就使得init可以用到jQuery原型上的方法了</span><br><span class="line">jQuery.prototype.init.prototype = jQuery.prototype;</span><br><span class="line"></span><br><span class="line">//就可以这样调用了</span><br><span class="line">jQuery().css();</span><br></pre></td></tr></table></figure></p><hr><h3 id="4-prototype两种写法的差异"><a href="#4-prototype两种写法的差异" class="headerlink" title="4.prototype两种写法的差异"></a>4.prototype两种写法的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这是往原型上去添加或修改属性、方法</span><br><span class="line">A.prototype.age = 18;</span><br><span class="line">A.prototype.name = &apos;lala&apos;;</span><br><span class="line"></span><br><span class="line">//这是重写原型，会覆盖掉默认生成的A.prototype.constructor，所以要把constructor写上</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    constructor:A,</span><br><span class="line">    age:18,</span><br><span class="line">    name:&apos;lala&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-init方法的参数处理"><a href="#5-init方法的参数处理" class="headerlink" title="5.init方法的参数处理"></a>5.init方法的参数处理</h3><p>我们在jQuery中用$()用得很多，它实际上调用的是jQuery的init方法，它可以接受以下这么几种参数，接受不同的参数，它的处理方式也是不一样的：</p><p>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;&quot;),$(null),$(undefined),$(false)</span><br></pre></td></tr></table></figure></p><p>这种情况就直接return this，不做其他处理。</p><p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;&lt;li&gt;1&lt;/li&gt;&quot;),$(&quot;&lt;div&gt;&quot;),$(&quot;#div1&quot;),$(&quot;div&quot;),$(&quot;#div1 div.box&quot;)</span><br></pre></td></tr></table></figure></p><p>遇到这种参数是字符串的，就会经过一系列判断、处理，最终生成这么一个对象格式：this = {0:’li’,1:’li’,length:2}。</p><p>(1)参数是字符串且匹配&lt;&gt;括号，说明是创建元素，那就调用parseHTML方法把它转化为元素节点数组，再调用merge方法转成上面所说到的this对象。</p><p>(2)参数是一个id选择器的，那就调用原生js的getElementById来获取它，然后也是再转化为this对象。</p><p>(3)参数是复杂多重选择器的，那就调用find方法（实现逻辑参见sizzle）来获取到元素节点。</p><p>3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(this),$(document)</span><br></pre></td></tr></table></figure></p><p>这种就会判断参数是不是一个node，是的话也是生成一个this对象。</p><p>4.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>如果参数是一个函数，就会在ready方法的回调中执行这个函数</p><p>5.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$([]),$(&#123;&#125;)</span><br></pre></td></tr></table></figure></p><hr><h3 id="6-pushStack方法"><a href="#6-pushStack方法" class="headerlink" title="6.pushStack方法"></a>6.pushStack方法</h3><p>jq对象的入栈（在slice,eq,map等方法中都是调用到这个方法）<br>它是一个栈结构，会先处理后入栈的对象，调用end()方法就会回溯到前一个对象</p><hr><h3 id="7-extend和-fn-extend"><a href="#7-extend和-fn-extend" class="headerlink" title="7.$.extend和$.fn.extend"></a>7.$.extend和$.fn.extend</h3><p>jq里面的继承是拷贝继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//扩展工具方法</span><br><span class="line">$.extend(&#123;</span><br><span class="line">    a:function()&#123;&#125;,</span><br><span class="line">    b:function()&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//调用：</span><br><span class="line">$.a();</span><br><span class="line">$.b();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//扩展jq实例方法</span><br><span class="line">$.fn.extend(&#123;</span><br><span class="line">    a:function()&#123;&#125;,</span><br><span class="line">    b:function()&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//调用：</span><br><span class="line">$().a();</span><br><span class="line">$().b();</span><br><span class="line"></span><br><span class="line">//对一个对象进行扩展</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">$.extend(a,&#123;age:18&#125;,&#123;name:&apos;lala&apos;&#125;)</span><br><span class="line"></span><br><span class="line">//深浅拷贝</span><br><span class="line">$.extend(a,b);//浅拷贝</span><br><span class="line">$.extend(true,a,b);//深拷贝</span><br></pre></td></tr></table></figure><hr><h3 id="8-extend方法详解"><a href="#8-extend方法详解" class="headerlink" title="8.extend方法详解"></a>8.extend方法详解</h3><p><strong>(1)生成唯一字符串(内部)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.expando</span><br></pre></td></tr></table></figure></p><p><strong>(2)解决冲突</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.noConflict()</span><br><span class="line">//写到上一个插件前面</span><br><span class="line">var aaa=$.noConflict();</span><br><span class="line">aaa(function()&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>(3)ready回调</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;&#125;) </span><br><span class="line">相当于</span><br><span class="line">$(document).ready(function()&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>DOM加载完就执行，它通过判断document.readyState或者给document加一个DOMContentLoaded事件监听来触发调用。<br>（ps：可以通过holdReady来控制同步异步，它的实现方式是以计数的方式判断是否能执行下去）</p><p><strong>(4)isWindow方法用来判断是不是window对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isWindow:function(obj)&#123;</span><br><span class="line">    return obj!=null &amp;&amp; obj===obj.window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(5)isNumeric方法用来判断是不是数值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNumeric:function(obj)&#123;</span><br><span class="line">    return !isNaN(parseFloat(obj)) &amp;&amp; isFinite(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(6)isPlainObject判断是不是对象自变量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isPlainObject:function(obj)&#123;</span><br><span class="line">    if(jQuery.type(obj)!==&quot;object&quot; || obj.nodeType || jQuery.isWindow(obj))&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        if(obj.constructor &amp;&amp; !core_hasOwn.call(obj.constructor.prototype,&quot;isPrototypeOf&quot;))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(7)parseHTML方法把标签字符串转换为html元素节点数组</strong></p><p>判断逻辑：</p><p>1.先用正则判断是不是单标签，是单标签就直接createElement</p><p>2.多标签就调用buildFragment</p><p><strong>(8)globalEval方法在全局执行传递进去的字符串参数</strong></p><p>判断逻辑：</p><p>如果是严格模式，那就新建一个script标签，标签里的内容是参数的内容，然后插入到文档中。</p><p>如果不是那就直接eval（因为严格模式下eval有自身的作用域，不是全局的作用域）</p><p><strong>(9)camelCase转驼峰写法（ps：ms前缀与众不同）</strong></p><p>ps:replace方法第二个参数可以是一个函数，这个函数有4个参数可以传入：第一个参数：正则所匹配到的字符；第二个参数：捕获括号所捕获到的字符；<br>第三个参数：正则匹配到的每段字符的第一个字符的索引；第四个参数：用于匹配的字符串主体；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">camelCase:function(str)&#123;</span><br><span class="line">    return str.replace(/^-ms-/,&quot;ms-&quot;).replace(/-([\da-z])/gi,(all,letter)=&gt;&#123;</span><br><span class="line">        return letter.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(10)nodeName方法判断节点的nodename</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeName:function(elem,name)&#123;</span><br><span class="line">    return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase()===name.toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(11)merge方法合并两个数组或形如{0:’a’,1:’b’,length:2}</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">merge:function(first,second)&#123;</span><br><span class="line">    var l = second.length,</span><br><span class="line">        i = first.length,</span><br><span class="line">        j = 0;</span><br><span class="line">    if(typeof l===&quot;number&quot;)&#123;</span><br><span class="line">        for(;j&lt;l;j++)&#123;</span><br><span class="line">            first[i++] = second[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        while(second[j]!==undefined)&#123;</span><br><span class="line">            first[i++] = second[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    first.length = i;</span><br><span class="line">    return first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(12)$(‘#div1’).width()</strong></p><p>它能够获取到即使display为none的元素的宽度，原生的offsetWidth是获取不到的</p><p>它的做法是先把display:none存起来，然后给元素加上display:block;visibility:hidden;position:absolute再获取它的offsetWidth，获取到之后再把刚才存起来的display:none还原，实现“偷梁换柱”（其实这种操作是依靠swap函数来实现的）</p><hr><h3 id="9-Callbacks-回调执行了解一下"><a href="#9-Callbacks-回调执行了解一下" class="headerlink" title="9.$.Callbacks()回调执行了解一下"></a>9.$.Callbacks()回调执行了解一下</h3><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var cb = $.Callbacks(options);</span><br><span class="line">options可以是：&apos;once&apos;,&apos;memory&apos;,&apos;unique&apos;,&apos;stopOnFalse&apos;</span><br><span class="line"></span><br><span class="line">//往回调数组中添加函数</span><br><span class="line">function a()&#123;&#125;</span><br><span class="line">function b()&#123;&#125;</span><br><span class="line">cb.add(a);</span><br><span class="line">cb.add(b);</span><br><span class="line"></span><br><span class="line">//依次调用</span><br><span class="line">cb.fire();</span><br></pre></td></tr></table></figure></p><p>首先有一个list数组来保存callbacks</p><p><strong>(0)options配置参数：</strong></p><p>once代表只能fire一次；</p><p>memory代表即使你的add在fire后面添加，但是也还能生效，他的实现原理是在add方法里面加上fire；</p><p>unique代表对list去重;</p><p>stopOnFlase代表如果回调函数里有return false的话，那就停止后面的执行。</p><p><strong>(1)add方法：</strong><br>往list里面push回调函数</p><p><strong>(2)remove方法：</strong><br>对list进行splice操作来移除某个回调函数</p><p><strong>(3)fire方法：</strong><br>遍历list，依次执行</p><hr><h3 id="10-Deferred-处理异步流程"><a href="#10-Deferred-处理异步流程" class="headerlink" title="10.$.Deferred()处理异步流程"></a>10.$.Deferred()处理异步流程</h3><p>实际上也是调用$.Callbacks()来处理。</p><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var dfd = $.Deferred();</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    alert(1);</span><br><span class="line">    dfd.resolve();  //这是成功触发，另外还有失败触发标志reject</span><br><span class="line">&#125;,1000);</span><br><span class="line">dfd.done(function()&#123;</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;)</span><br><span class="line">dfd.fail(function()&#123;</span><br><span class="line">    alert(3);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>done,fail方法对应callbacks的add方法，resolve,reject方法对应callbacks的fire方法。</p><p>resolve,done实际上对应的是$.Callbacks(‘once memory’)，有once是为了使状态不可逆，只触发一次；</p><p>reject,fail实际上对应的是$.Callbacks(‘once memory’)，有once是为了使状态不可逆，只触发一次；</p><p>notify,progress实际上对应的是$.Callbacks(‘memory’)。</p><p>内部还有一个自定义的promise对象来新增一些协助函数方法，它跟deferred不一样的地方就是它没有那三种状态，防止调用这个方法的时候把状态给改了。</p><p><strong>$.when()方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//相当于promise.all</span><br><span class="line">$.when(a(),b()).done(function()&#123;</span><br><span class="line">    alert(&apos;success&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>它会把参数放进一个数组里面并执行，内部有一个计数器，数值等于数组长度，每有一个参数完成计数器就减一，当计数器为0时那就执行内部新建的$.Deferred()</p><hr><h3 id="11-通过support进行功能检测"><a href="#11-通过support进行功能检测" class="headerlink" title="11.通过support进行功能检测"></a>11.通过support进行功能检测</h3><p>作为兼容性功能的判断实现，主要有样式兼容、h5兼容、js兼容等等。可以通过创建一些元素来检测不同浏览器下这些元素的表现行为、属性方法有什么异同，检测完之后就可以把元素给删掉。</p><p>而针对不同环境下作出不同的反应是通过hooks实现的，support只是一个兼容判断。</p><hr><h3 id="12-attr、prop和data"><a href="#12-attr、prop和data" class="headerlink" title="12.attr、prop和data"></a>12.attr、prop和data</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#div1&apos;).attr(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line">相当于</span><br><span class="line">document.getElementById(&apos;div1&apos;).setAttribute(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line"></span><br><span class="line">$(&apos;#div1&apos;).prop(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line">相当于</span><br><span class="line">document.getElementById(&apos;div1&apos;).name=&apos;lala&apos;;</span><br><span class="line"></span><br><span class="line">//当然不会这么简单直接设置，它们还会检测参数合法性，解决浏览器兼容问题等等</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这样不会内存泄漏</span><br><span class="line">$(&apos;#div1&apos;).data(&apos;name&apos;,obj);</span><br><span class="line">//这样有可能会内存泄漏</span><br><span class="line">$(&apos;#div1&apos;).attr(&apos;name&apos;,obj);</span><br><span class="line"></span><br><span class="line">//ps：DOM元素和对象之间相互引用，大部分浏览器就会出现内存泄漏</span><br><span class="line">var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">div1.name = obj;</span><br><span class="line">obj.age = div1;</span><br></pre></td></tr></table></figure><p>data方法是怎么做到消除内存泄漏的呢？</p><p>其实它是先新建一个cache对象来存放一种对应联系，建立元素绑定的属性和你自定义要绑定进去的属性之间的联系，就是说这是一种间接绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//cache就是类似于以下这样的结构</span><br><span class="line">this.cache=&#123;</span><br><span class="line">    1:&#123;name:&apos;lala&apos;&#125;,</span><br><span class="line">    2:&#123;name:&apos;lala&apos;,age:19&#125;</span><br><span class="line">&#125;</span><br><span class="line">//它会给每个data分配一个映射到实际属性的key：1、2、3...，同一个元素分配到的都是同一个key</span><br><span class="line">//元素上挂载的实际上是类似于这样的东西：</span><br><span class="line"></span><br><span class="line">&lt;div jquery784382547239469837=&quot;1&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//当this不是元素或者document节点时，这个cache会通过Object.defineProperty设置一个key为0，getter为&#123;&#125;的属性，这是处理非元素节点时用的</span><br></pre></td></tr></table></figure><hr><h3 id="13-jQuery的queue"><a href="#13-jQuery的queue" class="headerlink" title="13.jQuery的queue"></a>13.jQuery的queue</h3><p>跟数据结构里的队列是一样的，只不过它存放的是函数，出队列的时候就会调用这个函数,要前一个函数出了队列才会执行下一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//多个动画animate就用到了queue</span><br><span class="line">$(this).animate(&#123;width:300&#125;,2000);</span><br><span class="line">$(this).animate(&#123;height:100&#125;,2000);</span><br><span class="line">$(this).animate(&#123;left:500&#125;,2000);</span><br></pre></td></tr></table></figure><hr><h3 id="14-对class的操作"><a href="#14-对class的操作" class="headerlink" title="14.对class的操作"></a>14.对class的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#div1&apos;).addClass(&apos;box1 box2&apos;);</span><br><span class="line">$(&apos;#div1&apos;).removeClass(&apos;box1 box2&apos;);</span><br><span class="line">$(&apos;#div1&apos;).toggleClass(&apos;box1 box2&apos;);</span><br></pre></td></tr></table></figure><p>addClass实际上是对传进来的字符串进行检验、分割，然后再用indexOf判断元素原来的class里面有没有新增的class，没有才添加进去，有就不管。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-立即调用表达式&quot;&gt;&lt;a href=&quot;#1-立即调用表达式&quot; class=&quot;headerlink&quot; title=&quot;1.立即调用表达式&quot;&gt;&lt;/a&gt;1.立即调用表达式&lt;/h3&gt;&lt;p&gt;任何库与框架设计的第一个要点就是解决命名空间与变量污染的问题。jQuery就是利用了
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>fl效果器</title>
    <link href="http://yoursite.com/2017/07/12/fl%E6%95%88%E6%9E%9C%E5%99%A8/"/>
    <id>http://yoursite.com/2017/07/12/fl效果器/</id>
    <published>2017-07-11T16:00:00.000Z</published>
    <updated>2018-03-18T11:30:12.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录下fl效果器的效果"><a href="#记录下fl效果器的效果" class="headerlink" title="记录下fl效果器的效果"></a>记录下fl效果器的效果</h3><p>EQUO 音色粗细</p><p>Fabfilter simplon 电音</p><p>fruity chorus 和声</p><p>fruity convolver 空旷回声</p><p>fruity delay 2 重复音</p><p>fruity delay bank 重复音不同</p><p>fruity fast dist 电噪音</p><p>fruity flanger 多种回音</p><p>fruity flangus 电子跳音</p><p>fruity limiter 强弱</p><p>fruity love philter 未来电音</p><p>fruity multiband compressor 钝、干</p><p>fruity parametric EQ 铁质音</p><p>fruity parametric EQ2 多样铁质音</p><p>fruity phaser 多样</p><p>fruity reeverb2 场合音</p><p>fruity squeeze 噪铁</p><p>fruity stereo enhancer 立体音</p><p>fruity stereo shaper 左右声道多样</p><p>fruity vocoder 低小音</p><p>fruity waveshaper 噪</p><p>gross beat 多样重</p><p>hardcore 空灵噪</p><p>maximus 干电音</p><p>soundgoodizer 电</p><p>vocodex 弹东西的声音，赞</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;记录下fl效果器的效果&quot;&gt;&lt;a href=&quot;#记录下fl效果器的效果&quot; class=&quot;headerlink&quot; title=&quot;记录下fl效果器的效果&quot;&gt;&lt;/a&gt;记录下fl效果器的效果&lt;/h3&gt;&lt;p&gt;EQUO 音色粗细&lt;/p&gt;
&lt;p&gt;Fabfilter simplon
      
    
    </summary>
    
      <category term="电音" scheme="http://yoursite.com/categories/%E7%94%B5%E9%9F%B3/"/>
    
    
      <category term="fl" scheme="http://yoursite.com/tags/fl/"/>
    
      <category term="电音" scheme="http://yoursite.com/tags/%E7%94%B5%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/06/15/hello-world/"/>
    <id>http://yoursite.com/2017/06/15/hello-world/</id>
    <published>2017-06-14T16:00:00.000Z</published>
    <updated>2018-03-18T11:27:05.387Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="其它" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
