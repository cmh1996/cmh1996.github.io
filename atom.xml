<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chambers个人博客</title>
  
  <subtitle>记录点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-18T12:29:40.313Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chambers</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web缓存</title>
    <link href="http://yoursite.com/2017/09/12/web%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2017/09/12/web缓存/</id>
    <published>2017-09-11T16:00:00.000Z</published>
    <updated>2018-03-18T12:29:40.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。"><a href="#Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。" class="headerlink" title="Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存 。"></a>Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存 。</h2><p>浏览器HTTP缓存可以分为强缓存和协商缓存。强缓存和协商缓存最大也是最根本的区别是：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache），协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。简略流程图如下：</p><p><img src="/2017/09/12/web缓存/1.png" alt="web缓存流程图1"></p><p><img src="/2017/09/12/web缓存/2.png" alt="web缓存流程图2"></p><p>浏览器HTTP缓存由HTTP报文的首部字段决定</p><h2 id="控制强缓存的字段按优先级介绍："><a href="#控制强缓存的字段按优先级介绍：" class="headerlink" title="控制强缓存的字段按优先级介绍："></a>控制强缓存的字段按优先级介绍：</h2><h3 id="1-Pragma"><a href="#1-Pragma" class="headerlink" title="1.Pragma"></a>1.Pragma</h3><p>Pragma是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。虽然它是一个通用首部，但是它在响应报文中时的行为没有规范，依赖于浏览器的实现。RFC中该字段只有no-cache一个可选值，会通知浏览器不直接使用缓存，要求向服务器发请求校验新鲜度。因为它优先级最高，当存在时一定不会命中强缓存。</p><h3 id="2-Expires"><a href="#2-Expires" class="headerlink" title="2.Expires"></a>2.Expires</h3><p>Expires是一个响应首部字段，它指定了一个日期/时间，在这个时间/日期之前，HTTP缓存被认为是有效的。无效的日期比如0，表示这个资源已经过期了。如果同时设置了Cache-Control响应首部字段的max-age，则Expires会被忽略。它也是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。</p><h3 id="3-Cache-Control"><a href="#3-Cache-Control" class="headerlink" title="3.Cache-Control"></a>3.Cache-Control</h3><p>Cache-Control是一个通用首部字段，也是HTTP/1.1控制浏览器缓存的主流字段。和浏览器缓存相关的是如下几个响应指令：</p><p>指令 参数 说明</p><p>private 无 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）</p><p>public 可省略 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存</p><p>no-cache 可省略 缓存前必需确认其有效性</p><p>no-store 无 不缓存请求或响应的任何内容</p><p>max-age=[s] 必需 响应的最大值</p><p>max-age（单位为s）设置缓存的存在时间，相对于发送请求的时间。只有响应报文首部设置Cache-Control为非0的max-age或者设置了大于请求日期的Expires（下文会讲）才有可能命中强缓存。当满足这个条件，同时响应报文首部中Cache-Control不存在no-cache、no-store且请求报文首部不存在Pragma字段，才会真正命中强缓存。max-age=0相当于no-cache。</p><p>no-cache 表示请求必须先与服务器确认缓存的有效性，如果有效才能使用缓存（协商缓存），无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存。Chrome硬性重新加载（Command+shift+R）会在请求的首部加上Pragma：no-cache和Cache-Control：no-cache。会缓存，但是使用这份缓存之前先到服务器上确认这份缓存是不是最新的，是最新的才使用。</p><p>no-store 表示禁止浏览器以及所有中间缓存存储任何版本的返回响应，一定不会出现强缓存和协商缓存，适合个人隐私数据或者经济类数据。绝对不缓存。</p><p>public 表明响应可以被浏览器、CDN等等缓存。</p><p>private 响应只作为私有的缓存，不能被CDN等缓存。如果要求HTTP认证，响应会自动设置为private。</p><h2 id="控制协商缓存的字段："><a href="#控制协商缓存的字段：" class="headerlink" title="控制协商缓存的字段："></a>控制协商缓存的字段：</h2><h3 id="1-Last-Modified-If-Modified-Since"><a href="#1-Last-Modified-If-Modified-Since" class="headerlink" title="1.Last-Modified/If-Modified-Since"></a>1.Last-Modified/If-Modified-Since</h3><p>If-Modified-Since是一个请求首部字段，并且只能用在GET或者HEAD请求中。Last-Modified是一个响应首部字段，包含服务器认定的资源作出修改的日期及时间。当带着If-Modified-Since头访问服务器请求资源时，服务器会检查Last-Modified，如果Last-Modified的时间早于或等于If-Modified-Since则会返回一个不带主体的304响应，否则将重新返回资源。</p><h3 id="2-ETag-If-None-Match"><a href="#2-ETag-If-None-Match" class="headerlink" title="2.ETag/If-None-Match"></a>2.ETag/If-None-Match</h3><p>ETag是一个响应首部字段，它是根据实体内容生成的一段hash字符串，标识资源的状态，由服务端产生。If-None-Match是一个条件式的请求首部。如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的ETag，则当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的200响应，否则服务器会返回不带实体的304响应。ETag优先级比Last-Modified高，同时存在时会以ETag为准。</p><h3 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h3><p>在有效期内更新资源可以用资源加时间戳命名的方式，如下图的<img>。<br>按F5相当于no-cache，按ctrl+f5相当于强制刷新，拉取新资源。</p><h3 id="缓存策略："><a href="#缓存策略：" class="headerlink" title="缓存策略："></a>缓存策略：</h3><p>html文件用no-cache的方式设置，css,js文件用max-age设置.</p><p>首先对静态资源进行版本控制（比如给静态资源的文件名加上hash值），其次对网页设置合适时长的缓存时间（长短取决于实际场景）。这样就兼顾了版本升级和性能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。&quot;&gt;&lt;a href=&quot;#Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。&quot; class=&quot;headerlink&quot; title=&quot;Web缓存可以分为这几种
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="web缓存" scheme="http://yoursite.com/tags/web%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Three.js笔记</title>
    <link href="http://yoursite.com/2017/08/12/Three.js%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/12/Three.js笔记/</id>
    <published>2017-08-11T16:00:00.000Z</published>
    <updated>2018-03-18T12:12:33.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-渲染器初始化"><a href="#1-渲染器初始化" class="headerlink" title="1.渲染器初始化"></a>1.渲染器初始化</h2><p>渲染器将和Canvas元素进行绑定，如果之前在HTML中手动定义了id为mainCanvas的Canvas元素，那么Renderer可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var renderer = new THREE.WebGLRenderer(&#123;</span><br><span class="line">    canvas: document.getElementById(&apos;mainCanvas&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而如果想要Three.js生成Canvas元素，在HTML中就不需要定义Canvas元素，在JavaScript代码中可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var renderer = new THREE.WebGLRenderer();</span><br><span class="line">renderer.setSize(400, 300);</span><br><span class="line">document.getElementsByTagName(&apos;body&apos;)[0].appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure><p>背景色（清除色）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.setClearColor(0x000000);</span><br></pre></td></tr></table></figure></p><h2 id="2-场景相关API"><a href="#2-场景相关API" class="headerlink" title="2.场景相关API"></a>2.场景相关API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scene.add();    //添加东西</span><br><span class="line">scene.remove();    //移除东西</span><br><span class="line">scene.children();    //获取场景中所有子对象</span><br><span class="line">scene.getChildByName();    //利用name属性，获取场景中某个特定物体</span><br><span class="line">scene.traverse();   //参数接受一个函数，场景中每个子对象都会执行的，相当于forEach</span><br><span class="line"></span><br><span class="line">scene.fog = new THREE.Fog(0xffffff,0.015,100);  //雾化(两个参数时1是雾的颜色，2是雾的浓度；三个参数时1是雾的颜色，2是near值，3是far值)</span><br><span class="line"></span><br><span class="line">scene.overrideMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;);   //设置场景中所有物体的材质</span><br></pre></td></tr></table></figure><h2 id="3-正交投影vs透视投影"><a href="#3-正交投影vs透视投影" class="headerlink" title="3.正交投影vs透视投影"></a>3.正交投影vs透视投影</h2><p>使用透视投影照相机获得的结果是类似人眼在真实世界中看到的有“近大远小”的效果；而使用正交投影照相机获得的结果就像我们在数学几何学课上老师教我们画的效果，对于在三维空间内平行的线，投影到二维空间中也一定是平行的。</p><p>一般说来，对于制图、建模软件通常使用正交投影，这样不会因为投影而改变物体比例；而对于其他大多数应用，通常使用透视投影，因为这更接近人眼的观察效果。</p><h2 id="4-正交投影照相机"><a href="#4-正交投影照相机" class="headerlink" title="4.正交投影照相机"></a>4.正交投影照相机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.OrthographicCamera(left, right, top, bottom, near, far)</span><br></pre></td></tr></table></figure><p>这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，这六个面围成一个长方体，我们称其为视景体（Frustum）。只有在视景体内部（下图中的灰色部分）的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉。</p><p>为了保持照相机的横竖比例，需要保证(right - left)与(top - bottom)的比例与Canvas宽度与高度的比例一致。</p><p>near与far都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般near的值设置得较小，far的值设置得较大，具体值视场景中物体的位置等决定。</p><p><img src="http://www.ituring.com.cn/download/01YiZI4zr57Q.small" alt="camera"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//分别设置照相机的x,y,z位置</span><br><span class="line">camera.position.set(0,0,5);</span><br></pre></td></tr></table></figure><p>另外，因为照相机默认是看向z的负方向，所以要想照相机往其他方向看，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这样照相机就会看着(0,0,0)这个点（无论照相机在哪个位置）</span><br><span class="line">camera.lookAt(new THREE.Vector3(0,0,0));</span><br></pre></td></tr></table></figure><h2 id="5-透视投影照相机"><a href="#5-透视投影照相机" class="headerlink" title="5.透视投影照相机"></a>5.透视投影照相机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.PerspectiveCamera(fov, aspect, near, far);</span><br><span class="line">var camera = new THREE.PerspectiveCamera(45, 400 / 300, 1, 10);</span><br></pre></td></tr></table></figure><p><img src="http://www.ituring.com.cn/download/01YYrMaASOzm.small" alt="camera"></p><p>透视图中，灰色的部分是视景体，是可能被渲染的物体所在的区域。fov是视景体竖直方向上的张角（是角度制而非弧度制），如侧视图所示。</p><p>aspect等于width / height，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。</p><p>near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near。</p><h2 id="6-立方体"><a href="#6-立方体" class="headerlink" title="6.立方体"></a>6.立方体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)</span><br></pre></td></tr></table></figure><p>width是x方向上的长度；height是y方向上的长度；depth是z方向上的长度；后三个参数分别是在三个方向上的分段数，如widthSegments为3的话，代表x方向上水平分为三份。一般情况下不需要分段的话，可以不设置后三个参数，后三个参数的缺省值为1。其他几何形状中的分段也是类似的，下面不做说明。</p><h2 id="7-平面"><a href="#7-平面" class="headerlink" title="7.平面"></a>7.平面</h2><p>这里的平面（PlaneGeometry）其实是一个长方形，而不是数学意义上无限大小的平面。其构造函数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.PlaneGeometry(width, height, widthSegments, heightSegments)</span><br></pre></td></tr></table></figure></p><p>其中，width是x方向上的长度；height是y方向上的长度；后两个参数同样表示分段。</p><h2 id="8-球体"><a href="#8-球体" class="headerlink" title="8.球体"></a>8.球体</h2><p>其中，radius是半径；segmentsWidth表示经度上的切片数；segmentsHeight表示纬度上的切片数；phiStart表示经度开始的弧度；phiLength表示经度跨过的弧度；thetaStart表示纬度开始的弧度；thetaLength表示纬度跨过的弧度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure><h2 id="9-圆形"><a href="#9-圆形" class="headerlink" title="9.圆形"></a>9.圆形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure><h2 id="10-圆柱体"><a href="#10-圆柱体" class="headerlink" title="10.圆柱体"></a>10.圆柱体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)</span><br></pre></td></tr></table></figure><p>其中，radiusTop与radiusBottom分别是顶面和底面的半径，由此可知，当这两个参数设置为不同的值时，实际上创建的是一个圆台；height是圆柱体的高度；radiusSegments与heightSegments可类比球体中的分段；openEnded是一个布尔值，表示是否没有顶面和底面，缺省值为false，表示有顶面和底面。</p><h2 id="11-正n面体"><a href="#11-正n面体" class="headerlink" title="11.正n面体"></a>11.正n面体</h2><p>正四面体（TetrahedronGeometry）、正八面体（OctahedronGeometry）、正二十面体（IcosahedronGeometry）的构造函数较为类似，分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">THREE.TetrahedronGeometry(radius, detail)</span><br><span class="line">THREE.OctahedronGeometry(radius, detail)</span><br><span class="line">THREE.IcosahedronGeometry(radius, detail)</span><br></pre></td></tr></table></figure><p>其中，radius是半径；detail是细节层次（Level of Detail）的层数，对于大面片数模型，可以控制在视角靠近物体时，显示面片数多的精细模型，而在离物体较远时，显示面片数较少的粗略模型。这里我们不对detail多作展开，一般可以对这个值缺省。</p><h2 id="12-圆环面"><a href="#12-圆环面" class="headerlink" title="12.圆环面"></a>12.圆环面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc)</span><br></pre></td></tr></table></figure><p>其中，radius是圆环半径；tube是管道半径；radialSegments与tubularSegments分别是两个分段数，详见上图；arc是圆环面的弧度，缺省值为Math.PI * 2。</p><p><img src="http://www.ituring.com.cn/download/01YZGqQBQI0k" alt="pt"></p><h2 id="13-圆环结"><a href="#13-圆环结" class="headerlink" title="13.圆环结"></a>13.圆环结</h2><p>如果说圆环面是甜甜圈，那么圆环结（TorusKnotGeometry）就是打了结的甜甜圈，其构造参数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments, p, q, heightScale)</span><br></pre></td></tr></table></figure></p><p>前四个参数在圆环面中已经有所介绍，p和q是控制其样式的参数，一般可以缺省，如果需要详细了解，请学习圆环结的相关知识；heightScale是在z轴方向上的缩放。</p><h2 id="14-文字形状"><a href="#14-文字形状" class="headerlink" title="14.文字形状"></a>14.文字形状</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TextGeometry(text, parameters);</span><br></pre></td></tr></table></figure><p>其中，text是文字字符串，parameters是以下参数组成的对象：</p><p>size：字号大小，一般为大写字母的高度</p><p>height：文字的厚度</p><p>curveSegments：弧线分段数，使得文字的曲线更加光滑</p><p>font：字体，默认是’helvetiker’，需对应引用的字体文件</p><p>weight：值为’normal’或’bold’，表示是否加粗</p><p>style：值为’normal’或’italics’，表示是否斜体</p><p>bevelEnabled：布尔值，是否使用倒角，意为在边缘处斜切</p><p>bevelThickness：倒角厚度</p><p>bevelSize：倒角宽度</p><p>ps:加载字体示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.FontLoader();</span><br><span class="line">loader.load(&apos;../lib/helvetiker_regular.typeface.json&apos;, function(font) &#123;</span><br><span class="line">    var mesh = new THREE.Mesh(new THREE.TextGeometry(&apos;Hello&apos;, &#123;</span><br><span class="line">        font: font,</span><br><span class="line">        size: 1,</span><br><span class="line">        height: 1</span><br><span class="line">    &#125;), material);</span><br><span class="line">    scene.add(mesh);</span><br><span class="line"></span><br><span class="line">    // render</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="15-自定义形状"><a href="#15-自定义形状" class="headerlink" title="15.自定义形状"></a>15.自定义形状</h2><p>由于自定义形状需要手动指定每个顶点位置，以及顶点连接情况，如果该形状非常复杂，程序员的计算量就会比较大。在这种情况下，建议在3ds Max之类的建模软件中创建模型，然后使用Three.js导入到场景中，这样会更高效方便。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 初始化几何形状</span><br><span class="line">var geometry = new THREE.Geometry();</span><br><span class="line"></span><br><span class="line">// 设置顶点位置</span><br><span class="line">// 顶部4顶点</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-1, 2, -1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(1, 2, -1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(1, 2, 1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-1, 2, 1));</span><br><span class="line">// 底部4顶点</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-2, 0, -2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(2, 0, -2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(2, 0, 2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-2, 0, 2));</span><br><span class="line"></span><br><span class="line">// 设置顶点连接情况</span><br><span class="line">// 顶面</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 1, 3));</span><br><span class="line">geometry.faces.push(new THREE.Face3(1, 2, 3));</span><br><span class="line">// 底面</span><br><span class="line">geometry.faces.push(new THREE.Face3(4, 5, 6));</span><br><span class="line">geometry.faces.push(new THREE.Face3(5, 6, 7));</span><br><span class="line">// 四个侧面</span><br><span class="line">geometry.faces.push(new THREE.Face3(1, 5, 6));</span><br><span class="line">geometry.faces.push(new THREE.Face3(6, 2, 1));</span><br><span class="line">geometry.faces.push(new THREE.Face3(2, 6, 7));</span><br><span class="line">geometry.faces.push(new THREE.Face3(7, 3, 2));</span><br><span class="line">geometry.faces.push(new THREE.Face3(3, 7, 0));</span><br><span class="line">geometry.faces.push(new THREE.Face3(7, 4, 0));</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 4, 5));</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 5, 1));</span><br></pre></td></tr></table></figure></p><p>需要注意的是，new THREE.Vector3(-1, 2, -1)创建一个矢量，作为顶点位置追加到geometry.vertices数组中。</p><p>而由new THREE.Face3(0, 1, 3)创建一个三个顶点组成的面片，追加到geometry.faces数组中。三个参数分别是四个顶点在geometry.vertices中的序号。</p><h2 id="16-简单材质"><a href="#16-简单材质" class="headerlink" title="16.简单材质"></a>16.简单材质</h2><h3 id="1-基础材质"><a href="#1-基础材质" class="headerlink" title="1.基础材质"></a>1.基础材质</h3><p>对于基本材质，即使改变场景中的光源，使用该材质的物体也始终为颜色处处相同的效果。当然，这不是很具有真实感。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    color: 0xffff00,</span><br><span class="line">    opacity: 0.75</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可以设置以下属性：</p><p>visible：是否可见，默认为true</p><p>side：渲染面片正面或是反面，默认为正面THREE.FrontSide，可设置为反面THREE.BackSide，或双面THREE.DoubleSide</p><p>wireframe：是否渲染线而非面，默认为false</p><p>color：十六进制RGB颜色，如红色表示为0xff0000</p><p>map：使用纹理贴图</p><h3 id="2-深度材质"><a href="#2-深度材质" class="headerlink" title="2.深度材质"></a>2.深度材质</h3><p>其外观不由光照或某个材质属性决定，而是由物体到相机的距离决定。</p><p>可以将这种材质与其他材质相结合，很容易创建出逐渐消失的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var depthMaterial = new THREE.MeshDepthMaterial();</span><br><span class="line">depthMaterial.wireframe = true;  //是否显示线框</span><br><span class="line">depthMaterial.wireframeLineWidth = 10;  //线框线的宽度</span><br></pre></td></tr></table></figure><h3 id="3-联合材质"><a href="#3-联合材质" class="headerlink" title="3.联合材质"></a>3.联合材质</h3><p>把材质结合起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cube = new THREE.SceneUtils.createMultiMaterialObject(geometry,[basicMaterial,depthMaterial]);</span><br></pre></td></tr></table></figure><h3 id="4-每个面材质"><a href="#4-每个面材质" class="headerlink" title="4.每个面材质"></a>4.每个面材质</h3><p>相当于一个材质容器，为几何体每一个面制定不同的材质</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var matArray = [</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0x009e60&#125;),</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0x0051ba&#125;),</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0xffd500&#125;),</span><br><span class="line">];</span><br><span class="line">var faceMaterial = new THREE.MeshFaceMaterial(matArray);</span><br></pre></td></tr></table></figure><p>ps:要创建一种透明的材质，仅仅设置opacity:0是不够的，还要将transparent设为0。为一个几何体赋予多种材质会复制几何体，从而创建出多个网格。</p><h2 id="17-Lambert材质"><a href="#17-Lambert材质" class="headerlink" title="17.Lambert材质"></a>17.Lambert材质</h2><p>Lambert材质（MeshLambertMaterial）是符合Lambert光照模型的材质。Lambert光照模型的主要特点是只考虑漫反射而不考虑镜面反射的效果，因而对于金属、镜子等需要镜面反射效果的物体就不适应，对于其他大部分物体的漫反射效果都是适用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xffff00</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>color是用来表现材质对散射光的反射能力，也是最常用来设置材质颜色的属性。除此之外，还可以用ambient和emissive控制材质的颜色。</p><p>ambient表示对环境光的反射能力，只有当设置了AmbientLight后，该值才是有效的，材质对环境光的反射能力与环境光强相乘后得到材质实际表现的颜色。</p><p>emissive是材质的自发光颜色，可以用来表现光源的颜色。</p><h2 id="18-Phong材质"><a href="#18-Phong材质" class="headerlink" title="18.Phong材质"></a>18.Phong材质</h2><p>Phong材质（MeshPhongMaterial）是符合Phong光照模型的材质。和Lambert不同的是，Phong模型考虑了镜面反射的效果，因此对于金属、镜面的表现尤为适合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">material = new THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color: 0xff0000,</span><br><span class="line">    specular: 0xffff00,</span><br><span class="line">    shininess: 100</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同样地，可以指定emissive和ambient值，这里不再说明。</p><p>可以通过shininess属性控制光照模型中的n值，当shininess值越大时，高光的光斑越小，默认值为30。</p><h2 id="19-法向材质"><a href="#19-法向材质" class="headerlink" title="19.法向材质"></a>19.法向材质</h2><p>法向材质可以将材质的颜色设置为其法向量的方向，有时候对于调试很有帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshNormalMaterial()</span><br></pre></td></tr></table></figure><p>材质的颜色与照相机与该物体的角度相关，我们只改变照相机位置，就可以观察两个角度的颜色变化。</p><h2 id="20-材质的纹理贴图"><a href="#20-材质的纹理贴图" class="headerlink" title="20.材质的纹理贴图"></a>20.材质的纹理贴图</h2><p>导入图像作为纹理贴图，并添加到相应的材质中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//单张图像应用于长方体</span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;);</span><br><span class="line"></span><br><span class="line">var material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    map: texture</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//可以用回调函数的方式来命令渲染：</span><br><span class="line"></span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;, &#123;&#125;, function() &#123;</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br><span class="line">var material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    map: texture</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>六个面应用不同的图像示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var materials = [];</span><br><span class="line">for (var i = 0; i &lt; 6; ++i) &#123;</span><br><span class="line">    materials.push(new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">        map: THREE.ImageUtils.loadTexture(&apos;../img/&apos; + i + &apos;.png&apos;,</span><br><span class="line">                &#123;&#125;, function() &#123;</span><br><span class="line">                    renderer.render(scene, camera);</span><br><span class="line">                &#125;),</span><br><span class="line">        overdraw: true</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cube = new THREE.Mesh(new THREE.CubeGeometry(5, 5, 5),</span><br><span class="line">        new THREE.MeshFaceMaterial(materials));</span><br><span class="line">scene.add(cube);</span><br></pre></td></tr></table></figure></p><p>棋盘格（复制渲染）：</p><p>原图片：<br><img src="http://www.ituring.com.cn/download/01YdRC86nAUx" alt="pt"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//导入材质</span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/chess.png&apos;, &#123;&#125;, function() &#123;</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可是，棋盘格是8横8纵64个小方格组成的，那应该怎么办呢？</span><br><span class="line"></span><br><span class="line">//首先，我们需要指定重复方式为两个方向（wrapS和wrapT）都重复：</span><br><span class="line">texture.wrapS = texture.wrapT = THREE.RepeatWrapping;</span><br><span class="line"></span><br><span class="line">//然后，设置两个方向上都重复4次，由于我们的图像本来是有2行2列，所以重复4次即为8行8列：</span><br><span class="line">texture.repeat.set(4, 4);</span><br></pre></td></tr></table></figure><p>最后就得到了棋盘格：<br><img src="http://www.ituring.com.cn/download/01YdRCMAK2Xq" alt="pt"></p><h2 id="21-网格"><a href="#21-网格" class="headerlink" title="21.网格"></a>21.网格</h2><p>而网格的创建非常简单，只要把几何形状与材质传入其构造函数。最常用的物体是网格（Mesh），它代表包含点、线、面的几何体，其构造函数是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mesh = new THREE.Mesh(geometry, material);</span><br></pre></td></tr></table></figure></p><p>在网格被创建后，也能对材质进行修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xff0000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>位置、缩放、旋转:</p><p>位置、缩放、旋转是物体三个常用属性。由于THREE.Mesh基础自THREE.Object3D，因此包含scale、rotation、position三个属性。它们都是THREE.Vector3实例，因此修改其值的方法是相同的，这里以位置为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.position.z = 1;</span><br><span class="line">或</span><br><span class="line">mesh.position.set(1.5, -0.5, 0);</span><br></pre></td></tr></table></figure><h2 id="22-动画"><a href="#22-动画" class="headerlink" title="22.动画"></a>22.动画</h2><p>setInterval方法与requestAnimationFrame方法的区别较为微妙。一方面，最明显的差别表现在setInterval可以手动设定FPS，而requestAnimationFrame则会自动设定FPS；但另一方面，即使是setInterval也不能保证按照给定的FPS执行，在浏览器处理繁忙时，很可能低于设定值。当浏览器达不到设定的调用周期时，requestAnimationFrame采用跳过某些帧的方式来表现动画，虽然会有卡滞的效果但是整体速度不会拖慢，而setInterval会因此使整个程序放慢运行，但是每一帧都会绘制出来；</p><p>总而言之，requestAnimationFrame适用于对于时间较为敏感的环境（但是动画逻辑更加复杂），而setInterval则可在保证程序的运算不至于导致延迟的情况下提供更加简洁的逻辑（无需自行处理时间）。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">    mesh.rotation.y = (mesh.rotation.y + 0.01) % (Math.PI * 2);</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">    id = requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ps:可以使用stat.js记录FPS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stats.setMode(0);//监测FPS</span><br><span class="line">stats.setMode(1);//监测渲染时间</span><br></pre></td></tr></table></figure><p>详情请见：(使用stat.js记录FPS)[<a href="http://www.ituring.com.cn/book/miniarticle/53353]" target="_blank" rel="noopener">http://www.ituring.com.cn/book/miniarticle/53353]</a></p><h2 id="23-外部导入"><a href="#23-外部导入" class="headerlink" title="23.外部导入"></a>23.外部导入</h2><p>Three.js有一系列导入外部文件的辅助函数，是在three.js之外的，使用前需要额外下载，在(loaders)[<a href="https://github.com/mrdoob/three.js/tree/master/examples/js/loaders]可以找到。" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders]可以找到。</a></p><p>.obj是最常用的模型格式，导入.obj文件需要OBJLoader.js；</p><p>导入带.mtl材质的.obj文件需要MTLLoader.js以及OBJMTLLoader.js。另有PLYLoader.js、STLLoader.js等分别对应不同格式的加载器，可以根据模型格式自行选择。</p><p>导入过程：<a href="http://www.ituring.com.cn/book/miniarticle/53865" target="_blank" rel="noopener">无材质的模型</a><br>         <a href="http://www.ituring.com.cn/book/miniarticle/53881" target="_blank" rel="noopener">有材质的模型</a></p><h2 id="24-环境光"><a href="#24-环境光" class="headerlink" title="24.环境光"></a>24.环境光</h2><p>环境光是指场景整体的光照效果，是由于场景内若干光源的多次反射形成的亮度一致的效果，通常用来为整个场景指定一个基础亮度。因此，环境光没有明确的光源位置，在各处形成的亮度也是一致的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var light = new THREE.AmbientLight(0xffffff);</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure></p><p>环境光并不在乎物体材质的color属性，而是在乎ambient属性。ambient属性的默认值是0xffffff。</p><p>ambient为0x00ff00的长方体被渲染成了黑色。这是因为不透明物体的颜色其实是其反射光的颜色，而ambient属性表示的是物体反射环境光的能力。对于0x00ff00的物体，红色通道是0，而环境光是完全的红光，因此该长方体不能反射任何光线，最终的渲染颜色就是黑色；而对于0xffffff的白色长方体，红色通道是0xff，因而能反射所有红光，渲染的颜色就是红色。</p><p>前面我们看到，当环境光不是白色或灰色的时候，渲染的效果往往会很奇怪。因此，环境光通常使用白色或者灰色，作为整体光照的基础。</p><h2 id="25-点光源"><a href="#25-点光源" class="headerlink" title="25.点光源"></a>25.点光源</h2><p>点光源是不计光源大小，可以看作一个点发出的光源。点光源照到不同物体表面的亮度是线性递减的，因此，离点光源距离越远的物体会显得越暗。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">THREE.PointLight(hex, intensity, distance);</span><br><span class="line"></span><br><span class="line">//应用示例：</span><br><span class="line"></span><br><span class="line">var light = new THREE.PointLight(0xffffff, 2, 100);</span><br><span class="line">light.color = &quot;#ccffcc&quot;;    //设置光源颜色</span><br><span class="line">light.intensity = 1;    //光的强度</span><br><span class="line">light.position.set(0, 1.5, 2);  //设置光源位置</span><br><span class="line">light.distance = 100;   //光源照射距离（默认为0，也就是说光线亮度不会随着距离增加而递减）</span><br><span class="line">light.visible = true;   //光源是否开启</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure><p>其中，hex是光源十六进制的颜色值；intensity是亮度，缺省值为1，表示100%亮度；distance是光源最远照射到的距离，缺省值为0。</p><h2 id="26-平行光"><a href="#26-平行光" class="headerlink" title="26.平行光"></a>26.平行光</h2><p>我们都知道，太阳光常常被看作平行光，这是因为相对地球上物体的尺度而言，太阳离我们的距离足够远。对于任意平行的平面，平行光照射的亮度都是相同的，而与平面所在位置无关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">THREE.DirectionalLight(hex, intensity);</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">var light = new THREE.DirectionalLight();</span><br><span class="line">light.position.set(2, 5, 3);</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure><p>注意，这里设置光源位置并不意味着所有光从(2, 5, 3)点射出（如果是的话，就成了点光源），而是意味着，平行光将以矢量(-2, -5, -3)的方向照射到所有平面。因此，平面亮度与平面的位置无关，而只与平面的法向量相关。只要平面是平行的，那么得到的光照也一定是相同的。</p><h2 id="27-聚光灯"><a href="#27-聚光灯" class="headerlink" title="27.聚光灯"></a>27.聚光灯</h2><p>可以看出，聚光灯是一种特殊的点光源，它能够朝着一个方向投射光线。聚光灯投射出的是类似圆锥形的光线，这与我们现实中看到的聚光灯是一致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.SpotLight(hex, intensity, distance, angle, exponent)</span><br></pre></td></tr></table></figure><p>相比点光源，多了angle和exponent两个参数。angle是聚光灯的张角，缺省值是Math.PI / 3，最大值是Math.PI / 2；exponent是光强在偏离target的衰减指数（target需要在之后定义，缺省值为(0, 0, 0)），缺省值是10。</p><p>在调用构造函数之后，除了设置光源本身的位置，一般还需要设置target：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">light.position.set(x1, y1, z1);</span><br><span class="line">light.target.position.set(x2, y2, z2);</span><br></pre></td></tr></table></figure><p>除了设置light.target.position的方法外，如果想让聚光灯跟着某一物体移动（就像真的聚光灯！），可以target指定为该物体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),</span><br><span class="line">                    new THREE.MeshLambertMaterial(&#123;color: 0x00ff00&#125;));</span><br><span class="line"></span><br><span class="line">var light = new THREE.SpotLight(0xffff00, 1, 100, Math.PI / 6, 25);</span><br><span class="line">light.target = cube;</span><br></pre></td></tr></table></figure><h2 id="28-半球光"><a href="#28-半球光" class="headerlink" title="28.半球光"></a>28.半球光</h2><p>创建出更加贴近自然的户外光照效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var hemiLight = new THREE.HemisphereLight(0x0000ff,0x00ff00,0.6);   //参数分别是天空发出的颜色、地面发出的颜色、光线照射强度</span><br><span class="line"></span><br><span class="line">hemiLight.position.set(0,500,0);</span><br><span class="line">scene.add(hemiLight);</span><br></pre></td></tr></table></figure><h2 id="29-平面光（略）"><a href="#29-平面光（略）" class="headerlink" title="29.平面光（略）"></a>29.平面光（略）</h2><p>定义一个发光的矩形</p><h2 id="30-镜头眩光"><a href="#30-镜头眩光" class="headerlink" title="30.镜头眩光"></a>30.镜头眩光</h2><p>当你直接朝着太阳拍照时就会出现镜头眩光</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var lensFlare = new THREE.LensFlare(texture,350,0.5,THREE.AdditiveBlending,flareColor);</span><br><span class="line">//参数分别是眩光的材质，眩光尺寸(-1就表示用材质本身的尺寸)，光源(0)到相机(1)的距离，融合模式，颜色</span><br><span class="line"></span><br><span class="line">lensFlare.add(texture,60,0.6,THREE.AdditiveBlending);</span><br><span class="line">//增加眩光</span><br></pre></td></tr></table></figure><h2 id="31-阴影"><a href="#31-阴影" class="headerlink" title="31.阴影"></a>31.阴影</h2><p>在Three.js中，能形成阴影的光源只有THREE.DirectionalLight与THREE.SpotLight；而相对地，能表现阴影效果的材质只有THREE.LambertMaterial与THREE.PhongMaterial。因而在设置光源和材质的时候，一定要注意这一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//首先，我们需要在初始化时，告诉渲染器渲染阴影：</span><br><span class="line">renderer.shadowMapEnabled = true;</span><br><span class="line"></span><br><span class="line">//然后，对于光源以及所有要产生阴影的物体调用：</span><br><span class="line">xxx.castShadow = true;</span><br><span class="line"></span><br><span class="line">//对于接收阴影的物体调用：</span><br><span class="line">xxx.receiveShadow = true;</span><br></pre></td></tr></table></figure><p>对于聚光灯，需要设置shadowCameraNear、shadowCameraFar、shadowCameraFov三个值，类比我们在第二章学到的透视投影照相机，只有介于shadowCameraNear与shadowCameraFar之间的物体将产生阴影，shadowCameraFov表示张角。</p><p>对于平行光，需要设置shadowCameraNear、shadowCameraFar、shadowCameraLeft、shadowCameraRight、shadowCameraTop以及shadowCameraBottom六个值，相当于正交投影照相机的六个面。同样，只有在这六个面围成的长方体内的物体才会产生阴影效果。</p><p>为了看到阴影照相机的位置，通常可以在调试时开启light.shadowCameraVisible = true。</p><p>至此，阴影效果已经能正常显示了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">light.shadowCameraNear = 2;</span><br><span class="line">light.shadowCameraFar = 10;</span><br><span class="line">light.shadowCameraFov = 30;</span><br><span class="line">light.shadowCameraVisible = true;</span><br><span class="line"></span><br><span class="line">light.shadowMapWidth = 1024;</span><br><span class="line">light.shadowMapHeight = 1024;</span><br><span class="line">light.shadowDarkness = 0.3;</span><br></pre></td></tr></table></figure><h2 id="32-通过拉伸创建几何体"><a href="#32-通过拉伸创建几何体" class="headerlink" title="32.通过拉伸创建几何体"></a>32.通过拉伸创建几何体</h2><p>把二维图形拉伸成三维图形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//沿着Z轴拉伸</span><br><span class="line">var options = &#123;</span><br><span class="line">    amount:10,//图形可以拉多高</span><br><span class="line">    bevelThickness:2,//斜角厚度</span><br><span class="line">    bevelSize:1,//斜角尺寸</span><br><span class="line">    bevelSegments:3,//斜角分段数</span><br><span class="line">    bevelEnabled:true,//是否用斜角</span><br><span class="line">    curveSegments:12,//曲线分段数</span><br><span class="line">    steps:1//拉伸体段数</span><br><span class="line">&#125;;</span><br><span class="line">shape = createMesh(new THREE.ExtrudeGeometry(drawShape(),options));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//SVG图像2d变3d</span><br><span class="line">function drawShape()&#123;</span><br><span class="line">    var svgStr = $(&apos;#svg1&apos;).attr(&apos;d&apos;);</span><br><span class="line">    var shape = transformSVGPathExposed(svgStr);    //transformSVGPathExposed这个函数是d3-ThreeD库提供的</span><br><span class="line">    return shape;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var options = &#123;</span><br><span class="line">    amount:10,//图形可以拉多高</span><br><span class="line">    bevelThickness:2,//斜角厚度</span><br><span class="line">    bevelSize:1,//斜角尺寸</span><br><span class="line">    bevelSegments:3,//斜角分段数</span><br><span class="line">    bevelEnabled:true,//是否用斜角</span><br><span class="line">    curveSegments:12,//曲线分段数</span><br><span class="line">    steps:1//拉伸体段数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">shape = createMesh(new THREE.ExtrudeGeometry(drawShape(),options));</span><br></pre></td></tr></table></figure><h2 id="33-粒子"><a href="#33-粒子" class="headerlink" title="33.粒子"></a>33.粒子</h2><h2 id="34-相机控件（详情参见THREE-JS开发指南p181）"><a href="#34-相机控件（详情参见THREE-JS开发指南p181）" class="headerlink" title="34.相机控件（详情参见THREE.JS开发指南p181）"></a>34.相机控件（详情参见THREE.JS开发指南p181）</h2><h2 id="35-为物品添加多种材质"><a href="#35-为物品添加多种材质" class="headerlink" title="35.为物品添加多种材质"></a>35.为物品添加多种材质</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mesh = THREE.SceneUtils.createMultiMaterialObject(geometry,materials);</span><br><span class="line">//参数1是几何体，参数2是一个包含多个材质对象的数组</span><br></pre></td></tr></table></figure><h2 id="36-着色器（略）"><a href="#36-着色器（略）" class="headerlink" title="36.着色器（略）"></a>36.着色器（略）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-渲染器初始化&quot;&gt;&lt;a href=&quot;#1-渲染器初始化&quot; class=&quot;headerlink&quot; title=&quot;1.渲染器初始化&quot;&gt;&lt;/a&gt;1.渲染器初始化&lt;/h2&gt;&lt;p&gt;渲染器将和Canvas元素进行绑定，如果之前在HTML中手动定义了id为mainCanvas
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="three.js" scheme="http://yoursite.com/tags/three-js/"/>
    
  </entry>
  
  <entry>
    <title>web性能优化</title>
    <link href="http://yoursite.com/2017/08/05/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/08/05/web性能优化/</id>
    <published>2017-08-04T16:00:00.000Z</published>
    <updated>2018-03-18T12:29:38.899Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web性能优化"><a href="#web性能优化" class="headerlink" title="web性能优化"></a>web性能优化</h3><p>1.CDN</p><p>2.CSS不要过多使用*，因为他的选择器匹配原则是从右到左</p><p>3.压缩代码</p><p>4.减少http请求</p><p>5.预加载，预渲染：增加 rel=”prefetch”,rel=”dns-prefetch”，或者 rel=”prerender” 标记，详情：（<a href="http://web.jobbole.com/84256/）" target="_blank" rel="noopener">http://web.jobbole.com/84256/）</a></p><p>6.WebAssembly</p><p>7.webpack打包优化</p><p>8.懒加载</p><p>9.合理使用缓存，localstorage,sessionstorage</p><p>10.启用Http2</p><p>11.同构，服务端渲染</p><p>12.service workers</p><p>13.Gzip</p><p>14.将 CSS 样式放在页面的上方，将脚本移动到底部（包括内联的）</p><p>15.雪碧图，字体图标</p><p>16.图像优化</p><p>17.防抖和节流</p><p>18.减少 DOM 操作的次数，避免不必要的重排和重绘</p><p>19.动画合理使用translate3d,opacity来启用单独图层渲染</p><p>20.使用 requestAnimationFrame 来更新页面</p><p>21.可以给 JavaScript 加上 async 标记，表示 JavaScript 的执行不会读取 DOM ，JavaScript 可以不被 CSS 阻塞，可以在空闲时间立刻执行。（正常来说在浏览器没有下载并解析完成使用 link 引入的 CSS 文件之前，JavaScript 是不会执行的）（defer 跟 async 非常相似，不会阻塞页面加载，但会等到 HTML 完成解析后再执行，并且会按出现的次序执行。）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;web性能优化&quot;&gt;&lt;a href=&quot;#web性能优化&quot; class=&quot;headerlink&quot; title=&quot;web性能优化&quot;&gt;&lt;/a&gt;web性能优化&lt;/h3&gt;&lt;p&gt;1.CDN&lt;/p&gt;
&lt;p&gt;2.CSS不要过多使用*，因为他的选择器匹配原则是从右到左&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码学习——笔记</title>
    <link href="http://yoursite.com/2017/08/02/jQuery%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/02/jQuery源码学习笔记/</id>
    <published>2017-08-01T16:00:00.000Z</published>
    <updated>2018-04-22T08:03:25.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-立即调用表达式"><a href="#1-立即调用表达式" class="headerlink" title="1.立即调用表达式"></a>1.立即调用表达式</h3><p>任何库与框架设计的第一个要点就是解决命名空间与变量污染的问题。jQuery就是利用了JavaScript函数作用域的特性，采用立即调用表达式包裹了自身的方法来解决这个问题。</p><p><strong>写法1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function(window,factory)&#123;</span><br><span class="line">    factory(window);</span><br><span class="line">&#125;(this,function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        //jQuery调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>写法1主要是为了判断jQuery在不同平台的下的加载逻辑，主流的库一般都有对 AMD 和 CommonJS 的支持代码。</p><p><strong>写法2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var factory = function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var jQuery = factory();</span><br></pre></td></tr></table></figure><p><strong>写法3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function(window,undefined)&#123;</span><br><span class="line">    var jQuery = function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    window.jQuery = window.$ = jQuery;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure><p>传递参数undefined的原因是：<br>Javascript 中的undefined并不是作为关键字，因此可以允许用户对其赋值，为了避免有人在外面给undefined赋了值，所以我们就把它设置为参数。设置undefined参数后，函数内部它默认就是undefined，不会产生歧义。</p><hr><h3 id="2-处理兼容性"><a href="#2-处理兼容性" class="headerlink" title="2.处理兼容性"></a>2.处理兼容性</h3><p>ie9以前的浏览器对xmlNode.method的存在检测有问题，如window.a == undefined达不到检测效果，而用typeof window.a == ‘undefined’能达到效果。</p><hr><h3 id="3-jq的面向对象的写法"><a href="#3-jq的面向对象的写法" class="headerlink" title="3.jq的面向对象的写法"></a>3.jq的面向对象的写法</h3><p>在jquery源码里面，面向对象的写法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function jQuery()&#123;</span><br><span class="line">    //这样写就能实现调用jQuery的时候，直接调用初始化方法，生成实例，这就省去了jq.init()这一步。</span><br><span class="line">    return new jQuery.prototype.init();</span><br><span class="line">&#125;</span><br><span class="line">jQuery.prototype.init = function()&#123;&#125;;</span><br><span class="line">jQuery.prototype.css = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//把init方法的原型指向jQuery的原型，使得它们共享一份原型，所以也就使得init可以用到jQuery原型上的方法了</span><br><span class="line">jQuery.prototype.init.prototype = jQuery.prototype;</span><br><span class="line"></span><br><span class="line">//就可以这样调用了</span><br><span class="line">jQuery().css();</span><br></pre></td></tr></table></figure></p><hr><h3 id="4-prototype两种写法的差异"><a href="#4-prototype两种写法的差异" class="headerlink" title="4.prototype两种写法的差异"></a>4.prototype两种写法的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这是往原型上去添加或修改属性、方法</span><br><span class="line">A.prototype.age = 18;</span><br><span class="line">A.prototype.name = &apos;lala&apos;;</span><br><span class="line"></span><br><span class="line">//这是重写原型，会覆盖掉默认生成的A.prototype.constructor，所以要把constructor写上</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    constructor:A,</span><br><span class="line">    age:18,</span><br><span class="line">    name:&apos;lala&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-init方法的参数处理"><a href="#5-init方法的参数处理" class="headerlink" title="5.init方法的参数处理"></a>5.init方法的参数处理</h3><p>我们在jQuery中用$()用得很多，它实际上调用的是jQuery的init方法，它可以接受以下这么几种参数，接受不同的参数，它的处理方式也是不一样的：</p><p>1.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这种情况就直接return this，不做其他处理。</span><br><span class="line"></span><br><span class="line">2.```$(&quot;&lt;li&gt;1&lt;/li&gt;&quot;),$(&quot;&lt;div&gt;&quot;),$(&quot;#div1&quot;),$(&quot;div&quot;),$(&quot;#div1 div.box&quot;)</span><br></pre></td></tr></table></figure></p><p>遇到这种参数是字符串的，就会经过一系列判断、处理，最终生成这么一个对象格式：this = {0:’li’,1:’li’,length:2}。</p><p>(1)参数是字符串且匹配&lt;&gt;括号，说明是创建元素，那就调用parseHTML方法把它转化为元素节点数组，再调用merge方法转成上面所说到的this对象。</p><p>(2)参数是一个id选择器的，那就调用原生js的getElementById来获取它，然后也是再转化为this对象。</p><p>(3)参数是复杂多重选择器的，那就调用find方法（实现逻辑参见sizzle）来获取到元素节点。</p><p>3.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这种就会判断参数是不是一个node，是的话也是生成一个this对象。</span><br><span class="line"></span><br><span class="line">4.```$(function()&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>如果参数是一个函数，就会在ready方法的回调中执行这个函数</p><p>5.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 6.pushStack方法</span><br><span class="line"></span><br><span class="line">jq对象的入栈（在slice,eq,map等方法中都是调用到这个方法）</span><br><span class="line">它是一个栈结构，会先处理后入栈的对象，调用end()方法就会回溯到前一个对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">### 7.$.extend和$.fn.extend</span><br><span class="line"></span><br><span class="line">jq里面的继承是拷贝继承</span><br></pre></td></tr></table></figure></p><p>//扩展工具方法<br>$.extend({<br>    a:function(){},<br>    b:function(){}<br>})<br>//调用：<br>$.a();<br>$.b();</p><p>//扩展jq实例方法<br>$.fn.extend({<br>    a:function(){},<br>    b:function(){}<br>})<br>//调用：<br>$().a();<br>$().b();</p><p>//对一个对象进行扩展<br>var a = {};<br>$.extend(a,{age:18},{name:’lala’})</p><p>//深浅拷贝<br>$.extend(a,b);//浅拷贝<br>$.extend(true,a,b);//深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 8.extend方法详解</span><br><span class="line"></span><br><span class="line">**(1)生成唯一字符串(内部)**</span><br><span class="line">```$.expando</span><br></pre></td></tr></table></figure><p><strong>(2)解决冲突</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.noConflict()</span><br><span class="line">//写到上一个插件前面</span><br><span class="line">var aaa=$.noConflict();</span><br><span class="line">aaa(function()&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>(3)ready回调</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;&#125;) </span><br><span class="line">相当于</span><br><span class="line">$(document).ready(function()&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>DOM加载完就执行，它通过判断document.readyState或者给document加一个DOMContentLoaded事件监听来触发调用。<br>（ps：可以通过holdReady来控制同步异步，它的实现方式是以计数的方式判断是否能执行下去）</p><p><strong>(4)isWindow方法用来判断是不是window对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isWindow:function(obj)&#123;</span><br><span class="line">    return obj!=null &amp;&amp; obj===obj.window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(5)isNumeric方法用来判断是不是数值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNumeric:function(obj)&#123;</span><br><span class="line">    return !isNaN(parseFloat(obj)) &amp;&amp; isFinite(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(6)isPlainObject判断是不是对象自变量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isPlainObject:function(obj)&#123;</span><br><span class="line">    if(jQuery.type(obj)!==&quot;object&quot; || obj.nodeType || jQuery.isWindow(obj))&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        if(obj.constructor &amp;&amp; !core_hasOwn.call(obj.constructor.prototype,&quot;isPrototypeOf&quot;))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(7)parseHTML方法把标签字符串转换为html元素节点数组</strong></p><p>判断逻辑：</p><p>1.先用正则判断是不是单标签，是单标签就直接createElement</p><p>2.多标签就调用buildFragment</p><p><strong>(8)globalEval方法在全局执行传递进去的字符串参数</strong></p><p>判断逻辑：</p><p>如果是严格模式，那就新建一个script标签，标签里的内容是参数的内容，然后插入到文档中。</p><p>如果不是那就直接eval（因为严格模式下eval有自身的作用域，不是全局的作用域）</p><p><strong>(9)camelCase转驼峰写法（ps：ms前缀与众不同）</strong></p><p>ps:replace方法第二个参数可以是一个函数，这个函数有4个参数可以传入：第一个参数：正则所匹配到的字符；第二个参数：捕获括号所捕获到的字符；<br>第三个参数：正则匹配到的每段字符的第一个字符的索引；第四个参数：用于匹配的字符串主体；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">camelCase:function(str)&#123;</span><br><span class="line">    return str.replace(/^-ms-/,&quot;ms-&quot;).replace(/-([\da-z])/gi,(all,letter)=&gt;&#123;</span><br><span class="line">        return letter.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(10)nodeName方法判断节点的nodename</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeName:function(elem,name)&#123;</span><br><span class="line">    return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase()===name.toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(11)merge方法合并两个数组或形如{0:’a’,1:’b’,length:2}</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">merge:function(first,second)&#123;</span><br><span class="line">    var l = second.length,</span><br><span class="line">        i = first.length,</span><br><span class="line">        j = 0;</span><br><span class="line">    if(typeof l===&quot;number&quot;)&#123;</span><br><span class="line">        for(;j&lt;l;j++)&#123;</span><br><span class="line">            first[i++] = second[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        while(second[j]!==undefined)&#123;</span><br><span class="line">            first[i++] = second[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    first.length = i;</span><br><span class="line">    return first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(12)$(‘#div1’).width()</strong></p><p>它能够获取到即使display为none的元素的宽度，原生的offsetWidth是获取不到的</p><p>它的做法是先把display:none存起来，然后给元素加上display:block;visibility:hidden;position:absolute再获取它的offsetWidth，获取到之后再把刚才存起来的display:none还原，实现“偷梁换柱”（其实这种操作是依靠swap函数来实现的）</p><hr><h3 id="9-Callbacks-回调执行了解一下"><a href="#9-Callbacks-回调执行了解一下" class="headerlink" title="9.$.Callbacks()回调执行了解一下"></a>9.$.Callbacks()回调执行了解一下</h3><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var cb = $.Callbacks(options);</span><br><span class="line">options可以是：&apos;once&apos;,&apos;memory&apos;,&apos;unique&apos;,&apos;stopOnFalse&apos;</span><br><span class="line"></span><br><span class="line">//往回调数组中添加函数</span><br><span class="line">function a()&#123;&#125;</span><br><span class="line">function b()&#123;&#125;</span><br><span class="line">cb.add(a);</span><br><span class="line">cb.add(b);</span><br><span class="line"></span><br><span class="line">//依次调用</span><br><span class="line">cb.fire();</span><br></pre></td></tr></table></figure></p><p>首先有一个list数组来保存callbacks</p><p><strong>(0)options配置参数：</strong></p><p>once代表只能fire一次；</p><p>memory代表即使你的add在fire后面添加，但是也还能生效，他的实现原理是在add方法里面加上fire；</p><p>unique代表对list去重;</p><p>stopOnFlase代表如果回调函数里有return false的话，那就停止后面的执行。</p><p><strong>(1)add方法：</strong><br>往list里面push回调函数</p><p><strong>(2)remove方法：</strong><br>对list进行splice操作来移除某个回调函数</p><p><strong>(3)fire方法：</strong><br>遍历list，依次执行</p><hr><h3 id="10-Deferred-处理异步流程"><a href="#10-Deferred-处理异步流程" class="headerlink" title="10.$.Deferred()处理异步流程"></a>10.$.Deferred()处理异步流程</h3><p>实际上也是调用$.Callbacks()来处理。</p><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var dfd = $.Deferred();</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    alert(1);</span><br><span class="line">    dfd.resolve();  //这是成功触发，另外还有失败触发标志reject</span><br><span class="line">&#125;,1000);</span><br><span class="line">dfd.done(function()&#123;</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;)</span><br><span class="line">dfd.fail(function()&#123;</span><br><span class="line">    alert(3);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>done,fail方法对应callbacks的add方法，resolve,reject方法对应callbacks的fire方法。</p><p>resolve,done实际上对应的是$.Callbacks(‘once memory’)，有once是为了使状态不可逆，只触发一次；</p><p>reject,fail实际上对应的是$.Callbacks(‘once memory’)，有once是为了使状态不可逆，只触发一次；</p><p>notify,progress实际上对应的是$.Callbacks(‘memory’)。</p><p>内部还有一个自定义的promise对象来新增一些协助函数方法，它跟deferred不一样的地方就是它没有那三种状态，防止调用这个方法的时候把状态给改了。</p><p><strong>$.when()方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//相当于promise.all</span><br><span class="line">$.when(a(),b()).done(function()&#123;</span><br><span class="line">    alert(&apos;success&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>它会把参数放进一个数组里面并执行，内部有一个计数器，数值等于数组长度，每有一个参数完成计数器就减一，当计数器为0时那就执行内部新建的$.Deferred()</p><hr><h3 id="11-通过support进行功能检测"><a href="#11-通过support进行功能检测" class="headerlink" title="11.通过support进行功能检测"></a>11.通过support进行功能检测</h3><p>作为兼容性功能的判断实现，主要有样式兼容、h5兼容、js兼容等等。可以通过创建一些元素来检测不同浏览器下这些元素的表现行为、属性方法有什么异同，检测完之后就可以把元素给删掉。</p><p>而针对不同环境下作出不同的反应是通过hooks实现的，support只是一个兼容判断。</p><hr><h3 id="12-attr、prop和data"><a href="#12-attr、prop和data" class="headerlink" title="12.attr、prop和data"></a>12.attr、prop和data</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#div1&apos;).attr(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line">相当于</span><br><span class="line">document.getElementById(&apos;div1&apos;).setAttribute(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line"></span><br><span class="line">$(&apos;#div1&apos;).prop(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line">相当于</span><br><span class="line">document.getElementById(&apos;div1&apos;).name=&apos;lala&apos;;</span><br><span class="line"></span><br><span class="line">//当然不会这么简单直接设置，它们还会检测参数合法性，解决浏览器兼容问题等等</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这样不会内存泄漏</span><br><span class="line">$(&apos;#div1&apos;).data(&apos;name&apos;,obj);</span><br><span class="line">//这样有可能会内存泄漏</span><br><span class="line">$(&apos;#div1&apos;).attr(&apos;name&apos;,obj);</span><br><span class="line"></span><br><span class="line">//ps：DOM元素和对象之间相互引用，大部分浏览器就会出现内存泄漏</span><br><span class="line">var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">div1.name = obj;</span><br><span class="line">obj.age = div1;</span><br></pre></td></tr></table></figure><p>data方法是怎么做到消除内存泄漏的呢？</p><p>其实它是先新建一个cache对象来存放一种对应联系，建立元素绑定的属性和你自定义要绑定进去的属性之间的联系，就是说这是一种间接绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//cache就是类似于以下这样的结构</span><br><span class="line">this.cache=&#123;</span><br><span class="line">    1:&#123;name:&apos;lala&apos;&#125;,</span><br><span class="line">    2:&#123;name:&apos;lala&apos;,age:19&#125;</span><br><span class="line">&#125;</span><br><span class="line">//它会给每个data分配一个映射到实际属性的key：1、2、3...，同一个元素分配到的都是同一个key</span><br><span class="line">//元素上挂载的实际上是类似于这样的东西：</span><br><span class="line"></span><br><span class="line">&lt;div jquery784382547239469837=&quot;1&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//当this不是元素或者document节点时，这个cache会通过Object.defineProperty设置一个key为0，getter为&#123;&#125;的属性，这是处理非元素节点时用的</span><br></pre></td></tr></table></figure><hr><h3 id="13-jQuery的queue"><a href="#13-jQuery的queue" class="headerlink" title="13.jQuery的queue"></a>13.jQuery的queue</h3><p>跟数据结构里的队列是一样的，只不过它存放的是函数，出队列的时候就会调用这个函数,要前一个函数出了队列才会执行下一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//多个动画animate就用到了queue</span><br><span class="line">$(this).animate(&#123;width:300&#125;,2000);</span><br><span class="line">$(this).animate(&#123;height:100&#125;,2000);</span><br><span class="line">$(this).animate(&#123;left:500&#125;,2000);</span><br></pre></td></tr></table></figure><hr><h3 id="14-对class的操作"><a href="#14-对class的操作" class="headerlink" title="14.对class的操作"></a>14.对class的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#div1&apos;).addClass(&apos;box1 box2&apos;);</span><br><span class="line">$(&apos;#div1&apos;).removeClass(&apos;box1 box2&apos;);</span><br><span class="line">$(&apos;#div1&apos;).toggleClass(&apos;box1 box2&apos;);</span><br></pre></td></tr></table></figure><p>addClass实际上是对传进来的字符串进行检验、分割，然后再用indexOf判断元素原来的class里面有没有新增的class，没有才添加进去，有就不管。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-立即调用表达式&quot;&gt;&lt;a href=&quot;#1-立即调用表达式&quot; class=&quot;headerlink&quot; title=&quot;1.立即调用表达式&quot;&gt;&lt;/a&gt;1.立即调用表达式&lt;/h3&gt;&lt;p&gt;任何库与框架设计的第一个要点就是解决命名空间与变量污染的问题。jQuery就是利用了
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>fl效果器</title>
    <link href="http://yoursite.com/2017/07/12/fl%E6%95%88%E6%9E%9C%E5%99%A8/"/>
    <id>http://yoursite.com/2017/07/12/fl效果器/</id>
    <published>2017-07-11T16:00:00.000Z</published>
    <updated>2018-03-18T11:30:12.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录下fl效果器的效果"><a href="#记录下fl效果器的效果" class="headerlink" title="记录下fl效果器的效果"></a>记录下fl效果器的效果</h3><p>EQUO 音色粗细</p><p>Fabfilter simplon 电音</p><p>fruity chorus 和声</p><p>fruity convolver 空旷回声</p><p>fruity delay 2 重复音</p><p>fruity delay bank 重复音不同</p><p>fruity fast dist 电噪音</p><p>fruity flanger 多种回音</p><p>fruity flangus 电子跳音</p><p>fruity limiter 强弱</p><p>fruity love philter 未来电音</p><p>fruity multiband compressor 钝、干</p><p>fruity parametric EQ 铁质音</p><p>fruity parametric EQ2 多样铁质音</p><p>fruity phaser 多样</p><p>fruity reeverb2 场合音</p><p>fruity squeeze 噪铁</p><p>fruity stereo enhancer 立体音</p><p>fruity stereo shaper 左右声道多样</p><p>fruity vocoder 低小音</p><p>fruity waveshaper 噪</p><p>gross beat 多样重</p><p>hardcore 空灵噪</p><p>maximus 干电音</p><p>soundgoodizer 电</p><p>vocodex 弹东西的声音，赞</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;记录下fl效果器的效果&quot;&gt;&lt;a href=&quot;#记录下fl效果器的效果&quot; class=&quot;headerlink&quot; title=&quot;记录下fl效果器的效果&quot;&gt;&lt;/a&gt;记录下fl效果器的效果&lt;/h3&gt;&lt;p&gt;EQUO 音色粗细&lt;/p&gt;
&lt;p&gt;Fabfilter simplon
      
    
    </summary>
    
      <category term="电音" scheme="http://yoursite.com/categories/%E7%94%B5%E9%9F%B3/"/>
    
    
      <category term="fl" scheme="http://yoursite.com/tags/fl/"/>
    
      <category term="电音" scheme="http://yoursite.com/tags/%E7%94%B5%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/06/15/hello-world/"/>
    <id>http://yoursite.com/2017/06/15/hello-world/</id>
    <published>2017-06-14T16:00:00.000Z</published>
    <updated>2018-03-18T11:27:05.387Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="其它" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
