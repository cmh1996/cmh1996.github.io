<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chambers个人博客</title>
  
  <subtitle>记录点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-11T06:19:48.658Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chambers</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一探Webpack模块化机制</title>
    <link href="http://yoursite.com/2018/07/12/%E4%B8%80%E6%8E%A2Webpack%E6%A8%A1%E5%9D%97%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/07/12/一探Webpack模块化机制/</id>
    <published>2018-07-11T16:00:00.000Z</published>
    <updated>2018-09-11T06:19:48.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack模块化"><a href="#Webpack模块化" class="headerlink" title="Webpack模块化"></a>Webpack模块化</h2><p>对于webpack的模块化的实现，我们可以大致分为三种类型：<strong>commonjs</strong>，<strong>es6 Module</strong>，<strong>code splitting</strong>。</p><hr><h3 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h3><p>当我们在代码中使用到commonjs的模块化时，webpack就会用hack的手段帮我们处理好这些模块的关系，例如，我们写出这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">//假设index.js是webpack的打包入口文件</span><br><span class="line">var a = require(&apos;./a&apos;);</span><br><span class="line">console.log(a.name);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    name:&apos;cmh&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后经过webpack的打包转化，大概会生成这样的代码（简化版）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//一个IIFE</span><br><span class="line">//参数modules是存放着各模块的一个json</span><br><span class="line">(function (modules) &#123;</span><br><span class="line">    //存放模块缓存的对象</span><br><span class="line">    var installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //webpack实现的require，参数是传入一个你要require的模块的id</span><br><span class="line">    function __webpack_require__(moduleId) &#123;</span><br><span class="line"></span><br><span class="line">        //如果这个模块已经缓存过，那就直接返回它的exports</span><br><span class="line">        if(installedModules[moduleId]) &#123;</span><br><span class="line">            return installedModules[moduleId].exports;</span><br><span class="line">        &#125;</span><br><span class="line">        //没有的话就进行缓存模块</span><br><span class="line">        var module = installedModules[moduleId] = &#123;</span><br><span class="line">            i: moduleId,    //模块id</span><br><span class="line">            l: false,       //模块是否被加载了</span><br><span class="line">            exports: &#123;&#125;     //重写exports，即导出的内容</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //执行这个要被require的函数</span><br><span class="line">        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">        //标志模块被加载了</span><br><span class="line">        module.l = true;</span><br><span class="line"></span><br><span class="line">        //返回导出</span><br><span class="line">        return module.exports;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //最后再返回导入入口文件</span><br><span class="line">    return __webpack_require__(__webpack_require__.s = &quot;./index.js&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">(&#123;</span><br><span class="line">&quot;./a.js&quot;:(function(module,exports)&#123;</span><br><span class="line">    eval(&quot;module.exports = &#123;name:&apos;cmh&apos;&#125;&quot;);</span><br><span class="line">&#125;),</span><br><span class="line">&quot;./index.js&quot;:(function(module,exports,__webpack_require__)&#123;</span><br><span class="line">    eval(</span><br><span class="line">        &quot;var a = __webpack_require__(/*! ./a */ \&quot;./a.js\&quot;);</span><br><span class="line">        console.log(a.name);&quot;</span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>定义了installedModules ，这个变量被用来缓存已加载的模块。</li><li>定义了<strong>webpack_require</strong>这个函数，函数参数为模块的id。这个函数用来实现模块的require。</li><li>webpack_require函数首先会检查是否缓存了已加载的模块，如果有则直接返回缓存模块的exports。</li><li><p>如果没有缓存，也就是第一次加载，则首先初始化模块，并将模块进行缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    i: moduleId,</span><br><span class="line">    l: false,</span><br><span class="line">    exports: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后调用模块函数，也就是前面webpack对我们的模块的包装函数，将module、module.exports和<strong>webpack_require</strong>作为参数传入。注意这里做了一个动态绑定，将模块函数的调用对象绑定为module.exports，这是为了保证在模块中的this指向当前模块。</p></li><li>调用完成后，模块标记为已加载。</li><li>返回模块exports的内容。</li><li>利用前面定义的<strong>webpack_require</strong>函数，require入口模块，在这里是index.js。</li></ol><p>可以看到，这是一个立即执行函数，它会把各个模块函数当作参数传入到这个函数当中，然后经过对require，module.exports这些的处理（详情看上面代码的注释），就完成了对模块的require，然后这个模块又会根据自己对其他模块的require，依次加载其他模块，最终形成一个依赖网状结构。webpack管理着这些模块的缓存，如果一个模块被require多次，那么只会有一次加载过程，而返回的是缓存的内容，这也是commonjs的规范。</p><hr><h3 id="es6-Module"><a href="#es6-Module" class="headerlink" title="es6 Module"></a>es6 Module</h3><p>然后再来看看当我们在代码中使用到es6的模块化时，webpack会怎么处理？<br>例如，我们写出这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">//入口文件</span><br><span class="line">import bar from &apos;./a&apos;;</span><br><span class="line">import &#123;foo&#125; from &apos;./a&apos;;</span><br><span class="line">bar();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">export function foo()&#123;</span><br><span class="line">    return &apos;foo&apos;;</span><br><span class="line">&#125;</span><br><span class="line">export default function bar()&#123;</span><br><span class="line">    return &apos;bar&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后说说它跟commonjs转换的不同之处（相同的就不赘述了）<br>主要的不同之处在于传入的模块的解析部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//这里先放几个在说明过程中需要用到的函数：</span><br><span class="line"></span><br><span class="line">//1.r函数</span><br><span class="line">//通过Object.defineProperty在__webpack_exports__上添加属性__esModule</span><br><span class="line">//值为true，表明这是一个es模块。（在commonjs和es6Module混用时会用到，在这里暂时没用）</span><br><span class="line">__webpack_require__.r = function(exports) &#123;</span><br><span class="line">    Object.defineProperty(exports, &apos;__esModule&apos;, &#123; value: true &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.d函数</span><br><span class="line">//export default和export都被转换成了类似于commonjs的exports.xxx，</span><br><span class="line">//export对象变为__webpack_exports__的属性。</span><br><span class="line">__webpack_require__.d = function(exports, name, getter) &#123;</span><br><span class="line">    if(!__webpack_require__.o(exports, name)) &#123;</span><br><span class="line">        Object.defineProperty(exports, name, &#123;</span><br><span class="line">            configurable: false,</span><br><span class="line">            enumerable: true,</span><br><span class="line">            get: getter</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//模块部分</span><br><span class="line">//在这里用到的r,d函数在上面有说明</span><br><span class="line">&quot;./a.js&quot;:(function(module, __webpack_exports__, __webpack_require__) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    eval(&quot;</span><br><span class="line">        __webpack_require__.r(__webpack_exports__);</span><br><span class="line">        __webpack_require__.d(__webpack_exports__, \&quot;foo\&quot;, function() &#123; return foo; &#125;);</span><br><span class="line">        __webpack_require__.d(__webpack_exports__, \&quot;default\&quot;, function() &#123; return bar; &#125;);</span><br><span class="line">        function foo()&#123;return &apos;foo&apos;;&#125;</span><br><span class="line">        function bar()&#123;return &apos;bar&apos;;&#125;</span><br><span class="line">    &quot;)</span><br><span class="line">&#125;),</span><br><span class="line">&quot;./index.js&quot;:(function(module, __webpack_exports__, __webpack_require__) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    eval(&quot;</span><br><span class="line">        __webpack_require__.r(__webpack_exports__);</span><br><span class="line">        var _a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./a */ \&quot;./a.js\&quot;);</span><br><span class="line">        Object(_a__WEBPACK_IMPORTED_MODULE_0__[\&quot;default\&quot;])();</span><br><span class="line">        Object(_a__WEBPACK_IMPORTED_MODULE_0__[\&quot;foo\&quot;])()</span><br><span class="line">    &quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>前面讲commonjs的时候已经分析过了，webpack生成的代码是一个IIFE，这个IIFE完成一系列初始化工作后，就会通过<code>__webpack_require__(__webpack_require__.s = &quot;./index.js&quot;)</code>启动入口模块。这个跟前面一样。</li><li>然后就是通过<strong>webpack_require</strong>(‘./a.js’)导入a.js模块，再然后通过module.xxx获取a.js中export的对应属性。注意这里有一个重要的点，就是所有引入的模块属性都会用Object()包装成对象，这是为了保证像Boolean、String、Number这些基本数据类型转换成相应的类型对象。</li><li>为什么可以通过module.xxx拿到a.js中export的值呢？就是因为webpack通过d函数把a.js的export对象变为a模块的exports属性，这样就能拿到了。</li></ol><hr><h3 id="通过import-进行code-splitting"><a href="#通过import-进行code-splitting" class="headerlink" title="通过import()进行code splitting"></a>通过import()进行code splitting</h3><p>webpack提供了import()的方法可以让我们对代码进行分割。<br>比如，我们可以利用这点来实现Vue组件的懒加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; import(&apos;./Foo.vue&apos;)</span><br></pre></td></tr></table></figure></p><p>ps:注意：如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。</p><p>那么，它的实现原理是怎样的呢？<br>首先，我们先新建两个文件：入口文件index.js和模块文件a.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">import(&apos;./a&apos;).then((foo)=&gt;&#123;</span><br><span class="line">    console.log(foo())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//a.js</span><br><span class="line">exports.foo = function()&#123;</span><br><span class="line">    return &apos;a&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后打包，我们发现这次的打包跟之前的不一样的是它生成了两个文件：<br>主文件index.js和模块文件0.js</p><h4 id="主文件index-js："><a href="#主文件index-js：" class="headerlink" title="主文件index.js："></a>主文件index.js：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这次没了a，是因为它被分离到另一个文件中去了</span><br><span class="line">&quot;./index.js&quot;:(function(module, exports, __webpack_require__) &#123;</span><br><span class="line">    eval(&quot;</span><br><span class="line">        __webpack_require__.e(/*! import() */ 0)</span><br><span class="line">        .then(function() &#123; </span><br><span class="line">            var module = __webpack_require__(/*! ./a */ \&quot;./a.js\&quot;); </span><br><span class="line">            return typeof module === \&quot;object\&quot; &amp;&amp; module &amp;&amp; module.__esModule ? module : Object.assign(&#123;/* fake namespace object */&#125;, typeof module === \&quot;object\&quot; &amp;&amp; module, &#123; \&quot;default\&quot;: module &#125;); &#125;)</span><br><span class="line">        .then((foo)=&gt;&#123;console.log(foo())&#125;)</span><br><span class="line">    &quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从上面我们可以看出，这个e函数起到了关键作用，并且它还返回promise实现了异步加载。</p><p>接下来我们来看看，e函数是何方神圣：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.e = function requireEnsure(chunkId) &#123;</span><br><span class="line">    var promises = [];</span><br><span class="line">    </span><br><span class="line">    var installedChunkData = installedChunks[chunkId];</span><br><span class="line">    if(installedChunkData !== 0) &#123;</span><br><span class="line"></span><br><span class="line">        if(installedChunkData) &#123;</span><br><span class="line">            promises.push(installedChunkData[2]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">                installedChunkData = installedChunks[chunkId] = [resolve, reject];</span><br><span class="line">            &#125;);</span><br><span class="line">            promises.push(installedChunkData[2] = promise);</span><br><span class="line"></span><br><span class="line">            var head = document.getElementsByTagName(&apos;head&apos;)[0];</span><br><span class="line">            var script = document.createElement(&apos;script&apos;);</span><br><span class="line"></span><br><span class="line">            script.charset = &apos;utf-8&apos;;</span><br><span class="line">            script.timeout = 120;</span><br><span class="line"></span><br><span class="line">            if (__webpack_require__.nc) &#123;</span><br><span class="line">                script.setAttribute(&quot;nonce&quot;, __webpack_require__.nc);</span><br><span class="line">            &#125;</span><br><span class="line">            script.src = jsonpScriptSrc(chunkId);</span><br><span class="line">            var timeout = setTimeout(function()&#123;</span><br><span class="line">                onScriptComplete(&#123; type: &apos;timeout&apos;, target: script &#125;);</span><br><span class="line">            &#125;, 120000);</span><br><span class="line">            script.onerror = script.onload = onScriptComplete;</span><br><span class="line">            function onScriptComplete(event) &#123;</span><br><span class="line">                script.onerror = script.onload = null;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                var chunk = installedChunks[chunkId];</span><br><span class="line">                if(chunk !== 0) &#123;</span><br><span class="line">                    if(chunk) &#123;</span><br><span class="line">                        var errorType = event &amp;&amp; (event.type === &apos;load&apos; ? &apos;missing&apos; : event.type);</span><br><span class="line">                        var realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;</span><br><span class="line">                        var error = new Error(&apos;Loading chunk &apos; + chunkId + &apos; failed.\n(&apos; + errorType + &apos;: &apos; + realSrc + &apos;)&apos;);</span><br><span class="line">                        error.type = errorType;</span><br><span class="line">                        error.request = realSrc;</span><br><span class="line">                        chunk[1](https://cdn.example.com/error?m=webp&q=80);</span><br><span class="line">                    &#125;</span><br><span class="line">                    installedChunks[chunkId] = undefined;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            head.appendChild(script);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.all(promises);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>e函数主要做了这些事：</p><ol><li>缓存查找：从缓存installedChunks中查找是否有缓存模块，如果缓存标识为0，则表示模块已加载过，直接返回promise；如果缓存为数组，表示缓存正在加载中，则返回缓存的promise对象<br>2.如果没有缓存，则创建一个promise，并将promise和resolve、reject缓存在installedChunks中<br>3.构建一个script标签，append到head标签中，src指向加载的模块脚本资源，实现动态加载js脚本<br>4.添加script标签onload、onerror事件，如果超时或者模块加载失败，则会调用reject返回模块加载失败异常<br>5.如果模块加载成功，则返回当前模块promise，对应于import()</li></ol><h4 id="分割出来的模块0-js："><a href="#分割出来的模块0-js：" class="headerlink" title="分割出来的模块0.js："></a>分割出来的模块0.js：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([[0],&#123;</span><br><span class="line">    &quot;./a.js&quot;:(function(module, exports) &#123;</span><br><span class="line">        eval(&quot;</span><br><span class="line">            exports.foo = function()&#123;</span><br><span class="line">                return &apos;a&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>这里的webpackJsonp类似于jsonp中的callback，作用是作为模块加载和执行完成的回调，从而触发import的resolve。</p><p>从上面我们可以看出，webpack通过<strong>webpack_require</strong>.e函数实现了动态加载，再通过webpackJsonp函数实现异步加载回调，把模块内容以promise的方式暴露给调用方，从而实现了对code splitting的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Webpack模块化&quot;&gt;&lt;a href=&quot;#Webpack模块化&quot; class=&quot;headerlink&quot; title=&quot;Webpack模块化&quot;&gt;&lt;/a&gt;Webpack模块化&lt;/h2&gt;&lt;p&gt;对于webpack的模块化的实现，我们可以大致分为三种类型：&lt;strong&gt;
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="模块化" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>读读Koa2源码</title>
    <link href="http://yoursite.com/2018/06/14/%E8%AF%BB%E8%AF%BBKoa2%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2018/06/14/读读Koa2源码/</id>
    <published>2018-06-13T16:00:00.000Z</published>
    <updated>2018-09-25T02:52:52.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读读Koa2源码"><a href="#读读Koa2源码" class="headerlink" title="读读Koa2源码"></a>读读Koa2源码</h2><p>本人因为一直用的都是Koa2作为nodejs的开发框架，所以也对Koa2的原理产生了兴趣。于是我便花了一点时间分析了一下Koa2的源码，看看这个轻量级框架到底有多“轻”。</p><p>koa2的源码只有四个主要文件，我们一个一个来分析：<br><code>application.js</code>，<code>context.js</code>，<code>request.js</code>，<code>response.js</code></p><hr><h3 id="application-js-主入口文件"><a href="#application-js-主入口文件" class="headerlink" title="application.js 主入口文件"></a>application.js 主入口文件</h3><h4 id="继承events"><a href="#继承events" class="headerlink" title="继承events"></a>继承events</h4><p>这个文件导出了一个类<code>Application</code>，它继承了Emitter类，这样做是为了让koa也能监听事件，<br>例如，我们在koa中是这样来监听错误的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//没有处理过的错误将在这里被捕获</span><br><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line">app.on(&apos;error&apos;, err =&gt; console.log(err));</span><br></pre></td></tr></table></figure></p><h4 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h4><p>然后我们继续往下看，看到listen函数。<br>listen函数用于监听端口，它其实是对原生http模块的listen做了一下封装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">    debug(&apos;listen&apos;);</span><br><span class="line">    const server = http.createServer(this.callback());</span><br><span class="line">    return server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="callback函数"><a href="#callback函数" class="headerlink" title="callback函数"></a>callback函数</h4><p>我们看到createSever的时候传入了一个callback函数，它是创建完服务器之后要执行的回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line">    const fn = compose(this.middleware);</span><br><span class="line"></span><br><span class="line">    if (!this.listenerCount(&apos;error&apos;)) this.on(&apos;error&apos;, this.onerror);</span><br><span class="line"></span><br><span class="line">    const handleRequest = (req, res) =&gt; &#123;</span><br><span class="line">      const ctx = this.createContext(req, res);</span><br><span class="line">      return this.handleRequest(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它首先会把传入的中间件都用compose来处理（这是中间件的处理函数，后面会说到），然后返回一个handleRequest函数：先用createContext函数创建一个context环境，然后再把ctx和中间件放到handleRequest中去处理。</p><h4 id="compose函数"><a href="#compose函数" class="headerlink" title="compose函数"></a>compose函数</h4><p>在koa中compose是交给了<code>koa-compose</code>来处理，所以我们找来了<code>koa-compose</code>库来看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function compose (middleware) &#123;</span><br><span class="line">  if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;)</span><br><span class="line">  for (const fn of middleware) &#123;</span><br><span class="line">    if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return function (context, next) &#123;</span><br><span class="line">    // last called middleware #</span><br><span class="line">    let index = -1</span><br><span class="line">    return dispatch(0)</span><br><span class="line">    function dispatch (i) &#123;</span><br><span class="line">      if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;))</span><br><span class="line">      index = i</span><br><span class="line">      let fn = middleware[i]</span><br><span class="line">      if (i === middleware.length) fn = next</span><br><span class="line">      if (!fn) return Promise.resolve()</span><br><span class="line">      try &#123;</span><br><span class="line">        return Promise.resolve(fn(context, function next () &#123;</span><br><span class="line">          return dispatch(i + 1)</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        return Promise.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它先对传进来的中间件数组做一些合法性检测，然后返回一个函数来通过递归去遍历执行所有的中间件函数。<br>通过在<code>Promise.resolve(fn)</code>的回调中执行fn即实现了对异步函数的处理。我们可以关注一下 最初是执行的是 dispatch(0) 也就是this.middleware数组中下标为0的函数，也就是说 最先进入的中间件函数会最先被执行就像一个执行队列。<br>执行完成以后执行next()到下一步处理，next就是下一个的中间件。</p><h4 id="use函数"><a href="#use函数" class="headerlink" title="use函数"></a>use函数</h4><p>use函数也很简单，就是把中间件push到中间件数组当中最后返回this来提供链式调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use(fn) &#123;</span><br><span class="line">    if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;);</span><br><span class="line">    if (isGeneratorFunction(fn)) &#123;</span><br><span class="line">      deprecate(&apos;Support for generators will be removed in v3. &apos; +</span><br><span class="line">                &apos;See the documentation for examples of how to convert old middleware &apos; +</span><br><span class="line">                &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;);</span><br><span class="line">      fn = convert(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;);</span><br><span class="line">    this.middleware.push(fn);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="createContext函数"><a href="#createContext函数" class="headerlink" title="createContext函数"></a>createContext函数</h4><p>在上面的callback函数中我们看到它是通过createContext来创建ctx，<br>平时使用koa2的时候，ctx用的比较多，我们在ctx上面既可以处理req，又可以处理res，那它是怎么做到的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">createContext(req, res) &#123;</span><br><span class="line">    const context = Object.create(this.context);</span><br><span class="line">    const request = context.request = Object.create(this.request);</span><br><span class="line">    const response = context.response = Object.create(this.response);</span><br><span class="line">    context.app = request.app = response.app = this;</span><br><span class="line">    context.req = request.req = response.req = req;</span><br><span class="line">    context.res = request.res = response.res = res;</span><br><span class="line">    request.ctx = response.ctx = context;</span><br><span class="line">    request.response = response;</span><br><span class="line">    response.request = request;</span><br><span class="line">    context.originalUrl = request.originalUrl = req.url;</span><br><span class="line">    context.cookies = new Cookies(req, res, &#123;</span><br><span class="line">      keys: this.keys,</span><br><span class="line">      secure: request.secure</span><br><span class="line">    &#125;);</span><br><span class="line">    request.ip = request.ips[0] || req.socket.remoteAddress || &apos;&apos;;</span><br><span class="line">    context.accept = request.accept = accepts(req);</span><br><span class="line">    context.state = &#123;&#125;;</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实它也就是把一些常用的属性挂载到ctx上，让ctx就像一个大管家那样，拥有许多的权力。</p><h4 id="handleRequest函数"><a href="#handleRequest函数" class="headerlink" title="handleRequest函数"></a>handleRequest函数</h4><p>上面的callback函数就是把经过createContext处理的ctx和经过compose处理的fn传入到这个函数中，最终返回这个handleRequest函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">    const res = ctx.res;</span><br><span class="line">    res.statusCode = 404;</span><br><span class="line">    const onerror = err =&gt; ctx.onerror(err);</span><br><span class="line">    const handleResponse = () =&gt; respond(ctx);</span><br><span class="line">    onFinished(res, onerror);</span><br><span class="line">    return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>handleRequest中首先先取出res，先把默认状态置为404，然后对执行中间件后的成功和失败状态注册方法，失败调用ctx.onerror捕获异常，成功调用respond方法处理结果。这里还是用了onFinished模块，onFinished能确保一个流在关闭、完成和报错时都会执行相应的回调函数，这里把我们的异常处理函数传入用以处理错误信息。而respond方法，里面做的，就是读取ctx信息，把数据写入res中并响应请求。</p><h4 id="respond函数"><a href="#respond函数" class="headerlink" title="respond函数"></a>respond函数</h4><p>koa是通过respond来把数据写入res中并响应请求的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function respond(ctx) &#123;</span><br><span class="line">  //ctx.respond不存在则return</span><br><span class="line">  if (false === ctx.respond) return;</span><br><span class="line">    </span><br><span class="line">  //writable 是原生的 response 对象的 writeable 属性, 检查是否是可写流</span><br><span class="line">  const res = ctx.res;</span><br><span class="line">  if (!ctx.writable) return;</span><br><span class="line"></span><br><span class="line">  let body = ctx.body;</span><br><span class="line">  const code = ctx.status;</span><br><span class="line"></span><br><span class="line">  //如果响应的statusCode是属于body为空的类型, 例如204,205,304将body置为null</span><br><span class="line">  if (statuses.empty[code]) &#123;</span><br><span class="line">    ctx.body = null;</span><br><span class="line">    return res.end();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  //如果是HEAD方法，检查 http 响应头部是否已经被发送，如果头部未被发送, 那么添加 length 头部</span><br><span class="line">  if (&apos;HEAD&apos; == ctx.method) &#123;</span><br><span class="line">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span><br><span class="line">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span><br><span class="line">    &#125;</span><br><span class="line">    return res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //body为空的情况，那就把body设为message或者code，并修改头部的type和length</span><br><span class="line">  if (null == body) &#123;</span><br><span class="line">    body = ctx.message || String(code);</span><br><span class="line">    if (!res.headersSent) &#123;</span><br><span class="line">      ctx.type = &apos;text&apos;;</span><br><span class="line">      ctx.length = Buffer.byteLength(body);</span><br><span class="line">    &#125;</span><br><span class="line">    return res.end(body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //分别针对buffer，字符串，stream类型作相应的反应</span><br><span class="line">  if (Buffer.isBuffer(body)) return res.end(body);</span><br><span class="line">  if (&apos;string&apos; == typeof body) return res.end(body);</span><br><span class="line">  if (body instanceof Stream) return body.pipe(res);</span><br><span class="line"></span><br><span class="line">  //对 body 为 json 格式的数据进行处理</span><br><span class="line">  body = JSON.stringify(body);</span><br><span class="line">  if (!res.headersSent) &#123;</span><br><span class="line">    ctx.length = Buffer.byteLength(body);</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="context-js"><a href="#context-js" class="headerlink" title="context.js"></a>context.js</h3><p>context主要做的就是：</p><ol><li><p>将 request, response对象上的属性方法代理到 context 对象上。也就是说例如 this.ctx.headersSent 相当于 this.response.headersSent。request对象与response对象的所有方法与属性都能在 ctx 对象上找到。</p></li><li><p>对在中间函数数组生成的 Promise 的 catch 中与 res 对象的 onFinished 函数的回调的错误进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">onerror(err) &#123;</span><br><span class="line">    if (null == err) return;</span><br><span class="line">    // 将错误转化为 Error 实例</span><br><span class="line">    if (!(err instanceof Error)) err = new Error(util.format(&apos;non-error thrown: %j&apos;, err));</span><br><span class="line"></span><br><span class="line">    let headerSent = false;</span><br><span class="line">    if (this.headerSent || !this.writable) &#123;</span><br><span class="line">      headerSent = err.headerSent = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 触发 koa 实例对象的 error 事件, application 上的 onerror 函数会执行</span><br><span class="line">    this.app.emit(&apos;error&apos;, err, this);</span><br><span class="line">    // 如果响应头部已经发送(或者 socket 不可写)则返回</span><br><span class="line">    if (headerSent) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const &#123; res &#125; = this;</span><br><span class="line">    // 如果出错那么之前中间件或者其他地方设置的 HTTP 头部就无效了, 应该清空设置</span><br><span class="line">    if (typeof res.getHeaderNames === &apos;function&apos;) &#123;</span><br><span class="line">      res.getHeaderNames().forEach(name =&gt; res.removeHeader(name));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res._headers = &#123;&#125;; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.set(err.headers);</span><br><span class="line">    // 出错后响应类型为 text/plain</span><br><span class="line">    this.type = &apos;text&apos;;</span><br><span class="line">    </span><br><span class="line">    // 对 ENOENT 错误进行处理, ENOENT 的错误 message 是文件或者路径不存在, 所以状态码应该是 404</span><br><span class="line">    if (&apos;ENOENT&apos; == err.code) err.status = 404;</span><br><span class="line">    // 默认设置状态码为 500</span><br><span class="line">    if (&apos;number&apos; != typeof err.status || !statuses[err.status]) err.status = 500;</span><br><span class="line"></span><br><span class="line">    const code = statuses[err.status];</span><br><span class="line">    const msg = err.expose ? err.message : code;</span><br><span class="line">    this.status = err.status;</span><br><span class="line">    this.length = Buffer.byteLength(msg);</span><br><span class="line">    this.res.end(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="request-js-和-response-js"><a href="#request-js-和-response-js" class="headerlink" title="request.js 和 response.js"></a>request.js 和 response.js</h3><p><code>request.js</code>和<code>response.js</code>主要是对原生的http模块的requets和response对象进行封装, 其实就是对request和response对象某些属性或方法通过重写<code>getter/setter</code>函数进行代理。<br>因为重写封装的比较多，所以具体的也不多说了，有兴趣可以看看源码：<br><a href="https://github.com/koajs/koa/blob/master/lib/request.js" target="_blank" rel="noopener">koa的request.js</a><br><a href="https://github.com/koajs/koa/blob/master/lib/response.js" target="_blank" rel="noopener">koa的response.js</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;读读Koa2源码&quot;&gt;&lt;a href=&quot;#读读Koa2源码&quot; class=&quot;headerlink&quot; title=&quot;读读Koa2源码&quot;&gt;&lt;/a&gt;读读Koa2源码&lt;/h2&gt;&lt;p&gt;本人因为一直用的都是Koa2作为nodejs的开发框架，所以也对Koa2的原理产生了兴趣。于
      
    
    </summary>
    
      <category term="nodejs" scheme="http://yoursite.com/categories/nodejs/"/>
    
    
      <category term="Koa2" scheme="http://yoursite.com/tags/Koa2/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端数据流管理方案（五）——Rxjs篇</title>
    <link href="http://yoursite.com/2018/05/28/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94Rxjs%E7%AF%87/"/>
    <id>http://yoursite.com/2018/05/28/浅谈前端数据流管理方案（五）——Rxjs篇/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2018-09-11T05:59:57.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rxjs"><a href="#Rxjs" class="headerlink" title="Rxjs"></a>Rxjs</h2><p>下面我们来说说第三个流派，响应式observable流式流派。代表库有RXJS，它是Observable的Javascript实现，是一个强大的Reactive编程（面向数据流和变化传播的编程范式）库，提供了强大的数据流组合与控制能力。</p><p>它给人最直观的感觉就是通过链式操作让数据流动起来，把观察者模式和迭代器模式结合起来：数据源有变化的话就通知下游，通知的方式则是采用了迭代器中的next思想。它通常不会有取值这个操作，因为它是push-based的，下游obsever被动接受observable传来的数据。</p><hr><h3 id="Rxjs擅长做什么？"><a href="#Rxjs擅长做什么？" class="headerlink" title="Rxjs擅长做什么？"></a>Rxjs擅长做什么？</h3><ol><li>同步和异步的“和谐共处”。它把用于实现某一功能的同步异步方法按一定顺序组合到一起，使得两者执行起来有条不紊。</li><li>可组合的数据变更过程。当多个复杂的异步或者事件组合到一起的时候，它能够按一定顺序去处理多个数据序列。</li><li>数据和视图的精确绑定。在observable中可以把DOM事件作为数据源，而在observer中也可以执行更新视图的操作。</li><li>在操作时间轴方面得心应手。Rxjs提供的几个操作时间轴的Operator（delay,timeout,throttle,debounce,audit,bufferTime等等）使得我们对同步异步的处理更加随心所欲。</li><li>在多个服务端实时消息流的应用场景中，我们可以把数据源通过 Rx 进行高阶处理，最后到 view 层就是很清晰的一个 Observable。</li></ol><hr><h3 id="Rxjs的几个角色"><a href="#Rxjs的几个角色" class="headerlink" title="Rxjs的几个角色"></a>Rxjs的几个角色</h3><p>我们先通过Rxjs的几个角色，几种概念来去认识它。</p><h4 id="Observable-被观察者，管道入口"><a href="#Observable-被观察者，管道入口" class="headerlink" title="Observable 被观察者，管道入口"></a>Observable 被观察者，管道入口</h4><p>它是一个数据或事件的流的集合，就像一个序列，里面的数据源会按顺序依次推送到下游，也可以同时处理同步和异步的操作。<br>虽然它跟观察者模式的observable名字一样，但是具体上还是有所区别：这里的observable没有一份需要维护的订阅者的列表，它只是一个函数，如果你想要订阅它的话，只需要通过subscribe()把observer传进回调函数就好了。<br>创建observable的方式：</p><ul><li>单值：of，empty，never</li><li>多值：from</li><li>定时：interval，timer</li><li>事件：fromEvent</li><li>promise：fromPromise</li><li>自定义：create</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var observable = Rx.Observable</span><br><span class="line">// 通过create方法创建一个Observable</span><br><span class="line">// 回调函数会接受observer参数，也就是观察者角色</span><br><span class="line">    .create(function(observer) &#123;</span><br><span class="line">        observer.next(&apos;hi&apos;);</span><br><span class="line">        observer.next(&apos;world&apos;);</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            observer.next(&apos;这一段是异步操作&apos;);</span><br><span class="line">        &#125;, 30)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">// 订阅这个 observable</span><br><span class="line">// 只有在订阅之后，才会在流Observable变化的时候，调用observer提供的方法，并通知他 </span><br><span class="line">// 订阅之后也可以取消订阅，调用unsubscribe()即可</span><br><span class="line">console.log(&apos;start&apos;)</span><br><span class="line">var subscription = observable.subscribe(function(value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;end&apos;)</span><br><span class="line">setTimeOut(()=&gt; &#123;</span><br><span class="line">  subscription.unsubscribe()</span><br><span class="line">&#125;, 5000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 程序会依次输出</span><br><span class="line">&apos;start&apos;</span><br><span class="line">&quot;hi&quot;</span><br><span class="line">&apos;world&apos;</span><br><span class="line">&apos;end&apos;</span><br><span class="line">&apos;这一段是异步操作&apos;</span><br></pre></td></tr></table></figure></p><p>Rx 中的 Observable 对象默认是 lazy 且 cold 的，lazy 说的是如果 Observable 对象的 subscribe 方法没有被调用，那么 Producer 函数也就不会被调用。cold 是说每调用一次 subscribe 方法，就会执行一次 Producer 来产生一个新的 Subscription 流，也就是不同的 Subscription 流内的状态不会相互影响。（ps：它也可以是hot的，调用share这个API来实现）<br>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let interval = Rx.Observable.create(observer =&gt; &#123; </span><br><span class="line">setInterval(() =&gt; observer.next(), 1000) </span><br><span class="line">&#125;).scan(x =&gt; x+1, 0); //累加器，从 0 开始，类似在内部定义了一个count，然后每次count++ </span><br><span class="line">// 1, 2, 3... </span><br><span class="line">interval.subscribe(count =&gt; console.log(&apos;count1:&apos;+count)); </span><br><span class="line">setTimeout(() =&gt; &#123; </span><br><span class="line">// 3s 后监听，同样得到 1, 2, 3... 而不是 4, 5, 6..</span><br><span class="line">interval.subscribe(count =&gt; console.log(&apos;count2:&apos;+count)); </span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure></p><h4 id="Operator-对数据流的操作器"><a href="#Operator-对数据流的操作器" class="headerlink" title="Operator 对数据流的操作器"></a>Operator 对数据流的操作器</h4><p>可以用来对observable进行各种各样的操作。接受传进来的observable，通过操作后返回新的observable（这有点像immutable）。<br>操作符：</p><ul><li>改变数据值：map，mapTo</li><li>过滤：filter，skip，first，last，take</li><li>操作时间轴：delay，timeout，throttle，debounce，audit，bufferTime</li><li>累加：scan</li><li>异常处理：throw，catch</li><li>条件执行：takeUntil，delayWhen，observeOn</li><li>多个数据的合并操作：concat，merge，combineLatest，withLatestFrom，zip</li></ul><h4 id="Scheduler-控制Observable订阅开始执行和数据送达的时机"><a href="#Scheduler-控制Observable订阅开始执行和数据送达的时机" class="headerlink" title="Scheduler 控制Observable订阅开始执行和数据送达的时机"></a>Scheduler 控制Observable订阅开始执行和数据送达的时机</h4><p>一般有这么几种Scheduler：</p><ul><li>queue：把递归阻塞。</li><li>asap：as soon as possible，表现形式为setTimeout(()=&gt;{},0)。多用于永不退订的observable，例如轮询。</li><li>async：使observable执行方式变为异步。</li><li>animationFrame：适合高频率UI动画触发，用requestAnimationFrame实现的。<br>使用例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var observable = Rx.Observable.create(function (observer) &#123;</span><br><span class="line">    observer.next(1);</span><br><span class="line">    observer.next(2);</span><br><span class="line">    observer.next(3);</span><br><span class="line">    observer.complete();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;before subscribe&apos;);</span><br><span class="line">observable.observeOn(Rx.Scheduler.async) // 本来是同步的，变成了异步</span><br><span class="line">.subscribe(&#123;</span><br><span class="line">    next: (value) =&gt; &#123; console.log(value); &#125;,</span><br><span class="line">    error: (err) =&gt; &#123; console.log(&apos;Error: &apos; + err); &#125;,</span><br><span class="line">    complete: () =&gt; &#123; console.log(&apos;complete&apos;); &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;after subscribe&apos;);</span><br><span class="line"></span><br><span class="line">// &quot;before subscribe&quot;</span><br><span class="line">// &quot;after subscribe&quot;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// &quot;complete&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Subject-数据流管道的分岔接口，可进可出"><a href="#Subject-数据流管道的分岔接口，可进可出" class="headerlink" title="Subject 数据流管道的分岔接口，可进可出"></a>Subject 数据流管道的分岔接口，可进可出</h4><p>Subject可以向多个observer多路推送数据。每个subject既可以是一个observerable，也可以是一个observer。subject内部有一份它下游的observer的列表，在接收到上游传过来的值时，就会遍历这份列表并把值传递下去。<br>普通的subject:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个Observable，一秒钟输出一个数字，只取三个就结束</span><br><span class="line">var source = Rx.Observable.interval(1000).take(3);</span><br><span class="line"></span><br><span class="line">// 定义两个observer对象</span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个subject —— 特殊的Observable</span><br><span class="line">var subject = new Rx.Subject()</span><br><span class="line"></span><br><span class="line">// observerA订阅Subject</span><br><span class="line">subject.subscribe(observerA)</span><br><span class="line"></span><br><span class="line">// Subject又以observer的身份订阅Observable</span><br><span class="line">source.subscribe(subject);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subject.subscribe(observerB);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// &quot;A next: 0&quot;</span><br><span class="line">// &quot;A next: 1&quot;</span><br><span class="line">// &quot;B next: 1&quot;</span><br><span class="line">// &quot;A next: 2&quot;</span><br><span class="line">// &quot;B next: 2&quot;</span><br><span class="line">// &quot;A complete!&quot;</span><br><span class="line">// &quot;B complete!&quot;</span><br><span class="line"> A、B两个observer互不影响，是独立的</span><br></pre></td></tr></table></figure></p><p>除了基本的subject外，它还有这么几种类型：</p><ol><li><p>BehaviorSubject：初始化的时候传入一个参数作为当前值，执行过后它会把最新的值记住，作为当前值，因此它是有状态的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// BehaviorSubject 在建立时就需要给定一个状态，并在之后任何一次订阅，就会先送出最新的状态。其实这种行为就是一种状态的表达而非单存的事件，就像是年龄跟生日一样，年龄是一种状态而生日就是事件；所以当我们想要用一个stream 来表达年龄时，就应该用BehaviorSubject 。</span><br><span class="line"></span><br><span class="line">var subject = new Rx.BehaviorSubject(0); // 0</span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.subscribe(observerA);</span><br><span class="line">// &quot;A next: 0&quot;</span><br><span class="line">subject.next(1);</span><br><span class="line">// &quot;A next: 1&quot;</span><br><span class="line">subject.next(2);</span><br><span class="line">// &quot;A next: 2&quot;</span><br><span class="line">subject.next(3);</span><br><span class="line">// &quot;A next: 3&quot;</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subject.subscribe(observerB); </span><br><span class="line">    // &quot;B next: 3&quot;</span><br><span class="line">&#125;,3000)</span><br></pre></td></tr></table></figure></li><li><p>ReplaySubject：在有新订阅时，重新发送最后的n个值，n是你传进来的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.ReplaySubject(2); // 重复发送最后俩个元素</span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.subscribe(observerA);</span><br><span class="line">subject.next(1);</span><br><span class="line">// &quot;A next: 1&quot;</span><br><span class="line">subject.next(2);</span><br><span class="line">// &quot;A next: 2&quot;</span><br><span class="line">subject.next(3);</span><br><span class="line">// &quot;A next: 3&quot;</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subject.subscribe(observerB);</span><br><span class="line">    // &quot;B next: 2&quot;</span><br><span class="line">    // &quot;B next: 3&quot;</span><br><span class="line">&#125;,3000)</span><br></pre></td></tr></table></figure></li><li><p>AsyncSubject：它会一直等等到complete后才会传值，传递最后一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.AsyncSubject();</span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.subscribe(observerA);</span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">subject.next(3);</span><br><span class="line">subject.complete();</span><br><span class="line">// &quot;A next: 3&quot;</span><br><span class="line">// &quot;A complete!&quot;</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subject.subscribe(observerB);</span><br><span class="line">    // &quot;B next: 3&quot;</span><br><span class="line">    // &quot;B complete!&quot;</span><br><span class="line">&#125;,3000)</span><br></pre></td></tr></table></figure></li></ol><h4 id="Observer-观察者，只进不出"><a href="#Observer-观察者，只进不出" class="headerlink" title="Observer 观察者，只进不出"></a>Observer 观察者，只进不出</h4><p>接受上游数据，并作出相应的反应。它的表现形式与迭代器模式相对应，形如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var observer = &#123;</span><br><span class="line">    next:function(value)&#123;&#125;, //接收到observable的数据时触发</span><br><span class="line">    error:function(err)&#123;&#125;,  //接收到错误时触发</span><br><span class="line">    complete:function()&#123;&#125;   //执行完毕的时候触发(处理完所有的next后)，complete一旦执行后，next就不会再执行了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="Rxjs流程图"><a href="#Rxjs流程图" class="headerlink" title="Rxjs流程图"></a>Rxjs流程图</h3><p><img src="https://user-gold-cdn.xitu.io/2017/8/1/e66826df704255809a7e9477996d60d7?imageslim" alt="Rxjs"></p><hr><h3 id="Observable和Promise的区别"><a href="#Observable和Promise的区别" class="headerlink" title="Observable和Promise的区别"></a>Observable和Promise的区别</h3><p>它们都可以用于对副作用进行归一化，但加以比较的话，使用 rxjs 来做更为适合。<br>首先事件机制与 rxjs 很像，另外 promise 只能返回一次，而且之后 resolve reject 两种状态，而 Observable 可以返回多次，而且没有内置的状态，所以可以更加灵活的表示状态。<br>我们可以把Observable看成是一个有可变数据量的Promise，而Promise只能处理一个数据。<br>在分发和联动关系多的时候，Rxjs才能够体现出它比起Promise,Generator的优势。<br>ps：这样可以把observable转化成promise：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const promise = observable.toPromise();</span><br></pre></td></tr></table></figure></p><hr><h3 id="Rxjs实际使用"><a href="#Rxjs实际使用" class="headerlink" title="Rxjs实际使用"></a>Rxjs实际使用</h3><p><strong>示例1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Observable = Rx.Observable  </span><br><span class="line">const input = document.querySelector(&apos;input&apos;)</span><br><span class="line"></span><br><span class="line">const search$ = Observable.fromEvent(input, &apos;input&apos;)  </span><br><span class="line">  .map(e =&gt; e.target.value)</span><br><span class="line">  .filter(value =&gt; value.length &gt;= 1)</span><br><span class="line">  .throttleTime(100)</span><br><span class="line">  .distinctUntilChanged()</span><br><span class="line">  .switchMap(term =&gt; Observable.fromPromise(wikiIt(term)))</span><br><span class="line">  .subscribe(</span><br><span class="line">    x =&gt; renderSearchResult(x),</span><br><span class="line">    err =&gt; console.error(err)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p><p>上面的代码做了以下事情：</p><p>监听 input 元素的 input 事件<br>一旦发生，把事件对象 e 映射成 input 元素的值<br>接着过滤掉值长度小于 1 的<br>并且还设置了一个 throttle ( 节流器 )，两次输入间隔不超过 100 毫秒为有效输入<br>如果该值和过去最新的值相等的话，忽略他<br>最后，拿到值便调用 Wikipedia 的一个 API<br>最后的最后，需要 subscribe 才能拿到 API 返回的数据</p><p><strong>示例2（拖拽）：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var box = document.getElementById(&apos;box&apos;);</span><br><span class="line"></span><br><span class="line">var scroll = Rx.Observable.fromEvent(document, &apos;scroll&apos;);</span><br><span class="line">var mouseDown = Rx.Observable.fromEvent(box, &apos;mousedown&apos;)</span><br><span class="line">var mouseUp = Rx.Observable.fromEvent(document, &apos;mouseup&apos;)</span><br><span class="line">var mouseMove = Rx.Observable.fromEvent(document, &apos;mousemove&apos;)</span><br><span class="line"></span><br><span class="line">var validValue = (value, max, min) =&gt; &#123;</span><br><span class="line">    return Math.min(Math.max(value, min), max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mouseDown</span><br><span class="line">    .map(e =&gt; mouseMove.takeUntil(mouseUp))</span><br><span class="line">    .concatAll()</span><br><span class="line">//   完整版拖拽</span><br><span class="line">//     .withLatestFrom(mouseDown, (move, down) =&gt; &#123;</span><br><span class="line">//         return &#123;</span><br><span class="line">//             x: validValue(move.clientX - down.offsetX, window.innerWidth - 320, 0),</span><br><span class="line">//             y: validValue(move.clientY - down.offsetY, window.innerHeight - 180, 0)</span><br><span class="line">//         &#125;</span><br><span class="line">//     &#125;)</span><br><span class="line">//  简单版拖拽</span><br><span class="line">    .map(event =&gt; (&#123; x: event.clientX, y: event.clientY &#125;))</span><br><span class="line">    .subscribe(pos =&gt; &#123;</span><br><span class="line">        box.style.top = pos.y + &apos;px&apos;;</span><br><span class="line">        box.style.left = pos.x + &apos;px&apos;;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p><strong>示例3（实时获取时间。如果某个用户停留在某个页面时间太长，评论上的时间信息会变得不准确，比如说，用户停留了一个小时，而它看到的信息还显示：5分钟之前发表了评论，实际时间是一个小时零5分钟以前的事了。）：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(1000).subscribe(() =&gt; &#123;</span><br><span class="line">  this.diff = moment(createAt).fromNow()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><hr><h3 id="结合Vue，Redux的使用"><a href="#结合Vue，Redux的使用" class="headerlink" title="结合Vue，Redux的使用"></a>结合Vue，Redux的使用</h3><p>在 React/Vue 应用中部分使用 Rx 是完全没有问题的。思路上来说就是把 React/Vue 组件的 local state 当做一个『中介』，在一个 Rx Observable 的 subscribe 回调里面更新组件状态。通过简单的绑定库支持，可以完全把 component state 作为一个实现细节封装掉，实现 Observable -&gt; view 的声明式绑定。</p><h4 id="结合Vue"><a href="#结合Vue" class="headerlink" title="结合Vue"></a>结合Vue</h4><p>比如我们可以在created时初始化一个observable，beforeDestroy时取消订阅observable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  </span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    time: &apos;&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    this.timer$ = Rx.Observable.interval(1000)</span><br><span class="line">      .map(() =&gt; new Date())</span><br><span class="line">      .map(d =&gt; moment(d).format(&apos;hh:mm:ss&apos;))</span><br><span class="line">      .subscribe(t =&gt; &#123;</span><br><span class="line">        this.time = t</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    this.timer$.unsubscribe()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="结合Redux"><a href="#结合Redux" class="headerlink" title="结合Redux"></a>结合Redux</h4><p>可以通过redux-observable这个库来配合Redux。（下文会提到这个库）</p><hr><h3 id="Redux中间件redux-observable"><a href="#Redux中间件redux-observable" class="headerlink" title="Redux中间件redux-observable"></a>Redux中间件redux-observable</h3><p>Rxjs带来了两种新的开发方式，第一种是将一切前端副作用转化为数据源，因此副作用已经在数据源转换这一层完全隔离了，然后通过纯函数的操作，最后直接对接到 dom。另一种是类似 redux-observable，将 rxjs 数据流处理能力融合到已有数据流框架中。</p><p>redux-observable 将 action 与 reducer 改造为 stream 模式，对 action 中副作用行为，比如发请求，也提供了封装好的函数转化为数据源，因此，将 redux middleware 中的副作用，转移到了数据源转换，让 action 保持纯函数，同时增强了原本就是纯函数的 reducer 的数据处理能力。</p><p>如果说 redux-saga 解决了异步，那么 redux-observable 就是解决了副作用，同时赠送了 Rxjs 数据处理能力。</p><p>来看看它是怎么用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 定义两个action creator</span><br><span class="line">// 1. 拉取某用户数据</span><br><span class="line">const fetchUser = username =&gt; (&#123; type: &apos;GET_DATA&apos;, target: username &#125;);</span><br><span class="line">// 2. 拉取完成</span><br><span class="line">const fetchUserDone = data =&gt; (&#123; type: &apos;GET_SUCCESS&apos;, data&#125;);</span><br><span class="line"></span><br><span class="line">// 定义一个Epics函数</span><br><span class="line">const fetchEpics = (action$) =&gt; &#123;</span><br><span class="line">        return action$.ofType(&apos;GET_DATA&apos;)</span><br><span class="line">                      .mergeMap((action)=&gt;&#123;</span><br><span class="line">                          return ajax.getJson(`/api/users/$&#123;action.target&#125;`)</span><br><span class="line">                      &#125;)</span><br><span class="line">                      .map((data)=&gt;&#123;</span><br><span class="line">                          fetchUserDone(data)</span><br><span class="line">                      &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="Rxjs跟Redux的对比"><a href="#Rxjs跟Redux的对比" class="headerlink" title="Rxjs跟Redux的对比"></a>Rxjs跟Redux的对比</h3><p>基于Flux实现的方案中一个很大的痛点就是它的繁琐，造成它繁琐的原因就是它的自定义action，<br>如果不从根本上对事件这种机制进行抽象，就不可能彻底解决繁琐的问题。</p><p>基于Reactive理念的库天然就是为了处理对事件机制的抽象而出现的，所以用在这种场景下有奇效，它能把action的派发与处理过程描述得优雅精妙。在这样的机制里，我们可以很清楚地看到一块数据的来龙去脉，它最初是哪里来的，后来可能会被谁修改过。所有这样的数据都放置在管道中，除了指定的入口，不会有其他东西能够修改这些数据，视图可以很安全地订阅他们。</p><ol><li><p>数据转换逻辑。打个比方，同样是表达数据a到b这么一个转换，两者所关注的点可能是不一样的：<br>Redux：定义一个action叫做AtoB，在其实现中，把a转换成b。<br>Rx：定义两个数据流A和B，B是从A经过一次map转换得到的，map的表达式是把a转成b。</p></li><li><p>数据处理逻辑。在数据变更的链路较长时，Rx是具有很大优势的，它可以很简便地做多级状态变更的连接，也可以做数据变更链路的复用（比如存在a -&gt; b -&gt; c，又存在a -&gt; b -&gt; d，可以把a -&gt; b这个过程拿出来复用），还天生能处理好包括竞态在内的各种异步的情况，Redux可能要借助saga等理念才能更好地组织代码。</p></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过了这个系列文章的学习后，我们发现，Redux和Rxjs完全隔离了副作用，是因为他们有一个共性，那就是对前端副作用的抽象。redux 通过在 action 做副作用，将副作用隔离在 reducer 之外，使reducer成为了纯函数。rxjs将副作用先转化为数据源，将副作用隔离在管道流处理之外。<br>唯独 mobx，缺少了对副作用抽象这一层，所以导致了代码写的比redux和rxjs更爽，但副作用与纯函数混杂在一起，因此与函数式无缘。</p><p>综上，我们可以看出，现代前端数据流流动过程分为以下几个部分：<br>更新触发 -&gt; 副作用隔离 -&gt; 数据状态变更 -&gt; 视图渲染</p><ul><li>更新触发往往是视图层发送一个指令来传达某个状态需要改变。</li><li>副作用隔离就是把一切与数据本身修改无关的指令通通隔离，使得数据变更的这一过程变得“纯净”。</li><li>数据状态变更就是修改值，修改最新状态，在这里也有immutable和mutable之分。</li><li>视图渲染就是状态数据更新完成后到通知视图更新数据，再到经过virtualDom,diff等优化操作后将数据映射到视图上的过程。</li></ul><p>写到这里，前端数据流管理方案系列也告一段落了，从对这三者在特点、流程、角色上的学习也着实能感受到数据流的严谨、科学之处，数据流管理模式的探索肯定不会就此停滞，期待未来数据流管理的发展。</p><p>总而言之，数据状态管理没有银弹，不论黑猫白猫，抓到老鼠的才是好猫。(●’◡’●)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Rxjs&quot;&gt;&lt;a href=&quot;#Rxjs&quot; class=&quot;headerlink&quot; title=&quot;Rxjs&quot;&gt;&lt;/a&gt;Rxjs&lt;/h2&gt;&lt;p&gt;下面我们来说说第三个流派，响应式observable流式流派。代表库有RXJS，它是Observable的Javascrip
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="前端数据流" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
      <category term="Rxjs" scheme="http://yoursite.com/tags/Rxjs/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端数据流管理方案（四）——Redux篇</title>
    <link href="http://yoursite.com/2018/05/17/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Redux%E7%AF%87/"/>
    <id>http://yoursite.com/2018/05/17/浅谈前端数据流管理方案（四）——Redux篇/</id>
    <published>2018-05-16T16:00:00.000Z</published>
    <updated>2018-09-11T05:59:49.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理，属于Flux模式的具体实现之一，核心理念是在初始状态上依次叠加后续的变更，所得的就是当前的状态。</p><hr><h3 id="Redux各部分职能"><a href="#Redux各部分职能" class="headerlink" title="Redux各部分职能"></a>Redux各部分职能</h3><p>先来了解一下Redux的主要组成部分：</p><ul><li><p>Action：触发改变store中的state的唯一方法，它通过store.dispatch来将action传到store中。</p></li><li><p>Reducer：action只是描述事件的简单对象，而reducer会说明怎么更新state。reducer是一个纯函数：（(prevState,action)=&gt;newState）。因此你不能在reducer中执行这些操作：修改传入的参数；执行有副作用的操作；调用非纯函数（如Date.now(),Math.random()等等）。</p></li><li><p>Store：存放整个应用的state，并将action和reducer联系起来。store可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。Redux应用只有一个单一的store。当需要拆分数据处理逻辑时，你应该使用 reducer 组合而不是创建多个 store。它提供了以下四个方法：</p><ol><li>dispatch:用于action的分发。在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。</li><li>subscribe：监听state的变化。这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。 let unsubscribe = store.subscribe(() =&gt; {console.log(‘state发生了变化’)})</li><li>getState：获取store中的state。当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。</li><li>replaceReducer:替换reducer，改变state修改的逻辑。</li></ol></li><li><p>View：触发action以改变state，以及接收state数据以渲染界面。以react视图层为例，react通过react-redux把store绑定到视图上。</p></li></ul><hr><h3 id="Redux流程"><a href="#Redux流程" class="headerlink" title="Redux流程"></a>Redux流程</h3><p>那么这几个部分是怎么串联起来，相互配合，实现单向数据流的呢？</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg" alt="Redux流程示意图"></p><p><strong>一、初始化</strong></p><ol><li>创建好store。根reducer通过combineReducers()合并了reducers，然后作为参数传入createStore()中，生成唯一的store。</li><li>建立store与组件间的通信。通过Provider组件建立联系，Provider实质上是创建了一个用于更新视图的网络，智能组件通过connect()连入网络，以获取state更新。</li><li>在组件中准备好action的回调函数。 为了让木偶组件更容易处理动作，智能组件可以使用bindActionCreators()来设置action回调函数。 这样，他们可以将回调函数传递给木偶组件。</li></ol><p><strong>二、触发数据流</strong></p><ol><li>视图发出一个action，actionCreator将它格式化并返回它。</li><li>这个action要么被自动dispatch（使用了bindActionCreators()），要么由view手动dispatch。</li><li>store接收到这个action后，将当前的状态树和action传给了根reducer。</li><li>根reducer将整个状态树分割成一个个小块，然后将某个小块分发给知道该怎么处理这部分内容的子reducer。</li><li>子reducer将传入的一小块状态树进行拷贝，然后在这个副本上进行修改，最终将修改后的副本返回给根reducer。</li><li>根reducer将子reducer返回过来的部分再次组合成一棵新的状态树，然后把它交给store，store就会把当前的状态置为这棵最新的状态树。</li><li>store告诉view状态更新了，view让store把更新的状态传过去，之后view触发rerender进行重新渲染。</li></ol><hr><h3 id="Redux三大原则"><a href="#Redux三大原则" class="headerlink" title="Redux三大原则"></a>Redux三大原则</h3><p>Redux有三大基本原则：</p><ul><li>单一数据源：整个应用的状态state都是存储在一棵树上，并且这棵状态树只存在于唯一一个store中。</li><li>state是只读的：对state的修改的唯一做法是触发action，不能直接修改state。</li><li>用纯函数执行修改：reducer根据旧状态和传进来的action来生成一个新的state，不直接修改state。<br>（ps：纯函数是什么？<br>纯函数就是有相同输入值时只会产生相同的输出的函数，而且纯函数中不包含任何产生副作用的语句。）</li></ul><hr><h3 id="Redux处理异步的中间件"><a href="#Redux处理异步的中间件" class="headerlink" title="Redux处理异步的中间件"></a>Redux处理异步的中间件</h3><p>Redux针对异步数据流的情况，也设计出中间件这个概念来隔离异步所带来的副作用。它的主要目的就是控制异步dispatch，分离副作用。</p><p>接下来说说最具代表性的两个异步中间件：redux-thunk 和 redux-saga。</p><h4 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h4><p>它是一个dispatch的改造者，先来看看它是怎么用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async function getUserName(dispatch, getState, id) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        const user = await axios.get(`xxxx`);</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: &apos;GETUSERNAME_SUCCESS&apos;,</span><br><span class="line">            data: name</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: &apos;GETUSERNAME_FAILED&apos;,</span><br><span class="line">            error: err</span><br><span class="line">        &#125;);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch(getUserName);</span><br></pre></td></tr></table></figure></p><p>redux-thunk把dispatch改造成可以接受一个函数作为参数。这个函数往往就是我们定义的一个异步处理函数。如上例，我们在里面发起了一个异步的网络请求，当有数据返回的时候，就会执行成功或失败所对应的dispatch（这个dispatch就是我们平常用的dispatch），同步提交action。</p><p>接下来看看它的源码。<br>redux-thunk的源码只有短短的11行，对，你没看错，就是11行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createThunkMiddleware(extraArgument) &#123;</span><br><span class="line">  return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">    if (typeof action === &apos;function&apos;) &#123;</span><br><span class="line">      return action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line">    return next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line">export default thunk;</span><br></pre></td></tr></table></figure></p><p>这个中间件做的工作主要是判断传进来的参数是不是一个函数，是的话就执行传进来的函数（正常来说dispatch里面传的是一个plainObject，也就是一个action，但是redux-thunk使得dispatch里能传一个函数，这个函数就是包含异步处理逻辑的函数），不是的话交给下一个中间件处理。</p><h4 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h4><p>它是redux的集中处理副作用的异步处理中间件，被实现为generator，以监听=&gt;执行的工作形式来运行。</p><p><img src="https://wx4.sinaimg.cn/mw690/768c39d5gy1fqvrrtolovj20tw09tq4f.jpg" alt="redux-saga流程"></p><p>按照惯例，先说说redux-saga是怎么用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//1.put:相当于redux的dispatch</span><br><span class="line">yield put(&#123;type:&apos;LOGIN&apos;&#125;); </span><br><span class="line"></span><br><span class="line">//2.select:相当于redux的getState</span><br><span class="line">const name = yield select(state=&gt;state.name);</span><br><span class="line"></span><br><span class="line">//3.take:监听action，当GETNAME这个action被触发才会往下执行（参数也可以是*，代表所有action）</span><br><span class="line">while(true)&#123;</span><br><span class="line">    yield take(&apos;GETNAME&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//4.takeEvery:一直监听action，takeEvery 是每次 action 触发的时候都响应，而 take 则是执行流执行到 take 语句时才响应。</span><br><span class="line">yield takeEvery(&apos;*&apos;,function* logger(action)&#123;</span><br><span class="line">    console.log(action)</span><br><span class="line">&#125;);</span><br><span class="line">//takeEvery的模拟实现</span><br><span class="line">function* takeEvery(pattern, saga, ...args) &#123;</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    const action = yield take(pattern)</span><br><span class="line">    yield fork(saga, ...args.concat(action))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//5.call:阻塞型调用，一般用于获取网络请求数据</span><br><span class="line">const members = yield call(fetchMembers, project.id);</span><br><span class="line">//并行发起请求</span><br><span class="line">const [users, products] = yield [</span><br><span class="line">  call(fetch, &apos;/users&apos;),</span><br><span class="line">  call(fetch, &apos;/products&apos;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//6.fork:非阻塞型调用</span><br><span class="line">const countTaskId = yield fork(count, number);</span><br></pre></td></tr></table></figure></p><p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export function* loginSaga() &#123;</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    const &#123; user, pass &#125; = yield take(LOGIN_REQUEST) //等待 Store 上指定的 action LOGIN_REQUEST</span><br><span class="line">    try &#123;</span><br><span class="line">      let &#123; data &#125; = yield call(loginRequest, &#123; user, pass &#125;); //阻塞，请求后台数据</span><br><span class="line">      yield fork(loadUserData, data.uid); //非阻塞执行loadUserData</span><br><span class="line">      yield put(&#123; type: LOGIN_SUCCESS, data &#125;); //发起一个action，类似于dispatch</span><br><span class="line">    &#125; catch(error) &#123;</span><br><span class="line">      yield put(&#123; type: LOGIN_ERROR, error &#125;);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function* loadUserData(uid) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield put(&#123; type: USERDATA_REQUEST &#125;);</span><br><span class="line">    let &#123; data &#125; = yield call(userRequest, `/users/$&#123;uid&#125;`);</span><br><span class="line">    yield put(&#123; type: USERDATA_SUCCESS, data &#125;);</span><br><span class="line">  &#125; catch(error) &#123;</span><br><span class="line">    yield put(&#123; type: USERDATA_ERROR, error &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以把redux-saga理解为启动了一个“监听线程”，这个线程处理的输入是action，输出也是action，中间的逻辑就可以自己自由处理了。是在action和reducer之外的一层逻辑，使用saga会保持action的简单。</p><p>比起redux-thunk有这么几个优点：</p><ol><li>生命周期有所不同，redux-saga 可以理解成一直运行于后台的“LLT”（长时事务），而 redux-thunk 是一个 action，因而 redux-saga 能做的事情更多。</li><li>比起thunk，saga提供了更多的流程控制能力。redux-saga 有诸多常用并且声明式易测的 Effects，比如它可以无阻塞地调用一个 generator（fork）、中断一个generator（cancel）。这些特性在业务逻辑复杂的场景下非常适用。</li><li>redux-saga 最具魅力的地方，是它保持了 action 的原义，保持 action 的简洁，把所有有副作用的地方独立开来。dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满 “黑魔法” thunk function。这种特性让 redux-saga 在业务逻辑简单的场景下，也能保持代码清晰简洁，也就是说 redux-saga 的适用性较为普遍。</li></ol><h4 id="redux-observable"><a href="#redux-observable" class="headerlink" title="redux-observable"></a>redux-observable</h4><p>在《浅谈前端数据流管理方案（五）——Rxjs篇》有提到，这里先不说。</p><hr><h3 id="连接React和Redux的桥梁：React-Redux"><a href="#连接React和Redux的桥梁：React-Redux" class="headerlink" title="连接React和Redux的桥梁：React-Redux"></a>连接React和Redux的桥梁：React-Redux</h3><p><img src="https://raw.githubusercontent.com/bailicangdu/react-pxq/master/screenshot/all_redux.png" alt="redux配合react流程示意图"></p><h4 id="react-redux主要提供了这么两个方法："><a href="#react-redux主要提供了这么两个方法：" class="headerlink" title="react-redux主要提供了这么两个方法："></a>react-redux主要提供了这么两个方法：</h4><ol><li><p>provider。相当于一个高阶组件，包在整个组件树的最外层，让所有子孙组件都能使用connect来绑定store。它利用了 React 的 context 这一特性，只要在最外层的组件实现一个 getChildContext这个方法（React内置的），返回一个对象，内部的组件都可以通过 this.context 拿到这个对象。</p></li><li><p>connect。若一个组件想响应状态的变化，就把自己作为参数传给connect。<br>我们先看一下 connect 一般情况下是怎么使用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(MyComponent)</span><br></pre></td></tr></table></figure></li></ol><p>首先，export 出去的是一个增强过的 react 组件，也就是说 connect(mapStateToProps, mapDispatchToProps) 第一步首先返回了一个高阶组件。connect()()有两次执行，那么 connect 第二步具体做了什么呢？被这样包裹了一层之后，相应的组件变成了 Container / Smart Component，可以通过 this.props 来获取 store 里的 state，以及 dispatch 这个方法。这样一来，store.state 的更新也就触发了 this.props 的更新，继而触发了容器组件的 re-render。所以，connect 第二步就是把 mapStateToProps 和 mapDispatchToProps 里的返回的属性，以及本身的 props 一起，作为 props 传递给了被包裹的组件。<br>那么，connect 是怎么做到监听 store 变化的呢？答案是用到了Redux的subscribe这个API。综上，connect的内部应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function connect(mapStateToProps, mapDispatchToProps) &#123;</span><br><span class="line">  return function createHOC(WrappedComponent) &#123;</span><br><span class="line">    class Connect extends React.Component &#123;</span><br><span class="line">      constructor(props, context) &#123;</span><br><span class="line">        this.store = context.store // &lt;Provider /&gt; 提供</span><br><span class="line">      &#125;</span><br><span class="line">      componentDidMount() &#123;</span><br><span class="line">        this.unsubscribe = this.store.subscribe(this.handleChange.bind(this))</span><br><span class="line">      &#125;</span><br><span class="line">      componentWillUnmount() &#123;</span><br><span class="line">        this.unsubscribe()</span><br><span class="line">      &#125;</span><br><span class="line">      handleChange() &#123;</span><br><span class="line">        this.forceUpdate()</span><br><span class="line">      &#125;</span><br><span class="line">      render() &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;WrappedComponent </span><br><span class="line">            &#123;...this.props&#125;</span><br><span class="line">            &#123;...mapStateToProps(this.store.getState(), this.props)&#125;</span><br><span class="line">            &#123;...mapDispatchToProps(this.store.dispatch, this.props)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Connect.displayName = `Connect($&#123;WrappedComponent.name </span><br><span class="line">                              || WrappedComponent.displayName&#125;)`</span><br><span class="line">    return Connect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="考虑使用Immutable优化纯函数的操作"><a href="#考虑使用Immutable优化纯函数的操作" class="headerlink" title="考虑使用Immutable优化纯函数的操作"></a>考虑使用Immutable优化纯函数的操作</h3><p>Redux的宗旨就是单一数据流，可追溯，这两点恰恰是immutable.js的优势。<br>Immutable Data就是一旦创建，就不能再被更改的数据。对Immutable对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是持久化数据结构，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免深拷贝把所有节点都复制一遍带来的性能损耗，Immutable 使用了结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p><p>示例图：<br><img src="http://img.alicdn.com/tps/i2/TB1zzi_KXXXXXctXFXXbrb8OVXX-613-575.gif" alt="Immutable结构共享"></p><p>比如说，我们可以在reducer中这样用immutable：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">export const proData = (state = defaultState, action) =&gt; &#123;</span><br><span class="line">  let imuDataList;</span><br><span class="line">  let imuItem;</span><br><span class="line">  switch(action.type)&#123;</span><br><span class="line">    case pro.GETPRODUCTION: </span><br><span class="line">      return &#123;...state, ...action&#125;</span><br><span class="line">    case pro.TOGGLESELECT:</span><br><span class="line">      //避免引用类型数据，使用immutable进行数据转换 </span><br><span class="line">      imuDataList = Immutable.List(state.dataList);</span><br><span class="line">      imuItem = Immutable.Map(state.dataList[action.index]);</span><br><span class="line">      imuItem = imuItem.set(&apos;selectStatus&apos;, !imuItem.get(&apos;selectStatus&apos;));</span><br><span class="line">      imuDataList = imuDataList.set(action.index, imuItem);</span><br><span class="line">      // redux必须返回一个新的state</span><br><span class="line">      return &#123;...state, ...&#123;dataList: imuDataList.toJS()&#125;&#125;;</span><br><span class="line">    case pro.EDITPRODUCTION:</span><br><span class="line">      //避免引用类型数据，使用immutable进行数据转换 </span><br><span class="line">      imuDataList = Immutable.List(state.dataList);</span><br><span class="line">      imuItem = Immutable.Map(state.dataList[action.index]);</span><br><span class="line">      imuItem = imuItem.set(&apos;selectNum&apos;, action.selectNum);</span><br><span class="line">      imuDataList = imuDataList.set(action.index, imuItem);</span><br><span class="line">      // redux必须返回一个新的state</span><br><span class="line">      return &#123;...state, ...&#123;dataList: imuDataList.toJS()&#125;&#125;;</span><br><span class="line">    // 清空数据</span><br><span class="line">    case pro.CLEARSELECTED:</span><br><span class="line">      imuDataList = Immutable.fromJS(state.dataList);</span><br><span class="line">      for (let i = 0; i &lt; state.dataList.length; i++) &#123;</span><br><span class="line">        imuDataList = imuDataList.update(i, item =&gt; &#123;</span><br><span class="line">          item = item.set(&apos;selectStatus&apos;, false);</span><br><span class="line">          item = item.set(&apos;selectNum&apos;, 0);</span><br><span class="line">          return item</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      return &#123;...state, ...&#123;dataList: imuDataList.toJS()&#125;&#125;;</span><br><span class="line">    default: </span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Immutable带来的优点"><a href="#Immutable带来的优点" class="headerlink" title="Immutable带来的优点"></a>Immutable带来的优点</h4><ol><li>Immutable 降低了 Mutable 带来的复杂度。可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function touchAndLog(touchFn) &#123;</span><br><span class="line">  let data = &#123; key: &apos;value&apos; &#125;;</span><br><span class="line">  touchFn(data);</span><br><span class="line">  console.log(data.key); // 猜猜会打印什么？</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在不查看 <code>touchFn</code> 的代码的情况下，因为不确定它对 <code>data</code> 做了什么，你是不可能知道会打印什么。但如果 <code>data</code> 是 <code>Immutable</code> 的呢，你可以很肯定的知道打印的是 <code>value</code>。</p><ol><li>节省内存。Immutable.js 使用了结构共享，会尽量复用内存。没有被引用的对象会被垃圾回收。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Map&#125; from &apos;immutable&apos;;</span><br><span class="line">let a = Map(&#123;</span><br><span class="line">  select: &apos;users&apos;,</span><br><span class="line">  filter: Map(&#123; name: &apos;Cam&apos; &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">let b = a.set(&apos;select&apos;, &apos;people&apos;);</span><br><span class="line"></span><br><span class="line">a === b; // false</span><br><span class="line"></span><br><span class="line">a.get(&apos;filter&apos;) === b.get(&apos;filter&apos;); // true</span><br></pre></td></tr></table></figure></li></ol><p>上面 a 和 b 共享了没有变化的 <code>filter</code> 节点。</p><ol><li>可回溯，时间旅行这些功能做起来小菜一碟。因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。</li></ol><hr><h3 id="Redux和Flux的区别"><a href="#Redux和Flux的区别" class="headerlink" title="Redux和Flux的区别"></a>Redux和Flux的区别</h3><ol><li>Redux只有一个store，且在reducer中执行更新逻辑；Flux有多个store且在store中执行更新逻辑。</li><li>Redux没有dispatcher，它是通过reducer来处理数据（reducer是一个纯函数，(prevState,action)=&gt;newState）。在Redux中可能有多个reducer，单个reducer负责维护应用整体state树中的某一部分，多个reducer通过combineReducers合成一个根reducer来维护整个state。</li><li>Redux概念太超前了，一步到位强制把副作用隔离掉了，但自己又没有深入解决带来的代码冗余问题。</li></ol><hr><h3 id="Redux优缺点"><a href="#Redux优缺点" class="headerlink" title="Redux优缺点"></a>Redux优缺点</h3><p>优点：</p><ol><li>纯函数的开发模式，无副作用。</li><li>单向数据流流动自然清晰，任何的dispatch都会通知到reducer来处理，增强更新粒度可控性。</li><li>利用中间件的模式来解决异步带来的副作用问题。</li><li>可时间回溯。为了解决阻碍回溯的“对象引用”机制，将 immutable应用到了前端。这下所有状态都不会被修改，基于此的redux-dev-tools提高了开发体验。</li></ol><p>缺点：</p><ol><li>代码书写啰嗦，造成代码冗余。</li><li>函数式编程对于习惯于面向对象思维的开发人员比较难接受。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redux&quot;&gt;&lt;a href=&quot;#Redux&quot; class=&quot;headerlink&quot; title=&quot;Redux&quot;&gt;&lt;/a&gt;Redux&lt;/h2&gt;&lt;p&gt;Redux 是 JavaScript 状态容器，提供可预测化的状态管理，属于Flux模式的具体实现之一，核心理念是在
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="前端数据流" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端数据流管理方案（三）——Vuex篇</title>
    <link href="http://yoursite.com/2018/05/05/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Vuex%E7%AF%87/"/>
    <id>http://yoursite.com/2018/05/05/浅谈前端数据流管理方案（三）——Vuex篇/</id>
    <published>2018-05-04T16:00:00.000Z</published>
    <updated>2018-09-11T05:59:35.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>先来看看官网对Vuex的描述：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>Vuex也是属于Flux流派的一种，通过单向数据流的方式来管理数据。但是它是专门为Vue定制的数据管理框架，主要是为了配合Vue本身的响应式机制，对框架的依赖性更高。</p><h3 id="Vuex各部分职能："><a href="#Vuex各部分职能：" class="headerlink" title="Vuex各部分职能："></a>Vuex各部分职能：</h3><ul><li>Store：存储数据和管理数据方法的仓库。</li><li>State：状态数据。</li><li>Getters：computed过后的状态，对State进行的二次包装。</li><li>Mutations：所有状态修改都是通过它来提交，必须是同步的。</li><li>Actions：允许异步执行，其本质是在回调中提交Mutations。</li><li>Modules：为解决Store过大，分化Store到每个Module中。</li></ul><hr><h3 id="Vuex流程："><a href="#Vuex流程：" class="headerlink" title="Vuex流程："></a>Vuex流程：</h3><p>Vuex流程示意图：<br><img src="https://vuex.vuejs.org/zh-cn/images/vuex.png" alt="Vuex流程示意图"></p><ol><li>在Vue组件中手动触发Action，Action中执行异步操作，并在回调中commit到mutation。（如果是同步操作，你可以直接在Vue组件中直接触发mutation）。</li><li>mutation同步修改state。</li><li>state修改完成之后，通知Vue组件进行rerender。这样一来，一次数据的单向流动就完成了。</li></ol><hr><h3 id="与同门师兄Redux的区别："><a href="#与同门师兄Redux的区别：" class="headerlink" title="与同门师兄Redux的区别："></a>与同门师兄Redux的区别：</h3><ol><li>Vuex是一个针对Vue特化的Flux，能够很好地去配合Vue自身的响应式机制。</li><li>Vuex没有强制immutability，并不像Redux的纯函数那么严格，你可以在mutation中直接修改state，或是引发一些副作用，这一点比较宽松。这么做的原因和 Vue 的运行机制有关系，Vue 基于 ES5 中的 getter/setter 来实现视图和数据的双向绑定，因此 Vuex 中 state 的变更可以通过 setter 通知到视图中对应的指令来实现视图更新。</li><li>在异步流程处理这方面，Vuex通过action和mutation之间的配合来实现：action可以是异步的（下面的源码解析也会说到action在Vuex内部会被包装成Promise），然后异步处理完后，commit给mutation必须是同步的。而Redux通过引入中间件（如redux-thunk 、redux-saga等等）来处理异步流程。</li></ol><h4 id="ps：为什么mutation中必须是同步提交的？"><a href="#ps：为什么mutation中必须是同步提交的？" class="headerlink" title="ps：为什么mutation中必须是同步提交的？"></a>ps：为什么mutation中必须是同步提交的？</h4><p>尤大原话：同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。</p><p>因此mutations和状态树正确的对应关系是实现时间旅行的关键，异步的话不能保证这点。</p><hr><h3 id="Vuex源码解读："><a href="#Vuex源码解读：" class="headerlink" title="Vuex源码解读："></a>Vuex源码解读：</h3><p>Vuex的源码不多，适合阅读学习~</p><h4 id="1-入口文件index-js"><a href="#1-入口文件index-js" class="headerlink" title="1.入口文件index.js"></a>1.入口文件index.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Store, install &#125; from &apos;./store&apos;</span><br><span class="line">import &#123; mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers &#125; from &apos;./helpers&apos;</span><br><span class="line"></span><br><span class="line">//导出store类，install方法，版本，一些操作state,mutations,actions,getters的语法糖</span><br><span class="line">export default &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install,</span><br><span class="line">  version: &apos;__VERSION__&apos;,</span><br><span class="line">  mapState,</span><br><span class="line">  mapMutations,</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions,</span><br><span class="line">  createNamespacedHelpers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入口文件的主要功能就是把个模块部分实现的方法、属性等等聚合起来，然后再提供一个出口供外部来调用。</p><h4 id="2-将store注入Vue实例"><a href="#2-将store注入Vue实例" class="headerlink" title="2.将store注入Vue实例"></a>2.将store注入Vue实例</h4><p>接下来看看Vuex是如何把store注入到每个Vue实例中，使得每个Vue实例拿到同一份store。这里的实现逻辑主要是在mixin.js文件中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Vue2.x和Vue1.x的注入方式有点不同</span><br><span class="line">const version = Number(Vue.version.split(&apos;.&apos;)[0])</span><br><span class="line">if (version &gt;= 2) &#123;</span><br><span class="line">  Vue.mixin(&#123; beforeCreate: vuexInit &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  const _init = Vue.prototype._init</span><br><span class="line">  Vue.prototype._init = function (options = &#123;&#125;) &#123;</span><br><span class="line">    options.init = options.init</span><br><span class="line">      ? [vuexInit].concat(options.init)</span><br><span class="line">      : vuexInit</span><br><span class="line">    _init.call(this, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//注入实现逻辑</span><br><span class="line">function vuexInit () &#123;</span><br><span class="line">  const options = this.$options</span><br><span class="line">  // store injection</span><br><span class="line">  if (options.store) &#123;</span><br><span class="line">    this.$store = typeof options.store === &apos;function&apos;</span><br><span class="line">      ? options.store()</span><br><span class="line">      : options.store</span><br><span class="line">  &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">    this.$store = options.parent.$store</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里只说下Vue2.x的注入流程：调用Vue的mixin方法把vuexInit方法混入到每个组件的beforeCreate钩子中。在vuexInit中通过vm.$options判断有没有store，有就说明是root组件（因为在vue初始化root组件的时候会注入），没有的话就从它的parent那里获取。这样一来，所有组件都能拿到同一份store了。</p><h4 id="3-重头戏store-js"><a href="#3-重头戏store-js" class="headerlink" title="3.重头戏store.js"></a>3.重头戏store.js</h4><p>这个文件是Vuex的主文件，定义了Vuex的运行逻辑、方法等等。先说说它初始化的一些东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//定义的一些内部变量</span><br><span class="line">//判断是否通过mutation来修改state，严格模式实现的主要参数（下文会说怎么实现严格模式）</span><br><span class="line">this._committing = false</span><br><span class="line">//存放actions</span><br><span class="line">this._actions = Object.create(null)</span><br><span class="line">//存放mutations</span><br><span class="line">this._mutations = Object.create(null)</span><br><span class="line">//存放getters</span><br><span class="line">this._wrappedGetters = Object.create(null)</span><br><span class="line">this._modules = new ModuleCollection(options)</span><br><span class="line">this._modulesNamespaceMap = Object.create(null)</span><br><span class="line">//存放订阅者</span><br><span class="line">this._subscribers = []</span><br><span class="line">//借用这个vue实例来使用它的watch方法</span><br><span class="line">this._watcherVM = new Vue()</span><br></pre></td></tr></table></figure></p><p>两个主要方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装各个module，给不同的module加上不同的命名空间，避免命名污染，遍历注册mutation、action、getter、子module。</span><br><span class="line">installModule(this, state, [], this._modules.root)</span><br><span class="line"></span><br><span class="line">//通过vm重设store，利用vue的响应式使得vuex的数据也变得响应式</span><br><span class="line">resetStoreVM(this, state)</span><br></pre></td></tr></table></figure></p><h4 id="4-着重说说resetStoreVM方法"><a href="#4-着重说说resetStoreVM方法" class="headerlink" title="4.着重说说resetStoreVM方法"></a>4.着重说说resetStoreVM方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function resetStoreVM (store, state, hot) &#123;</span><br><span class="line">  const oldVm = store._vm </span><br><span class="line"></span><br><span class="line">  store.getters = &#123;&#125;</span><br><span class="line">  const wrappedGetters = store._wrappedGetters</span><br><span class="line">  const computed = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  /* 通过Object.defineProperty方法为每一个getter方法设置它的get，比如获取this.$store.getters.age的时候获取的是store._vm.age，这赋值到Vue对象的computed属性上的，利用了computed本身就有的响应式，从而实现了响应式 */</span><br><span class="line">  forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">    computed[key] = () =&gt; fn(store)</span><br><span class="line">    Object.defineProperty(store.getters, key, &#123;</span><br><span class="line">      get: () =&gt; store._vm[key],</span><br><span class="line">      enumerable: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  const silent = Vue.config.silent</span><br><span class="line">  </span><br><span class="line">  /* 这里新建一个vue实例，运用Vue内部的响应式实现注册state以及computed（把state赋值到vue实例的data上，把getter赋值到vue实例的computed上）*/</span><br><span class="line">  store._vm = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      $$state: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Vue.config.silent = silent</span><br><span class="line"></span><br><span class="line">  //严格模式是否启用</span><br><span class="line">  if (store.strict) &#123;</span><br><span class="line">    enableStrictMode(store)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (oldVm) &#123;</span><br><span class="line">    if (hot) &#123;</span><br><span class="line">      store._withCommit(() =&gt; &#123;</span><br><span class="line">        oldVm._data.$$state = null</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    Vue.nextTick(() =&gt; oldVm.$destroy())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-commit方法"><a href="#5-commit方法" class="headerlink" title="5.commit方法"></a>5.commit方法</h4><p>Mutation的commit方法用于同步修改state<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">commit (_type, _payload, _options) &#123;</span><br><span class="line">   const &#123;</span><br><span class="line">     type,</span><br><span class="line">     payload,</span><br><span class="line">     options</span><br><span class="line">   &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line"></span><br><span class="line">   const mutation = &#123; type, payload &#125;</span><br><span class="line">   </span><br><span class="line">   //找到Mutations中对应的type的mutation</span><br><span class="line">   const entry = this._mutations[type]</span><br><span class="line">   if (!entry) &#123;</span><br><span class="line">     if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">       console.error(`[vuex] unknown mutation type: $&#123;type&#125;`)</span><br><span class="line">     &#125;</span><br><span class="line">     return</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //遍历执行刚才拿到的mutations</span><br><span class="line">   /* ps：这个_withCommit方法会先保存当前的_committing值，然后把它修改为true，再去执行回调，最后把_committing复原。这也是下文提到的严格模式的控制实现 */</span><br><span class="line">   this._withCommit(() =&gt; &#123;</span><br><span class="line">     entry.forEach(function commitIterator (handler) &#123;</span><br><span class="line">       handler(payload)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   //通知所有的订阅者</span><br><span class="line">   this._subscribers.forEach(sub =&gt; sub(mutation, this.state))</span><br><span class="line"></span><br><span class="line">   if (</span><br><span class="line">     process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">     options &amp;&amp; options.silent</span><br><span class="line">   ) &#123;</span><br><span class="line">     console.warn(</span><br><span class="line">       `[vuex] mutation type: $&#123;type&#125;. Silent option has been removed. ` +</span><br><span class="line">       &apos;Use the filter functionality in the vue-devtools&apos;</span><br><span class="line">     )</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>commit方法会根据传进来的type找到对应的mutation去执行，执行完之后，又会通知所有订阅者有新的state。</p><p>这个subscribe一般在devtool那里用到，如果是渲染更新state的话直接利用vue自身的响应式就好，不用这个subscribe。</p><p>subscribe可以协助devtoolPlugin实现时间旅行。因为dev模式下所有的state change都会被记录下来，时间旅行 功能其实就是将当前的state替换为记录中某个时刻的state状态，利用 store.replaceState(targetState) 方法将执行this._vm.state = state 实现。</p><h4 id="6-dispatch方法"><a href="#6-dispatch方法" class="headerlink" title="6.dispatch方法"></a>6.dispatch方法</h4><p>处理action的dispatch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch (_type, _payload) &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    type,</span><br><span class="line">    payload</span><br><span class="line">  &#125; = unifyObjectStyle(_type, _payload)</span><br><span class="line"></span><br><span class="line">  const entry = this._actions[type]</span><br><span class="line">  if (!entry) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      console.error(`[vuex] unknown action type: $&#123;type&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return entry.length &gt; 1</span><br><span class="line">    ? Promise.all(entry.map(handler =&gt; handler(payload)))</span><br><span class="line">    : entry[0](https://cdn.example.com/payload?m=webp&q=80)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过type拿到所有的actions，如果actions大于1，那就把它们包装在Promise.all里面去并行执行，等于1就直接执行。那么，为什么这里可以把actions放在Promise.all里面呢？Promise.all里不是只能放Promise对象吗？</p><p>对，每个action都是一个Promise，这是通过registerAction来注册实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function registerAction (store, type, handler, local) &#123;</span><br><span class="line">  const entry = store._actions[type] || (store._actions[type] = [])</span><br><span class="line">  entry.push(function wrappedActionHandler (payload, cb) &#123;</span><br><span class="line">    let res = handler.call(store, &#123;</span><br><span class="line">      dispatch: local.dispatch,</span><br><span class="line">      commit: local.commit,</span><br><span class="line">      getters: local.getters,</span><br><span class="line">      state: local.state,</span><br><span class="line">      rootGetters: store.getters,</span><br><span class="line">      rootState: store.state</span><br><span class="line">    &#125;, payload, cb)</span><br><span class="line">    </span><br><span class="line">    //它就会把每一个action转化为Promise对象</span><br><span class="line">    if (!isPromise(res)) &#123;</span><br><span class="line">      res = Promise.resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    if (store._devtoolHook) &#123;</span><br><span class="line">      return res.catch(err =&gt; &#123;</span><br><span class="line">        store._devtoolHook.emit(&apos;vuex:error&apos;, err)</span><br><span class="line">        throw err</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7-严格模式的实现"><a href="#7-严格模式的实现" class="headerlink" title="7.严格模式的实现"></a>7.严格模式的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//启用严格模式</span><br><span class="line">function enableStrictMode (store) &#123;</span><br><span class="line">  store._vm.$watch(function () &#123; return this._data.$$state &#125;, () =&gt; &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123; deep: true, sync: true &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文也说到，store中有个_committing属性，是用来标志是否正在通过mutation来修改state，如果是的话，它的值为true，否则为false。启用严格模式后，严格模式中会通过vue的$watch方法来检测state的变化，如果有变化，那就判断_committing属性，_committing为false的话就抛出异常。</p><h4 id="8-语法糖：mapState-mapMutations-mapActions-mapGetters"><a href="#8-语法糖：mapState-mapMutations-mapActions-mapGetters" class="headerlink" title="8.语法糖：mapState,mapMutations,mapActions,mapGetters"></a>8.语法糖：mapState,mapMutations,mapActions,mapGetters</h4><p>mapState,mapMutations,mapActions,mapGetters它们都是一些提供给开发者操作store的一些语法糖函数。<br>它们几个在实现上也比较类似，主要流程是先将state,mutations等等这些转化成[{key, val},{key, val},{key, val}…]的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function normalizeMap (map) &#123;</span><br><span class="line">  return Array.isArray(map)</span><br><span class="line">    ? map.map(key =&gt; (&#123; key, val: key &#125;))</span><br><span class="line">    : Object.keys(map).map(key =&gt; (&#123; key, val: map[key] &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后遍历这个数据结构，把每一项都包装成一个函数。<br>mapState和mapGetters是把它们的值作为该函数的返回值返回出去，这样在vue示例中的computed就能拿到它们的值了。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    ...mapState([</span><br><span class="line">        &apos;name&apos;</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br><span class="line">//就会转化成</span><br><span class="line">computed:&#123;</span><br><span class="line">    name () &#123;</span><br><span class="line">      return this.$store.state.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而mapMutations和mapActions分别是返回调用它们的commit和dispatch方法，这样在vue示例中的methods也就存在它们的方法了。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    ...mapMutation([</span><br><span class="line">        &apos;addName&apos;</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br><span class="line">//就会转化成</span><br><span class="line">methods:&#123;</span><br><span class="line">    addName(...args)&#123;</span><br><span class="line">        return this.$store.commit.apply(this.$store,[&apos;addName&apos;].concat(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="9-Vuex的错误处理方式"><a href="#9-Vuex的错误处理方式" class="headerlink" title="9.Vuex的错误处理方式"></a>9.Vuex的错误处理方式</h4><p>Vuex的错误处理是通过自定义函数assert实现，内容很简单，值得一学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//假设现在要判断当前环境支不支持Promise</span><br><span class="line">assert(typeof Promise!==&apos;undefined&apos;,&apos;当前环境不支持Promise&apos;);</span><br><span class="line"></span><br><span class="line">function assert(condition,msg)&#123;</span><br><span class="line">    if(!condition) throw new Error(`[vuex] $&#123;msg&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h2&gt;&lt;p&gt;先来看看官网对Vuex的描述：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="前端数据流" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
      <category term="Vuex" scheme="http://yoursite.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端数据流管理方案（二）——MobX篇</title>
    <link href="http://yoursite.com/2018/05/03/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94MobX%E7%AF%87/"/>
    <id>http://yoursite.com/2018/05/03/浅谈前端数据流管理方案（二）——MobX篇/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-09-11T05:59:39.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MobX"><a href="#MobX" class="headerlink" title="MobX"></a>MobX</h2><p>Mobx专注于解决数据级别的响应，它不关系数据的来源方式，只要一个对象中的属性、一个基本类型变量发生了变化，对这些数据的订阅就会自动执行。使用Mobx管理状态时，当我们更新观察对象的状态后，由观察对象的改变带来的界面重渲染、数据序列化等一系列副作用，Mobx会自动帮我们完成。</p><hr><h3 id="Mobx的主要概念"><a href="#Mobx的主要概念" class="headerlink" title="Mobx的主要概念"></a>Mobx的主要概念</h3><ol><li><p>Actions: 改变state的操作。</p></li><li><p>ObservableState:应用的可被观察的数据状态。</p></li><li><p>Computed: 从state中通过纯函数的操作衍生出的值，state变化它也会跟着变化。</p></li><li><p>Reactions：需要对state变化动态作出反应的东西，它包含不同的概念，基于被观察数据的更新导致某个计算值，或者是发送网络请求以及更新视图等，都属于响应的范畴，这也是响应式编程在 JavaScript 中的一个应用。</p></li><li><p>Autorun。依赖收集，监听触发，autorun 背后由 reaction 实现。由于 autorun 与 view 的 render 函数很像，我们在 render 函数初始化执行时，使其包裹在 autorun 环境中，第 2 次 render 开始遍剥离外层的 autorun，保证只绑定一遍数据。这样 view 层在原本 props 更新机制的基础上，增加了 autorun 的功能，实现修改任何数据自动更新对应 view 的效果。（ps:使用autoRun实现Mobx-react非常简单，核心思想是将组件外面包上autoRun，这样代码中用到的所有属性都会像上面Demo一样，与当前组件绑定，一旦任何值发生了修改，就直接forceUpdate，而且精确命中，效率最高。）</p></li></ol><hr><h3 id="Mobx流程"><a href="#Mobx流程" class="headerlink" title="Mobx流程"></a>Mobx流程</h3><p>一图胜千言~<br><img src="https://wx3.sinaimg.cn/mw690/768c39d5gy1fqvrrvmevqj21330dfq56.jpg" alt="Mobx流程示意图"><br>可以把 observable 理解为信号源，每当信号变化时，函数流会自动执行，并输出结果，最终会使视图刷新。这就是数据驱动视图。每当我们的可观察对象变化时，都会自动触发数据源的 dispatch，而且各视图也是自动订阅各数据源的，这就是依赖追踪。</p><hr><h3 id="Mobx的优缺点"><a href="#Mobx的优缺点" class="headerlink" title="Mobx的优缺点"></a>Mobx的优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>使用起来十分顺手，降低开发难度。十分“智能”，当我们更新观察对象的状态后，由观察对象的改变带来的界面重渲染、数据序列化等一系列副作用，Mobx会自动帮我们完成。</li><li>面向对象的使用方法，较为符合我们平时开发的逻辑。</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><p>无副作用隔离，非严格模式下可以对observable直接修改，这样容易造成 store 被随意修改。在项目规模比较大的时候，像 Vuex 和 Redux 一样对修改数据的入口进行限制可以提高安全性。因此如果不规范Mobx使用的话将会导致数据流变化混乱问题。</p></li><li><p>在收集依赖时，Mobx会把autorun执行一遍来触发里面observable的getter从而收集依赖。但是万一你写出了以下的代码，Mobx是收集不到你想要收集的依赖的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let val = 1;</span><br><span class="line">let ob = observable(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">//在这里我们没有访问 ob.a ，而只是访问了 ob，autorun 没有收集到 ob.a 的依赖，所以当改变ob.a的时候也不会触发下面这个函数。</span><br><span class="line">let test1 = autorun(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;log ob.a&apos;, ob);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//在这里有一个返回值为false的判断语句使得判断语句里面的内容没有执行，从而也收集不到依赖</span><br><span class="line">let test2 = autorun(() =&gt; &#123;</span><br><span class="line">    if (val === 2) &#123;</span><br><span class="line">        console.log(&apos;判断 x&apos;, ob.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>observable跟普通的plainObject傻傻分不清楚，observable跟plainObject外貌上一摸一样，有时可能会误会了observable的本质</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const x = observable([1, 2, 3])</span><br><span class="line">x.map(x =&gt; x + 1) // 我们可以像普通的数组一样操作 observable array</span><br><span class="line"></span><br><span class="line">//不会被执行，因为 Array.isArray(observable([1, 2, 3])) === false</span><br><span class="line">if (Array.isArray(x)) &#123;</span><br><span class="line">  x.push(4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="Mobx与Redux的区别"><a href="#Mobx与Redux的区别" class="headerlink" title="Mobx与Redux的区别"></a>Mobx与Redux的区别</h3><ol><li>从数据管理模式的差别上看，Mobx是基于双向绑定的响应式的实现，而redux是基于flux的单向数据流的实现。</li><li>从开发上来看是和面向对象和函数式编程的区别。但是前端开发需要经常与副作用打交道，所以前端开发很难与完美的函数式编程相结合。</li><li>redux的state是只读的，产生新的state的过程是pure的；Mobx的state可读可写，并且action并不是必须的，可以直接赋值改变，这也看出了Mobx改变数据的impure。</li><li>在可预测性、可维护性上看，redux得益于它的清晰的单向数据流和纯函数的实现，在这方面优于Mobx。</li><li>redux是单一数据源；而Mobx是多个store。</li><li>redux中的store是普通的js对象结构，而Mobx中的会对其进行observable化，从而实现响应式。</li><li>从代码量上看，Mobx能少写很多代码，而redux要通过action,reducer等等的编写才能实现整个流程。</li></ol><hr><h3 id="Mobx与Rxjs"><a href="#Mobx与Rxjs" class="headerlink" title="Mobx与Rxjs"></a>Mobx与Rxjs</h3><p>它们两者都是响应式的，但又有所不同。<br>Mobx的observable是从store到view的数据变化的autorun响应。<br>Rxjs的observable是从数据源到store的数据源派发流的过程。</p><p>Mobx和Rxjs可以是一种互补的关系，Rxjs响应数据的来源，Mobx响应数据的变化。<br>例如:如果想在更新state之前对用户的输入操作节流，大致工作流是：</p><p>DOM events -&gt; RxJS -&gt; Update state -&gt; MobX -&gt; Update UI<br>//Rxjs仅用来隔离副作用与数据处理，Mobx用来响应数据的变化，拥有修改 store 的能力，并且精准更新使用的 View。</p><hr><h3 id="Mobx基本原理"><a href="#Mobx基本原理" class="headerlink" title="Mobx基本原理"></a>Mobx基本原理</h3><p>那么Mobx是怎么做到这个响应式双向绑定的呢？</p><p>我们通过定义可观察对象，依赖收集，触发更新这个顺序来说说它的基本原理~</p><h4 id="1-定义可观察对象"><a href="#1-定义可观察对象" class="headerlink" title="1.定义可观察对象"></a>1.定义可观察对象</h4><p>我们平时是这样来定义一个可观察对象的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class newsStore&#123;</span><br><span class="line">    @observable hotNews=[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在这里mobx用了修饰器的形式来定义，实质上，它是这样的：</span><br><span class="line">function newsStore() &#123;</span><br><span class="line">    extendObservable(this, &#123;</span><br><span class="line">        hotNews: []</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到这里用到了<code>extendObservable</code>这个方法来让目标对象可观察化，在这个方法中：</p><ol><li>给<code>target</code>(当前的类，例子中的<code>newsStore</code>)设置一个<code>$mobx</code>属性作为它的代理对象，<code>$mobx</code>有一个属性<code>values</code>属性，就是用来存储可观察属性的。因此对其的可观察化不会对该对象本身产生影响，对其的所有操作都将通过其 <code>$mobx</code> 属性代理。</li><li>然后将每个设置了<code>@observable</code>的属性值转化为一个可观察的对象，并存储在 <code>$mobx.values[propName]</code> 中，例如上面的例子，就是把<code>hotNews</code>放在了<code>target.$mobx.values[hotNews]</code>中。</li><li>遍历可观察属性，给每个<code>observable</code>重写<code>get</code>和<code>set</code>来将外界对目标对象的读写操作代理到其代理对象。get和set分别会调用<code>reportObserved</code>和<code>reportChanged</code>进行相应操作。<br><img src="https://wx4.sinaimg.cn/mw690/768c39d5gy1fqvwcn2y8wj215q0dpmyk.jpg" alt="$mobx"><br>图片来源：阿里云中台前端/全栈团队专栏，侵删</li></ol><h4 id="2-依赖收集"><a href="#2-依赖收集" class="headerlink" title="2.依赖收集"></a>2.依赖收集</h4><p>依赖收集主要是在<code>autorun</code>中进行的，它会把参数包装成一个观察者，先执行一次，当执行过程中遇到可观察属性，就会触发到该可观察属性的getter，这个getter就会调用它的<code>reportObserved</code>方法,这个方法就会拿到全局状态下当前的<code>Derivation</code>（也就是当前这个autorun的Reaction），然后把这个<code>observableValue</code>放到当前<code>Derivation</code>的<code>newObserving</code>数组中，从而使得该<code>Reaction</code>中就绑定着它所观察的所有的<code>observableValue</code>。<br>然后，遍历每个<code>observableValue</code>，通过<code>addObserver</code>的方法将依赖该<code>observableValue</code>的<code>reaction</code>添加到它的<code>observers</code>属性中。<br>这样一来，在<code>Reaction</code>中储存着它依赖的<code>observableValue</code>，在每个<code>observableValue</code>中的<code>observers</code>属性中也储存着依赖它的<code>Reaction</code>。</p><h4 id="3-触发更新"><a href="#3-触发更新" class="headerlink" title="3.触发更新"></a>3.触发更新</h4><p>当<code>observableValue</code>发生改变的时候，就会出发到它的<code>setter</code>。在这个<code>setter</code>中会遍历该<code>observable</code>的<code>observers</code>数组，把它们都标志为过期状态。当这个<code>reaction</code>处于过期状态的时候，就会把这个<code>reaction</code>放进<code>pendingReactions</code>（一个全局的数组）中，然后依次调用它们的<code>runReaction</code>方法（这里用到了事务的方式来进行批处理）。<br>然后在<code>runReaction</code>的流程中，就会运行这些<code>reaction</code>，从而触发了所有被观察的 <code>Observable</code> 的 <code>reportObserved</code> 方法，并更新了当前<code>Derivation</code>的<code>newObserving</code>数组，也即重新收集了依赖，更新了依赖。</p><hr><h3 id="Nobx——迷你版的Mobx"><a href="#Nobx——迷你版的Mobx" class="headerlink" title="Nobx——迷你版的Mobx"></a>Nobx——迷你版的Mobx</h3><p>最后贴一下本人通过学习Mobx原理来实现的迷你版Mobx(●’◡’●)</p><p><a href="https://github.com/cmh1996/nobx" target="_blank" rel="noopener">https://github.com/cmh1996/nobx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MobX&quot;&gt;&lt;a href=&quot;#MobX&quot; class=&quot;headerlink&quot; title=&quot;MobX&quot;&gt;&lt;/a&gt;MobX&lt;/h2&gt;&lt;p&gt;Mobx专注于解决数据级别的响应，它不关系数据的来源方式，只要一个对象中的属性、一个基本类型变量发生了变化，对这些数据的订阅
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="前端数据流" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
      <category term="MobX" scheme="http://yoursite.com/tags/MobX/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端数据流管理方案（一）——Flux篇</title>
    <link href="http://yoursite.com/2018/04/22/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Flux%E7%AF%87/"/>
    <id>http://yoursite.com/2018/04/22/浅谈前端数据流管理方案（一）——Flux篇/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-05-10T12:36:01.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端主流的数据流管理现阶段已衍生出三种管理模式，分别是：</p><ul><li>单向数据流派Flux，代表库有Redux、Vuex。</li><li>响应式的双向绑定流派，代表库有MobX。</li><li>响应式的observable流派，代表库有RxJs。</li></ul><p>整个系列一共有五篇文章，主要介绍了上述三个流派在前端数据流管理上的模式阐述、库实现，并对它们三者进行了比较。本系列旨在加深对前端数据流的管理的认识，希望对你我都有所帮助(●’◡’●)。</p><h2 id="Flux模式"><a href="#Flux模式" class="headerlink" title="Flux模式"></a>Flux模式</h2><p>Flux是什么？Flux不是某一个具体库的名称，它是一种前端数据流的管理模式，核心是单向数据流，近年来诞生的很多js库就是这种思想的实现，例如Redux,Vuex等等。它用于构建客户端 Web 应用，规范数据在 Web 应用中的流动方式。</p><h3 id="Flux各部分职能："><a href="#Flux各部分职能：" class="headerlink" title="Flux各部分职能："></a>Flux各部分职能：</h3><ul><li>Action：这一块有个生成器叫Action Creator，它负责把type（自定义的用于标志特定action常量）和payload（负载的信息）封装成一个action，创建好之后就会把它传递给Dispatcher。</li><li>Dispatcher：它是一个负责派发action的派发器，它保存着包含所有的store的一个列表，接收到action之后再传给所有store，也就是说store并不是订阅某些action，而是聆听每一个action，从中过滤筛选出它关心的来做出反应。</li><li>Store：保存着整个应用的状态。它从dispatcher中接收到action后，使用一个switch语句判断action的类型，决定是否对这个action作出响应，如果store关心这个action，就会根据action找出需要变化的部分，更新state。只要state做出了变化，就会触发change事件，通知视图状态变化。</li><li>View：将state渲染给用户，并接受用户的输入,操作。view不能直接修改应用状态，只能触发action。View也分为Control-View和各个子View（类似于react中的智能组件和木偶组件），对于非Control-View的子View来说，所有数据都来源于Control-View传来的props。</li></ul><hr><h3 id="Flux流程："><a href="#Flux流程：" class="headerlink" title="Flux流程："></a>Flux流程：</h3><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png" alt="Flux流程示意图"><br>一、初始化</p><ol><li>创建store，store告诉dispatcher只要有action产生就告诉它。</li><li>Control-View从store获取到初始的state，并传递给各个子view去渲染。</li><li>Control-View让store在state变化更新的时候告诉它。</li></ol><p>二、触发数据流</p><ol><li>Control-View向Action-Creator触发一个action。</li><li>Action Creator做好action后将其发送给dispatcher。</li><li>dispatcher按顺序将action传给所有store，store自行对actionn进行判断，看是否对它作出响应。</li><li>store根据接受的action，对state进行更新，更新完毕后就通知订阅了该store的Control-View。</li><li>Control-View收到通知后，就会向store请求更新了的state。</li><li>Control-View获得了新的state之后，让子view渲染新的state。</li></ol><hr><h3 id="Flux优缺点："><a href="#Flux优缺点：" class="headerlink" title="Flux优缺点："></a>Flux优缺点：</h3><p>优点：</p><ol><li>视图组件变薄，只包含触发action和渲染数据这两个职责。</li><li>view对于数据层的只读使得数据是可预测的。</li><li>要想知道一个store可能的状态变化，只要看它注册了哪些actions回调即可。</li><li>每次有状态变化都会从dispatcher流过，这让所有状态变化都留下了一笔记录，有利于debug还有时间旅行。</li><li>dispatcher派发action是同步行为，这防止同一份数据有多个地方同时在写，使得数据变乱。</li></ol><p>缺点：</p><ol><li>冗余代码太多，出现很多类似的样板代码。每个应用中都要手动创建dispatcher实例，还有就是一个应用包含多个store来管理数据。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前端主流的数据流管理现阶段已衍生出三种管理模式，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单向数据流派Flux，代表库有Redux、Vuex。&lt;/
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Flux" scheme="http://yoursite.com/tags/Flux/"/>
    
      <category term="前端数据流" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>CSS世界学习笔记</title>
    <link href="http://yoursite.com/2018/04/02/css%E4%B8%96%E7%95%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/02/css世界学习笔记/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-09-25T02:53:19.783Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-盒子双重性"><a href="#1-盒子双重性" class="headerlink" title="1.盒子双重性"></a>1.盒子双重性</h3><p>按照 display 的属性值不同，值为 block 的元素的盒子实际由外在的“块级盒子” 和内在的“块级容器盒子”组成，值为 inline-block 的元素则由外在的“内联盒子”和内 在的“块级容器盒子”组成，值为 inline 的元素则内外均是“内联盒子”。实际上，如果遵循这种理解，display:block 应该脑补成 display:block-block，display:table 应该脑补成 display:block-table，我们平时的写法实际上是一种简写。<br>下面问题来了：元素都有内外两个盒子， 我们平常设置的 width/height 属性是作用在哪个盒子上的？这个问题也是很简单的，因为在解释内外盒子的时候就已经提到过了：是内在盒子，也就 是“容器盒子”。</p><h3 id="2-默认宽度width-auto的表现特性（即不设置宽度的表现）"><a href="#2-默认宽度width-auto的表现特性（即不设置宽度的表现）" class="headerlink" title="2.默认宽度width:auto的表现特性（即不设置宽度的表现）"></a>2.默认宽度width:auto的表现特性（即不设置宽度的表现）</h3><p><strong>（1）</strong>充分利用可用空间。比方说块级block元素的宽度默认是 100%于父级容器的。</p><p><strong>（2）</strong>收缩与包裹。典型代表就是浮动、绝对定位、inline-block 元素或 table 元素，意为“收缩到合适”，有那么点儿意思，但不够形象，我一直把这种现 象称为“包裹性”。元素尺寸由内部元素决定，但永远小于“包含块”容器的 尺寸。因此，对于一个元素，如果其 display 属性值是 inline-block，那么即使其里面内容 再多，只要是正常文本，宽度也不会超过容器。<br>包裹性例子：<a href="http://demo.cssworld.cn/3/2-5.php" target="_blank" rel="noopener">http://demo.cssworld.cn/3/2-5.php</a></p><p><strong>（3）</strong>收缩到最小。这个最容易出现在 table-layout 为 auto 的表格中。</p><p><strong>（4）</strong>超出容器限制。除非有明确的 width 相关设置，否则上面 3 种情况尺寸都不会主动 超过父级容器宽度的，但是存在一些特殊情况。例如，内容很长的连续的英文和数字，或者内联 元素被设置了 white-space:nowrap。</p><h3 id="3-min-width和max-width"><a href="#3-min-width和max-width" class="headerlink" title="3.min-width和max-width"></a>3.min-width和max-width</h3><p>min-width初始值为auto，max-width初始值为none。<br>max-width：<br><img src="/2018/04/02/css世界学习笔记/0.png" alt="css世界学习笔记"><br>上图答案是 256px。style、!important 通通靠边站！因为 max-width 会覆盖 width。<br>ps：如果元素height是auto不确定，那么可以巧用max-width实现“展开收起”效果：<br><img src="/2018/04/02/css世界学习笔记/1.png" alt="css世界学习笔记"><br>min-width：<br><img src="/2018/04/02/css世界学习笔记/2.png" alt="css世界学习笔记"><br>上图中min-width 活下来，max-width 被忽略， 于是，.container 元素表现为至少 1400 像素宽。</p><h3 id="4-幽灵空白节点"><a href="#4-幽灵空白节点" class="headerlink" title="4.幽灵空白节点"></a>4.幽灵空白节点</h3><p>“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在 HTML5 文档声明 中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这 个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样， 但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。<br><img src="/2018/04/02/css世界学习笔记/3.png" alt="css世界学习笔记"></p><h3 id="5-input-type-’button’-和button的区别"><a href="#5-input-type-’button’-和button的区别" class="headerlink" title="5.input[type=’button’]和button的区别"></a>5.input[type=’button’]和button的区别</h3><p>区别在什么地方？区别在于两种按钮默认的 white-space 值不一样，前者是 pre，后者是 normal，所表示出来的现象差异就是：当按钮文字足够多的时候，input按钮不会自动换行，button则会。</p><h3 id="6-margin-left和margin-right设为auto"><a href="#6-margin-left和margin-right设为auto" class="headerlink" title="6.margin-left和margin-right设为auto"></a>6.margin-left和margin-right设为auto</h3><p><img src="/2018/04/02/css世界学习笔记/4.png" alt="css世界学习笔记"><br>如果想让某个块状元素右对齐，脑子里不要就一个 float:right，很多时候，marginleft:auto 才是最佳的实践，浮动毕竟是个“小魔鬼”。我甚至可以这么说：margin 属性的 auto 计算就是为块级元素左中右对齐而设计的，和内联元素使用 text-align 控制左中右对 齐正好遥相呼应！ 居中对齐左右同时 auto 计算即可，CSS 如下：<br><img src="/2018/04/02/css世界学习笔记/5.png" alt="css世界学习笔记"></p><h3 id="7-尺寸单位ex了解一下"><a href="#7-尺寸单位ex了解一下" class="headerlink" title="7.尺寸单位ex了解一下"></a>7.尺寸单位ex了解一下</h3><p>ex 是 CSS 中的一个相对单位，指的是小写字母 x 的高度，没错，就是指 x-height。ex 是 CSS 中的一个相对单位，指的是小写字母 x 的高度，没错，就是指 x-height。<br>我们都知道，内联元素默认是基线对齐的，而基线就是 x 的底部，而 1ex 就是一个 x 的高 度。设想一下，假如图标高度就是 1ex，同时背景图片居中，岂不是图标和文字天然垂直居中， 而且完全不受字体和字号的影响？因为 ex 就是一个相对于字体和字号的单位。<br>现在，要让该图标和文字中间位置对齐，你会如 何实现？设定好尺寸，然后使用 vertical-align:middle？这 样虽然也有效果，但是，实际上啰嗦了，借助 ex 单位，我们直接 利用默认的 baseline 基线对齐就可以实现这个效果。<br><img src="/2018/04/02/css世界学习笔记/6.png" alt="css世界学习笔记"><br><img src="/2018/04/02/css世界学习笔记/7.png" alt="css世界学习笔记"></p><h3 id="8-多行文字垂直居中"><a href="#8-多行文字垂直居中" class="headerlink" title="8.多行文字垂直居中"></a>8.多行文字垂直居中</h3><p><img src="/2018/04/02/css世界学习笔记/8.png" alt="css世界学习笔记"><br><img src="/2018/04/02/css世界学习笔记/9.png" alt="css世界学习笔记"></p><h3 id="9-line-height的属性值"><a href="#9-line-height的属性值" class="headerlink" title="9.line-height的属性值"></a>9.line-height的属性值</h3><p><strong>1.数值</strong>，如 line-height:1.5，其最终的计算值是和当前 font-size 相乘后的值。 例如，假设我们此时的 font-size 大小为 14px，则 line-height 计算值是 1.5<em>14px=21px。<br><strong>2.百分比值</strong>，如 line-height:150%，其最终的计算值是和当前 font-size 相乘后 的值。例如，假设我们此时的 font-size 大小为 14px，则 line-height 计算值是 150%</em>14px=21px。<br><strong>3.长度值</strong>，也就是带单位的值，如 line-height:21px 或者 line-height:1.5em 等，此处 em 是一个相对于 font-size 的相对单位，因此，line-height:1.5em 最终的计算值也是和当前font-size相乘后的值。例如，假设我们此时的font-size 大小为 14px，则 line-height 计算值是 1.5*14px=21px。<br>乍一看，似乎 line-height:1.5、line-height:150%和 line-height:1.5em 这 3 种 用法是一模一样的，最终的行高大小都是和font-size计算值，但是，实际上，line-height:1.5 和另外两个有一点儿不同，那就是继承细节有所差别。如果使用数值作为 line-height 的属性值， 那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。<br><img src="/2018/04/02/css世界学习笔记/10.png" alt="css世界学习笔记"><br>如果我们做的是一个重图文内容展示的网页或者网站，如博客、论坛、 公众号之类的，那一定要使用数值作为单位，考虑到文章阅读的舒适度，line-height 值可 以设置在 1.6～1.8。</p><h3 id="10-word-break-break-all和word-wrap-break-word的区别"><a href="#10-word-break-break-all和word-wrap-break-word的区别" class="headerlink" title="10.word-break:break-all和word-wrap:break-word的区别"></a>10.word-break:break-all和word-wrap:break-word的区别</h3><p>word-break:break-all 的作用是所有的都换行，毫不留情，一点儿空 隙都不放过，而 word-wrap:break-word 则带有怜悯之心，如果这一行文字有可以换 行的点，如空格或 CJK（中文/日文/韩文）之类的，就不打英文单词或字符的主意了，在 这些换行点换行，至于对不对齐、好不好看则不关心，因此，很容易出现一片一片空白区域的情况。<br><img src="/2018/04/02/css世界学习笔记/11.png" alt="css世界学习笔记"></p><h3 id="11-隐藏元素的-background-image-到底加不加载呢？"><a href="#11-隐藏元素的-background-image-到底加不加载呢？" class="headerlink" title="11.隐藏元素的 background-image 到底加不加载呢？"></a>11.隐藏元素的 background-image 到底加不加载呢？</h3><p>想必这是一个很多人都感兴趣的问题。 根据我的测试，一个元素如果 display 计算值为 none，在 IE 浏览器下（IE8～IE11，更 高版本不确定）依然会发送图片请求，Firefox 浏览器不会，至于 Chrome 和 Safari 浏览器则似 乎更加智能一点：如果隐藏元素同时又设置了 background-image，则图片依然会去加载； 如果是父元素的 display 计算值为 none，则背景图不会请求，此时浏览器或许放心地认为这 个背景图暂时是不会使用的。</p><h3 id="12-outline"><a href="#12-outline" class="headerlink" title="12.outline"></a>12.outline</h3><p>万万不可在全局设置 outline:0 none！这样的错误会造成部分场景 下的部分用户产生使用障碍！ 国内很多大站也会犯类似的错误，注意千万不要学习，千万不要模仿！<br>outline 是不占据任何空间的属性。<br>ps:用outline自动填满屏幕剩余空间的应用技巧。<br><img src="/2018/04/02/css世界学习笔记/12.png" alt="css世界学习笔记"></p><p><img src="/2018/04/02/css世界学习笔记/13.png" alt="css世界学习笔记"></p><h3 id="13-direction-rtl十分有用"><a href="#13-direction-rtl十分有用" class="headerlink" title="13.direction:rtl十分有用"></a>13.direction:rtl十分有用</h3><p>ltr 是初始值，表示 left-to-right，就是从左往右的意思。目前东亚以及欧美文字书写就 是从左往右的；rtl 表示 right-to-left，就是从右往左的意思。配合text-align来用在某些场景很有用！另外，配合unicode-bidi 属性也了解一下。</p><h3 id="14-writing-mode实现纵向文字"><a href="#14-writing-mode实现纵向文字" class="headerlink" title="14.writing-mode实现纵向文字"></a>14.writing-mode实现纵向文字</h3><p>配合text-indent可以实现以下效果：<br><img src="/2018/04/02/css世界学习笔记/14.png" alt="css世界学习笔记"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-盒子双重性&quot;&gt;&lt;a href=&quot;#1-盒子双重性&quot; class=&quot;headerlink&quot; title=&quot;1.盒子双重性&quot;&gt;&lt;/a&gt;1.盒子双重性&lt;/h3&gt;&lt;p&gt;按照 display 的属性值不同，值为 block 的元素的盒子实际由外在的“块级盒子” 和内在的
      
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>web缓存</title>
    <link href="http://yoursite.com/2017/09/12/web%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2017/09/12/web缓存/</id>
    <published>2017-09-11T16:00:00.000Z</published>
    <updated>2018-05-10T12:36:31.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。"><a href="#Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。" class="headerlink" title="Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存 。"></a>Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存 。</h2><p>浏览器HTTP缓存可以分为强缓存和协商缓存。强缓存和协商缓存最大也是最根本的区别是：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache），协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。简略流程图如下：</p><p><img src="/2017/09/12/web缓存/1.png" alt="web缓存流程图1"></p><p><img src="/2017/09/12/web缓存/2.png" alt="web缓存流程图2"></p><p>浏览器HTTP缓存由HTTP报文的首部字段决定</p><h2 id="控制强缓存的字段按优先级介绍："><a href="#控制强缓存的字段按优先级介绍：" class="headerlink" title="控制强缓存的字段按优先级介绍："></a>控制强缓存的字段按优先级介绍：</h2><h3 id="1-Pragma"><a href="#1-Pragma" class="headerlink" title="1.Pragma"></a>1.Pragma</h3><p>Pragma是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。虽然它是一个通用首部，但是它在响应报文中时的行为没有规范，依赖于浏览器的实现。RFC中该字段只有no-cache一个可选值，会通知浏览器不直接使用缓存，要求向服务器发请求校验新鲜度。因为它优先级最高，当存在时一定不会命中强缓存。</p><h3 id="2-Expires"><a href="#2-Expires" class="headerlink" title="2.Expires"></a>2.Expires</h3><p>Expires是一个响应首部字段，它指定了一个日期/时间，在这个时间/日期之前，HTTP缓存被认为是有效的。无效的日期比如0，表示这个资源已经过期了。如果同时设置了Cache-Control响应首部字段的max-age，则Expires会被忽略。它也是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。</p><h3 id="3-Cache-Control"><a href="#3-Cache-Control" class="headerlink" title="3.Cache-Control"></a>3.Cache-Control</h3><p>Cache-Control是一个通用首部字段，也是HTTP/1.1控制浏览器缓存的主流字段。和浏览器缓存相关的是如下几个响应指令：</p><p>指令 参数 说明</p><p>private 无 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）</p><p>public 可省略 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存</p><p>no-cache 可省略 缓存前必需确认其有效性</p><p>no-store 无 不缓存请求或响应的任何内容</p><p>max-age=[s] 必需 响应的最大值</p><p>max-age（单位为s）设置缓存的存在时间，相对于发送请求的时间。只有响应报文首部设置Cache-Control为非0的max-age或者设置了大于请求日期的Expires（下文会讲）才有可能命中强缓存。当满足这个条件，同时响应报文首部中Cache-Control不存在no-cache、no-store且请求报文首部不存在Pragma字段，才会真正命中强缓存。max-age=0相当于no-cache。</p><p>no-cache 表示请求必须先与服务器确认缓存的有效性，如果有效才能使用缓存（协商缓存），无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存。Chrome硬性重新加载（Command+shift+R）会在请求的首部加上Pragma：no-cache和Cache-Control：no-cache。会缓存，但是使用这份缓存之前先到服务器上确认这份缓存是不是最新的，是最新的才使用。</p><p>no-store 表示禁止浏览器以及所有中间缓存存储任何版本的返回响应，一定不会出现强缓存和协商缓存，适合个人隐私数据或者经济类数据。绝对不缓存。</p><p>public 表明响应可以被浏览器、CDN等等缓存。对于public，则允许所有服务器缓存该资源。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），Cache-Control 设为 public 是合理的。</p><p>private 响应只作为私有的缓存，不能被CDN等缓存。如果要求HTTP认证，响应会自动设置为private。如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。</p><h2 id="控制协商缓存的字段："><a href="#控制协商缓存的字段：" class="headerlink" title="控制协商缓存的字段："></a>控制协商缓存的字段：</h2><h3 id="1-Last-Modified-If-Modified-Since"><a href="#1-Last-Modified-If-Modified-Since" class="headerlink" title="1.Last-Modified/If-Modified-Since"></a>1.Last-Modified/If-Modified-Since</h3><p>If-Modified-Since是一个请求首部字段，并且只能用在GET或者HEAD请求中。Last-Modified是一个响应首部字段，包含服务器认定的资源作出修改的日期及时间。当带着If-Modified-Since头访问服务器请求资源时，服务器会检查Last-Modified，如果Last-Modified的时间早于或等于If-Modified-Since则会返回一个不带主体的304响应，否则将重新返回资源。</p><h3 id="2-ETag-If-None-Match"><a href="#2-ETag-If-None-Match" class="headerlink" title="2.ETag/If-None-Match"></a>2.ETag/If-None-Match</h3><p>ETag是一个响应首部字段，它是根据实体内容生成的一段hash字符串，标识资源的状态，由服务端产生。If-None-Match是一个条件式的请求首部。如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的ETag，则当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的200响应，否则服务器会返回不带实体的304响应。ETag优先级比Last-Modified高，同时存在时会以ETag为准。</p><h3 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h3><p>在有效期内更新资源可以用资源加时间戳命名的方式，如下图的<img>。<br>按F5相当于no-cache，按ctrl+f5相当于强制刷新，拉取新资源。</p><h3 id="缓存策略："><a href="#缓存策略：" class="headerlink" title="缓存策略："></a>缓存策略：</h3><h4 id="为静态资源设置长缓存时间"><a href="#为静态资源设置长缓存时间" class="headerlink" title="为静态资源设置长缓存时间"></a>为静态资源设置长缓存时间</h4><p>有些资源是很长时间不会改变的，比如网站的 logo 图片、jQuery 库、字体等，因此可以为它们设定「永不过期」的缓存时间，例如设定为 10 年。</p><h4 id="确保文件修改生效"><a href="#确保文件修改生效" class="headerlink" title="确保文件修改生效"></a>确保文件修改生效</h4><p>有些时候我们会修改一些资源，比如更新了 jQuery 版本，或网站的 CSS 样式。如果这些资源已经被缓存，那么除非用户手工刷新页面，否则要等缓存自然过期之后用户才会获得新版本。如何在这种情况下强制浏览器重新下载呢？最有效的一个办法就是在这类资源的文件名中包含版本信息，并在更改之后对应地修改文件名。浏览器发现文件更换后，自然无法使用缓存，而会重新下载。</p><h4 id="对于-HTML-文档谨慎设定过期时间"><a href="#对于-HTML-文档谨慎设定过期时间" class="headerlink" title="对于 HTML 文档谨慎设定过期时间"></a>对于 HTML 文档谨慎设定过期时间</h4><p>大部分情况下，对于其他图片、CSS、JavaScript 等资源的请求都来自一个单一的 HTML 文档。对于这类页面通常应该设定比较短的过期时间，或者干脆不设定。因为如果这类页面被缓存，那么页面中包含的资源的文件名等等信息都会一并被缓存，导致对它的更新难以确保立即对用户生效。</p><p>html文件用no-cache的方式设置，css,js文件用max-age设置.可以对静态资源进行版本控制（比如给静态资源的文件名加上hash值），其次对网页设置合适时长的缓存时间（长短取决于实际场景）。这样就兼顾了版本升级和性能</p><h4 id="引用静态资源时，不要使用-Query-String"><a href="#引用静态资源时，不要使用-Query-String" class="headerlink" title="引用静态资源时，不要使用 Query String"></a>引用静态资源时，不要使用 Query String</h4><p>Query String 就是例如?key=val的字符串，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;/static/js/func.js?v=a87ff8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>这会阻止一部分较老的浏览器（包括 IE6 ）对该资源进行缓存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。&quot;&gt;&lt;a href=&quot;#Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。&quot; class=&quot;headerlink&quot; title=&quot;Web缓存可以分为这几种
      
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="web缓存" scheme="http://yoursite.com/tags/web%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Three.js开发指南笔记</title>
    <link href="http://yoursite.com/2017/08/12/Three.js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/12/Three.js开发指南笔记/</id>
    <published>2017-08-11T16:00:00.000Z</published>
    <updated>2018-09-25T02:53:47.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-渲染器初始化"><a href="#1-渲染器初始化" class="headerlink" title="1.渲染器初始化"></a>1.渲染器初始化</h2><p>渲染器将和Canvas元素进行绑定，如果之前在HTML中手动定义了id为mainCanvas的Canvas元素，那么Renderer可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var renderer = new THREE.WebGLRenderer(&#123;</span><br><span class="line">    canvas: document.getElementById(&apos;mainCanvas&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而如果想要Three.js生成Canvas元素，在HTML中就不需要定义Canvas元素，在JavaScript代码中可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var renderer = new THREE.WebGLRenderer();</span><br><span class="line">renderer.setSize(400, 300);</span><br><span class="line">document.getElementsByTagName(&apos;body&apos;)[0].appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure><p>背景色（清除色）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.setClearColor(0x000000);</span><br></pre></td></tr></table></figure></p><h2 id="2-场景相关API"><a href="#2-场景相关API" class="headerlink" title="2.场景相关API"></a>2.场景相关API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scene.add();    //添加东西</span><br><span class="line">scene.remove();    //移除东西</span><br><span class="line">scene.children();    //获取场景中所有子对象</span><br><span class="line">scene.getChildByName();    //利用name属性，获取场景中某个特定物体</span><br><span class="line">scene.traverse();   //参数接受一个函数，场景中每个子对象都会执行的，相当于forEach</span><br><span class="line"></span><br><span class="line">scene.fog = new THREE.Fog(0xffffff,0.015,100);  //雾化(两个参数时1是雾的颜色，2是雾的浓度；三个参数时1是雾的颜色，2是near值，3是far值)</span><br><span class="line"></span><br><span class="line">scene.overrideMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;);   //设置场景中所有物体的材质</span><br></pre></td></tr></table></figure><h2 id="3-正交投影vs透视投影"><a href="#3-正交投影vs透视投影" class="headerlink" title="3.正交投影vs透视投影"></a>3.正交投影vs透视投影</h2><p>使用透视投影照相机获得的结果是类似人眼在真实世界中看到的有“近大远小”的效果；而使用正交投影照相机获得的结果就像我们在数学几何学课上老师教我们画的效果，对于在三维空间内平行的线，投影到二维空间中也一定是平行的。</p><p>一般说来，对于制图、建模软件通常使用正交投影，这样不会因为投影而改变物体比例；而对于其他大多数应用，通常使用透视投影，因为这更接近人眼的观察效果。</p><h2 id="4-正交投影照相机"><a href="#4-正交投影照相机" class="headerlink" title="4.正交投影照相机"></a>4.正交投影照相机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.OrthographicCamera(left, right, top, bottom, near, far)</span><br></pre></td></tr></table></figure><p>这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，这六个面围成一个长方体，我们称其为视景体（Frustum）。只有在视景体内部（下图中的灰色部分）的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉。</p><p>为了保持照相机的横竖比例，需要保证(right - left)与(top - bottom)的比例与Canvas宽度与高度的比例一致。</p><p>near与far都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般near的值设置得较小，far的值设置得较大，具体值视场景中物体的位置等决定。</p><p><img src="http://www.ituring.com.cn/download/01YiZI4zr57Q.small" alt="camera"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//分别设置照相机的x,y,z位置</span><br><span class="line">camera.position.set(0,0,5);</span><br></pre></td></tr></table></figure><p>另外，因为照相机默认是看向z的负方向，所以要想照相机往其他方向看，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这样照相机就会看着(0,0,0)这个点（无论照相机在哪个位置）</span><br><span class="line">camera.lookAt(new THREE.Vector3(0,0,0));</span><br></pre></td></tr></table></figure><h2 id="5-透视投影照相机"><a href="#5-透视投影照相机" class="headerlink" title="5.透视投影照相机"></a>5.透视投影照相机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.PerspectiveCamera(fov, aspect, near, far);</span><br><span class="line">var camera = new THREE.PerspectiveCamera(45, 400 / 300, 1, 10);</span><br></pre></td></tr></table></figure><p><img src="http://www.ituring.com.cn/download/01YYrMaASOzm.small" alt="camera"></p><p>透视图中，灰色的部分是视景体，是可能被渲染的物体所在的区域。fov是视景体竖直方向上的张角（是角度制而非弧度制），如侧视图所示。</p><p>aspect等于width / height，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。</p><p>near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near。</p><h2 id="6-立方体"><a href="#6-立方体" class="headerlink" title="6.立方体"></a>6.立方体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)</span><br></pre></td></tr></table></figure><p>width是x方向上的长度；height是y方向上的长度；depth是z方向上的长度；后三个参数分别是在三个方向上的分段数，如widthSegments为3的话，代表x方向上水平分为三份。一般情况下不需要分段的话，可以不设置后三个参数，后三个参数的缺省值为1。其他几何形状中的分段也是类似的，下面不做说明。</p><h2 id="7-平面"><a href="#7-平面" class="headerlink" title="7.平面"></a>7.平面</h2><p>这里的平面（PlaneGeometry）其实是一个长方形，而不是数学意义上无限大小的平面。其构造函数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.PlaneGeometry(width, height, widthSegments, heightSegments)</span><br></pre></td></tr></table></figure></p><p>其中，width是x方向上的长度；height是y方向上的长度；后两个参数同样表示分段。</p><h2 id="8-球体"><a href="#8-球体" class="headerlink" title="8.球体"></a>8.球体</h2><p>其中，radius是半径；segmentsWidth表示经度上的切片数；segmentsHeight表示纬度上的切片数；phiStart表示经度开始的弧度；phiLength表示经度跨过的弧度；thetaStart表示纬度开始的弧度；thetaLength表示纬度跨过的弧度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure><h2 id="9-圆形"><a href="#9-圆形" class="headerlink" title="9.圆形"></a>9.圆形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure><h2 id="10-圆柱体"><a href="#10-圆柱体" class="headerlink" title="10.圆柱体"></a>10.圆柱体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)</span><br></pre></td></tr></table></figure><p>其中，radiusTop与radiusBottom分别是顶面和底面的半径，由此可知，当这两个参数设置为不同的值时，实际上创建的是一个圆台；height是圆柱体的高度；radiusSegments与heightSegments可类比球体中的分段；openEnded是一个布尔值，表示是否没有顶面和底面，缺省值为false，表示有顶面和底面。</p><h2 id="11-正n面体"><a href="#11-正n面体" class="headerlink" title="11.正n面体"></a>11.正n面体</h2><p>正四面体（TetrahedronGeometry）、正八面体（OctahedronGeometry）、正二十面体（IcosahedronGeometry）的构造函数较为类似，分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">THREE.TetrahedronGeometry(radius, detail)</span><br><span class="line">THREE.OctahedronGeometry(radius, detail)</span><br><span class="line">THREE.IcosahedronGeometry(radius, detail)</span><br></pre></td></tr></table></figure><p>其中，radius是半径；detail是细节层次（Level of Detail）的层数，对于大面片数模型，可以控制在视角靠近物体时，显示面片数多的精细模型，而在离物体较远时，显示面片数较少的粗略模型。这里我们不对detail多作展开，一般可以对这个值缺省。</p><h2 id="12-圆环面"><a href="#12-圆环面" class="headerlink" title="12.圆环面"></a>12.圆环面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc)</span><br></pre></td></tr></table></figure><p>其中，radius是圆环半径；tube是管道半径；radialSegments与tubularSegments分别是两个分段数，详见上图；arc是圆环面的弧度，缺省值为Math.PI * 2。</p><p><img src="http://www.ituring.com.cn/download/01YZGqQBQI0k" alt="pt"></p><h2 id="13-圆环结"><a href="#13-圆环结" class="headerlink" title="13.圆环结"></a>13.圆环结</h2><p>如果说圆环面是甜甜圈，那么圆环结（TorusKnotGeometry）就是打了结的甜甜圈，其构造参数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments, p, q, heightScale)</span><br></pre></td></tr></table></figure></p><p>前四个参数在圆环面中已经有所介绍，p和q是控制其样式的参数，一般可以缺省，如果需要详细了解，请学习圆环结的相关知识；heightScale是在z轴方向上的缩放。</p><h2 id="14-文字形状"><a href="#14-文字形状" class="headerlink" title="14.文字形状"></a>14.文字形状</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TextGeometry(text, parameters);</span><br></pre></td></tr></table></figure><p>其中，text是文字字符串，parameters是以下参数组成的对象：</p><p>size：字号大小，一般为大写字母的高度</p><p>height：文字的厚度</p><p>curveSegments：弧线分段数，使得文字的曲线更加光滑</p><p>font：字体，默认是’helvetiker’，需对应引用的字体文件</p><p>weight：值为’normal’或’bold’，表示是否加粗</p><p>style：值为’normal’或’italics’，表示是否斜体</p><p>bevelEnabled：布尔值，是否使用倒角，意为在边缘处斜切</p><p>bevelThickness：倒角厚度</p><p>bevelSize：倒角宽度</p><p>ps:加载字体示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.FontLoader();</span><br><span class="line">loader.load(&apos;../lib/helvetiker_regular.typeface.json&apos;, function(font) &#123;</span><br><span class="line">    var mesh = new THREE.Mesh(new THREE.TextGeometry(&apos;Hello&apos;, &#123;</span><br><span class="line">        font: font,</span><br><span class="line">        size: 1,</span><br><span class="line">        height: 1</span><br><span class="line">    &#125;), material);</span><br><span class="line">    scene.add(mesh);</span><br><span class="line"></span><br><span class="line">    // render</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="15-自定义形状"><a href="#15-自定义形状" class="headerlink" title="15.自定义形状"></a>15.自定义形状</h2><p>由于自定义形状需要手动指定每个顶点位置，以及顶点连接情况，如果该形状非常复杂，程序员的计算量就会比较大。在这种情况下，建议在3ds Max之类的建模软件中创建模型，然后使用Three.js导入到场景中，这样会更高效方便。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 初始化几何形状</span><br><span class="line">var geometry = new THREE.Geometry();</span><br><span class="line"></span><br><span class="line">// 设置顶点位置</span><br><span class="line">// 顶部4顶点</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-1, 2, -1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(1, 2, -1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(1, 2, 1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-1, 2, 1));</span><br><span class="line">// 底部4顶点</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-2, 0, -2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(2, 0, -2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(2, 0, 2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-2, 0, 2));</span><br><span class="line"></span><br><span class="line">// 设置顶点连接情况</span><br><span class="line">// 顶面</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 1, 3));</span><br><span class="line">geometry.faces.push(new THREE.Face3(1, 2, 3));</span><br><span class="line">// 底面</span><br><span class="line">geometry.faces.push(new THREE.Face3(4, 5, 6));</span><br><span class="line">geometry.faces.push(new THREE.Face3(5, 6, 7));</span><br><span class="line">// 四个侧面</span><br><span class="line">geometry.faces.push(new THREE.Face3(1, 5, 6));</span><br><span class="line">geometry.faces.push(new THREE.Face3(6, 2, 1));</span><br><span class="line">geometry.faces.push(new THREE.Face3(2, 6, 7));</span><br><span class="line">geometry.faces.push(new THREE.Face3(7, 3, 2));</span><br><span class="line">geometry.faces.push(new THREE.Face3(3, 7, 0));</span><br><span class="line">geometry.faces.push(new THREE.Face3(7, 4, 0));</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 4, 5));</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 5, 1));</span><br></pre></td></tr></table></figure></p><p>需要注意的是，new THREE.Vector3(-1, 2, -1)创建一个矢量，作为顶点位置追加到geometry.vertices数组中。</p><p>而由new THREE.Face3(0, 1, 3)创建一个三个顶点组成的面片，追加到geometry.faces数组中。三个参数分别是四个顶点在geometry.vertices中的序号。</p><h2 id="16-简单材质"><a href="#16-简单材质" class="headerlink" title="16.简单材质"></a>16.简单材质</h2><h3 id="1-基础材质"><a href="#1-基础材质" class="headerlink" title="1.基础材质"></a>1.基础材质</h3><p>对于基本材质，即使改变场景中的光源，使用该材质的物体也始终为颜色处处相同的效果。当然，这不是很具有真实感。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    color: 0xffff00,</span><br><span class="line">    opacity: 0.75</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可以设置以下属性：</p><p>visible：是否可见，默认为true</p><p>side：渲染面片正面或是反面，默认为正面THREE.FrontSide，可设置为反面THREE.BackSide，或双面THREE.DoubleSide</p><p>wireframe：是否渲染线而非面，默认为false</p><p>color：十六进制RGB颜色，如红色表示为0xff0000</p><p>map：使用纹理贴图</p><h3 id="2-深度材质"><a href="#2-深度材质" class="headerlink" title="2.深度材质"></a>2.深度材质</h3><p>其外观不由光照或某个材质属性决定，而是由物体到相机的距离决定。</p><p>可以将这种材质与其他材质相结合，很容易创建出逐渐消失的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var depthMaterial = new THREE.MeshDepthMaterial();</span><br><span class="line">depthMaterial.wireframe = true;  //是否显示线框</span><br><span class="line">depthMaterial.wireframeLineWidth = 10;  //线框线的宽度</span><br></pre></td></tr></table></figure><h3 id="3-联合材质"><a href="#3-联合材质" class="headerlink" title="3.联合材质"></a>3.联合材质</h3><p>把材质结合起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cube = new THREE.SceneUtils.createMultiMaterialObject(geometry,[basicMaterial,depthMaterial]);</span><br></pre></td></tr></table></figure><h3 id="4-每个面材质"><a href="#4-每个面材质" class="headerlink" title="4.每个面材质"></a>4.每个面材质</h3><p>相当于一个材质容器，为几何体每一个面制定不同的材质</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var matArray = [</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0x009e60&#125;),</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0x0051ba&#125;),</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0xffd500&#125;),</span><br><span class="line">];</span><br><span class="line">var faceMaterial = new THREE.MeshFaceMaterial(matArray);</span><br></pre></td></tr></table></figure><p>ps:要创建一种透明的材质，仅仅设置opacity:0是不够的，还要将transparent设为0。为一个几何体赋予多种材质会复制几何体，从而创建出多个网格。</p><h2 id="17-Lambert材质"><a href="#17-Lambert材质" class="headerlink" title="17.Lambert材质"></a>17.Lambert材质</h2><p>Lambert材质（MeshLambertMaterial）是符合Lambert光照模型的材质。Lambert光照模型的主要特点是只考虑漫反射而不考虑镜面反射的效果，因而对于金属、镜子等需要镜面反射效果的物体就不适应，对于其他大部分物体的漫反射效果都是适用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xffff00</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>color是用来表现材质对散射光的反射能力，也是最常用来设置材质颜色的属性。除此之外，还可以用ambient和emissive控制材质的颜色。</p><p>ambient表示对环境光的反射能力，只有当设置了AmbientLight后，该值才是有效的，材质对环境光的反射能力与环境光强相乘后得到材质实际表现的颜色。</p><p>emissive是材质的自发光颜色，可以用来表现光源的颜色。</p><h2 id="18-Phong材质"><a href="#18-Phong材质" class="headerlink" title="18.Phong材质"></a>18.Phong材质</h2><p>Phong材质（MeshPhongMaterial）是符合Phong光照模型的材质。和Lambert不同的是，Phong模型考虑了镜面反射的效果，因此对于金属、镜面的表现尤为适合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">material = new THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color: 0xff0000,</span><br><span class="line">    specular: 0xffff00,</span><br><span class="line">    shininess: 100</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同样地，可以指定emissive和ambient值，这里不再说明。</p><p>可以通过shininess属性控制光照模型中的n值，当shininess值越大时，高光的光斑越小，默认值为30。</p><h2 id="19-法向材质"><a href="#19-法向材质" class="headerlink" title="19.法向材质"></a>19.法向材质</h2><p>法向材质可以将材质的颜色设置为其法向量的方向，有时候对于调试很有帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshNormalMaterial()</span><br></pre></td></tr></table></figure><p>材质的颜色与照相机与该物体的角度相关，我们只改变照相机位置，就可以观察两个角度的颜色变化。</p><h2 id="20-材质的纹理贴图"><a href="#20-材质的纹理贴图" class="headerlink" title="20.材质的纹理贴图"></a>20.材质的纹理贴图</h2><p>导入图像作为纹理贴图，并添加到相应的材质中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//单张图像应用于长方体</span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;);</span><br><span class="line"></span><br><span class="line">var material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    map: texture</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//可以用回调函数的方式来命令渲染：</span><br><span class="line"></span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;, &#123;&#125;, function() &#123;</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br><span class="line">var material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    map: texture</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>六个面应用不同的图像示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var materials = [];</span><br><span class="line">for (var i = 0; i &lt; 6; ++i) &#123;</span><br><span class="line">    materials.push(new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">        map: THREE.ImageUtils.loadTexture(&apos;../img/&apos; + i + &apos;.png&apos;,</span><br><span class="line">                &#123;&#125;, function() &#123;</span><br><span class="line">                    renderer.render(scene, camera);</span><br><span class="line">                &#125;),</span><br><span class="line">        overdraw: true</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cube = new THREE.Mesh(new THREE.CubeGeometry(5, 5, 5),</span><br><span class="line">        new THREE.MeshFaceMaterial(materials));</span><br><span class="line">scene.add(cube);</span><br></pre></td></tr></table></figure></p><p>棋盘格（复制渲染）：</p><p>原图片：<br><img src="http://www.ituring.com.cn/download/01YdRC86nAUx" alt="pt"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//导入材质</span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/chess.png&apos;, &#123;&#125;, function() &#123;</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可是，棋盘格是8横8纵64个小方格组成的，那应该怎么办呢？</span><br><span class="line"></span><br><span class="line">//首先，我们需要指定重复方式为两个方向（wrapS和wrapT）都重复：</span><br><span class="line">texture.wrapS = texture.wrapT = THREE.RepeatWrapping;</span><br><span class="line"></span><br><span class="line">//然后，设置两个方向上都重复4次，由于我们的图像本来是有2行2列，所以重复4次即为8行8列：</span><br><span class="line">texture.repeat.set(4, 4);</span><br></pre></td></tr></table></figure><p>最后就得到了棋盘格：<br><img src="http://www.ituring.com.cn/download/01YdRCMAK2Xq" alt="pt"></p><h2 id="21-网格"><a href="#21-网格" class="headerlink" title="21.网格"></a>21.网格</h2><p>而网格的创建非常简单，只要把几何形状与材质传入其构造函数。最常用的物体是网格（Mesh），它代表包含点、线、面的几何体，其构造函数是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mesh = new THREE.Mesh(geometry, material);</span><br></pre></td></tr></table></figure></p><p>在网格被创建后，也能对材质进行修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xff0000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>位置、缩放、旋转:</p><p>位置、缩放、旋转是物体三个常用属性。由于THREE.Mesh基础自THREE.Object3D，因此包含scale、rotation、position三个属性。它们都是THREE.Vector3实例，因此修改其值的方法是相同的，这里以位置为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.position.z = 1;</span><br><span class="line">或</span><br><span class="line">mesh.position.set(1.5, -0.5, 0);</span><br></pre></td></tr></table></figure><h2 id="22-动画"><a href="#22-动画" class="headerlink" title="22.动画"></a>22.动画</h2><p>setInterval方法与requestAnimationFrame方法的区别较为微妙。一方面，最明显的差别表现在setInterval可以手动设定FPS，而requestAnimationFrame则会自动设定FPS；但另一方面，即使是setInterval也不能保证按照给定的FPS执行，在浏览器处理繁忙时，很可能低于设定值。当浏览器达不到设定的调用周期时，requestAnimationFrame采用跳过某些帧的方式来表现动画，虽然会有卡滞的效果但是整体速度不会拖慢，而setInterval会因此使整个程序放慢运行，但是每一帧都会绘制出来；</p><p>总而言之，requestAnimationFrame适用于对于时间较为敏感的环境（但是动画逻辑更加复杂），而setInterval则可在保证程序的运算不至于导致延迟的情况下提供更加简洁的逻辑（无需自行处理时间）。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">    mesh.rotation.y = (mesh.rotation.y + 0.01) % (Math.PI * 2);</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">    id = requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ps:可以使用stat.js记录FPS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stats.setMode(0);//监测FPS</span><br><span class="line">stats.setMode(1);//监测渲染时间</span><br></pre></td></tr></table></figure><p>详情请见：(使用stat.js记录FPS)[<a href="http://www.ituring.com.cn/book/miniarticle/53353]" target="_blank" rel="noopener">http://www.ituring.com.cn/book/miniarticle/53353]</a></p><h2 id="23-外部导入"><a href="#23-外部导入" class="headerlink" title="23.外部导入"></a>23.外部导入</h2><p>Three.js有一系列导入外部文件的辅助函数，是在three.js之外的，使用前需要额外下载，在(loaders)[<a href="https://github.com/mrdoob/three.js/tree/master/examples/js/loaders]可以找到。" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders]可以找到。</a></p><p>.obj是最常用的模型格式，导入.obj文件需要OBJLoader.js；</p><p>导入带.mtl材质的.obj文件需要MTLLoader.js以及OBJMTLLoader.js。另有PLYLoader.js、STLLoader.js等分别对应不同格式的加载器，可以根据模型格式自行选择。</p><p>导入过程：<a href="http://www.ituring.com.cn/book/miniarticle/53865" target="_blank" rel="noopener">无材质的模型</a><br>         <a href="http://www.ituring.com.cn/book/miniarticle/53881" target="_blank" rel="noopener">有材质的模型</a></p><h2 id="24-环境光"><a href="#24-环境光" class="headerlink" title="24.环境光"></a>24.环境光</h2><p>环境光是指场景整体的光照效果，是由于场景内若干光源的多次反射形成的亮度一致的效果，通常用来为整个场景指定一个基础亮度。因此，环境光没有明确的光源位置，在各处形成的亮度也是一致的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var light = new THREE.AmbientLight(0xffffff);</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure></p><p>环境光并不在乎物体材质的color属性，而是在乎ambient属性。ambient属性的默认值是0xffffff。</p><p>ambient为0x00ff00的长方体被渲染成了黑色。这是因为不透明物体的颜色其实是其反射光的颜色，而ambient属性表示的是物体反射环境光的能力。对于0x00ff00的物体，红色通道是0，而环境光是完全的红光，因此该长方体不能反射任何光线，最终的渲染颜色就是黑色；而对于0xffffff的白色长方体，红色通道是0xff，因而能反射所有红光，渲染的颜色就是红色。</p><p>前面我们看到，当环境光不是白色或灰色的时候，渲染的效果往往会很奇怪。因此，环境光通常使用白色或者灰色，作为整体光照的基础。</p><h2 id="25-点光源"><a href="#25-点光源" class="headerlink" title="25.点光源"></a>25.点光源</h2><p>点光源是不计光源大小，可以看作一个点发出的光源。点光源照到不同物体表面的亮度是线性递减的，因此，离点光源距离越远的物体会显得越暗。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">THREE.PointLight(hex, intensity, distance);</span><br><span class="line"></span><br><span class="line">//应用示例：</span><br><span class="line"></span><br><span class="line">var light = new THREE.PointLight(0xffffff, 2, 100);</span><br><span class="line">light.color = &quot;#ccffcc&quot;;    //设置光源颜色</span><br><span class="line">light.intensity = 1;    //光的强度</span><br><span class="line">light.position.set(0, 1.5, 2);  //设置光源位置</span><br><span class="line">light.distance = 100;   //光源照射距离（默认为0，也就是说光线亮度不会随着距离增加而递减）</span><br><span class="line">light.visible = true;   //光源是否开启</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure><p>其中，hex是光源十六进制的颜色值；intensity是亮度，缺省值为1，表示100%亮度；distance是光源最远照射到的距离，缺省值为0。</p><h2 id="26-平行光"><a href="#26-平行光" class="headerlink" title="26.平行光"></a>26.平行光</h2><p>我们都知道，太阳光常常被看作平行光，这是因为相对地球上物体的尺度而言，太阳离我们的距离足够远。对于任意平行的平面，平行光照射的亮度都是相同的，而与平面所在位置无关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">THREE.DirectionalLight(hex, intensity);</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">var light = new THREE.DirectionalLight();</span><br><span class="line">light.position.set(2, 5, 3);</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure><p>注意，这里设置光源位置并不意味着所有光从(2, 5, 3)点射出（如果是的话，就成了点光源），而是意味着，平行光将以矢量(-2, -5, -3)的方向照射到所有平面。因此，平面亮度与平面的位置无关，而只与平面的法向量相关。只要平面是平行的，那么得到的光照也一定是相同的。</p><h2 id="27-聚光灯"><a href="#27-聚光灯" class="headerlink" title="27.聚光灯"></a>27.聚光灯</h2><p>可以看出，聚光灯是一种特殊的点光源，它能够朝着一个方向投射光线。聚光灯投射出的是类似圆锥形的光线，这与我们现实中看到的聚光灯是一致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.SpotLight(hex, intensity, distance, angle, exponent)</span><br></pre></td></tr></table></figure><p>相比点光源，多了angle和exponent两个参数。angle是聚光灯的张角，缺省值是Math.PI / 3，最大值是Math.PI / 2；exponent是光强在偏离target的衰减指数（target需要在之后定义，缺省值为(0, 0, 0)），缺省值是10。</p><p>在调用构造函数之后，除了设置光源本身的位置，一般还需要设置target：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">light.position.set(x1, y1, z1);</span><br><span class="line">light.target.position.set(x2, y2, z2);</span><br></pre></td></tr></table></figure><p>除了设置light.target.position的方法外，如果想让聚光灯跟着某一物体移动（就像真的聚光灯！），可以target指定为该物体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),</span><br><span class="line">                    new THREE.MeshLambertMaterial(&#123;color: 0x00ff00&#125;));</span><br><span class="line"></span><br><span class="line">var light = new THREE.SpotLight(0xffff00, 1, 100, Math.PI / 6, 25);</span><br><span class="line">light.target = cube;</span><br></pre></td></tr></table></figure><h2 id="28-半球光"><a href="#28-半球光" class="headerlink" title="28.半球光"></a>28.半球光</h2><p>创建出更加贴近自然的户外光照效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var hemiLight = new THREE.HemisphereLight(0x0000ff,0x00ff00,0.6);   //参数分别是天空发出的颜色、地面发出的颜色、光线照射强度</span><br><span class="line"></span><br><span class="line">hemiLight.position.set(0,500,0);</span><br><span class="line">scene.add(hemiLight);</span><br></pre></td></tr></table></figure><h2 id="29-平面光（略）"><a href="#29-平面光（略）" class="headerlink" title="29.平面光（略）"></a>29.平面光（略）</h2><p>定义一个发光的矩形</p><h2 id="30-镜头眩光"><a href="#30-镜头眩光" class="headerlink" title="30.镜头眩光"></a>30.镜头眩光</h2><p>当你直接朝着太阳拍照时就会出现镜头眩光</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var lensFlare = new THREE.LensFlare(texture,350,0.5,THREE.AdditiveBlending,flareColor);</span><br><span class="line">//参数分别是眩光的材质，眩光尺寸(-1就表示用材质本身的尺寸)，光源(0)到相机(1)的距离，融合模式，颜色</span><br><span class="line"></span><br><span class="line">lensFlare.add(texture,60,0.6,THREE.AdditiveBlending);</span><br><span class="line">//增加眩光</span><br></pre></td></tr></table></figure><h2 id="31-阴影"><a href="#31-阴影" class="headerlink" title="31.阴影"></a>31.阴影</h2><p>在Three.js中，能形成阴影的光源只有THREE.DirectionalLight与THREE.SpotLight；而相对地，能表现阴影效果的材质只有THREE.LambertMaterial与THREE.PhongMaterial。因而在设置光源和材质的时候，一定要注意这一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//首先，我们需要在初始化时，告诉渲染器渲染阴影：</span><br><span class="line">renderer.shadowMapEnabled = true;</span><br><span class="line"></span><br><span class="line">//然后，对于光源以及所有要产生阴影的物体调用：</span><br><span class="line">xxx.castShadow = true;</span><br><span class="line"></span><br><span class="line">//对于接收阴影的物体调用：</span><br><span class="line">xxx.receiveShadow = true;</span><br></pre></td></tr></table></figure><p>对于聚光灯，需要设置shadowCameraNear、shadowCameraFar、shadowCameraFov三个值，类比我们在第二章学到的透视投影照相机，只有介于shadowCameraNear与shadowCameraFar之间的物体将产生阴影，shadowCameraFov表示张角。</p><p>对于平行光，需要设置shadowCameraNear、shadowCameraFar、shadowCameraLeft、shadowCameraRight、shadowCameraTop以及shadowCameraBottom六个值，相当于正交投影照相机的六个面。同样，只有在这六个面围成的长方体内的物体才会产生阴影效果。</p><p>为了看到阴影照相机的位置，通常可以在调试时开启light.shadowCameraVisible = true。</p><p>至此，阴影效果已经能正常显示了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">light.shadowCameraNear = 2;</span><br><span class="line">light.shadowCameraFar = 10;</span><br><span class="line">light.shadowCameraFov = 30;</span><br><span class="line">light.shadowCameraVisible = true;</span><br><span class="line"></span><br><span class="line">light.shadowMapWidth = 1024;</span><br><span class="line">light.shadowMapHeight = 1024;</span><br><span class="line">light.shadowDarkness = 0.3;</span><br></pre></td></tr></table></figure><h2 id="32-通过拉伸创建几何体"><a href="#32-通过拉伸创建几何体" class="headerlink" title="32.通过拉伸创建几何体"></a>32.通过拉伸创建几何体</h2><p>把二维图形拉伸成三维图形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//沿着Z轴拉伸</span><br><span class="line">var options = &#123;</span><br><span class="line">    amount:10,//图形可以拉多高</span><br><span class="line">    bevelThickness:2,//斜角厚度</span><br><span class="line">    bevelSize:1,//斜角尺寸</span><br><span class="line">    bevelSegments:3,//斜角分段数</span><br><span class="line">    bevelEnabled:true,//是否用斜角</span><br><span class="line">    curveSegments:12,//曲线分段数</span><br><span class="line">    steps:1//拉伸体段数</span><br><span class="line">&#125;;</span><br><span class="line">shape = createMesh(new THREE.ExtrudeGeometry(drawShape(),options));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//SVG图像2d变3d</span><br><span class="line">function drawShape()&#123;</span><br><span class="line">    var svgStr = $(&apos;#svg1&apos;).attr(&apos;d&apos;);</span><br><span class="line">    var shape = transformSVGPathExposed(svgStr);    //transformSVGPathExposed这个函数是d3-ThreeD库提供的</span><br><span class="line">    return shape;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var options = &#123;</span><br><span class="line">    amount:10,//图形可以拉多高</span><br><span class="line">    bevelThickness:2,//斜角厚度</span><br><span class="line">    bevelSize:1,//斜角尺寸</span><br><span class="line">    bevelSegments:3,//斜角分段数</span><br><span class="line">    bevelEnabled:true,//是否用斜角</span><br><span class="line">    curveSegments:12,//曲线分段数</span><br><span class="line">    steps:1//拉伸体段数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">shape = createMesh(new THREE.ExtrudeGeometry(drawShape(),options));</span><br></pre></td></tr></table></figure><h2 id="33-粒子"><a href="#33-粒子" class="headerlink" title="33.粒子"></a>33.粒子</h2><h2 id="34-相机控件（详情参见THREE-JS开发指南p181）"><a href="#34-相机控件（详情参见THREE-JS开发指南p181）" class="headerlink" title="34.相机控件（详情参见THREE.JS开发指南p181）"></a>34.相机控件（详情参见THREE.JS开发指南p181）</h2><h2 id="35-为物品添加多种材质"><a href="#35-为物品添加多种材质" class="headerlink" title="35.为物品添加多种材质"></a>35.为物品添加多种材质</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mesh = THREE.SceneUtils.createMultiMaterialObject(geometry,materials);</span><br><span class="line">//参数1是几何体，参数2是一个包含多个材质对象的数组</span><br></pre></td></tr></table></figure><h2 id="36-着色器（略）"><a href="#36-着色器（略）" class="headerlink" title="36.着色器（略）"></a>36.着色器（略）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-渲染器初始化&quot;&gt;&lt;a href=&quot;#1-渲染器初始化&quot; class=&quot;headerlink&quot; title=&quot;1.渲染器初始化&quot;&gt;&lt;/a&gt;1.渲染器初始化&lt;/h2&gt;&lt;p&gt;渲染器将和Canvas元素进行绑定，如果之前在HTML中手动定义了id为mainCanvas
      
    
    </summary>
    
      <category term="three.js" scheme="http://yoursite.com/categories/three-js/"/>
    
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>web性能优化</title>
    <link href="http://yoursite.com/2017/08/05/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/08/05/web性能优化/</id>
    <published>2017-08-04T16:00:00.000Z</published>
    <updated>2018-10-04T14:18:05.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web性能优化"><a href="#web性能优化" class="headerlink" title="web性能优化"></a>web性能优化</h3><h3 id="一、资源加载"><a href="#一、资源加载" class="headerlink" title="一、资源加载"></a>一、资源加载</h3><ol><li><p>CDN（存放静态资源的CDN域名和主域名要不一样，因为这便于CDN业务独立，能够独立配置缓存，抛开无用cookie，减小带宽占用。CDN域名与主站域名不同，DNS解析CDN域名还需要花费额外的时间，增加网络延迟。不过可以用DNS Prefetch。）</p></li><li><p>减少http请求</p></li><li><p>图像优化（不要在HTML里缩放图像，雪碧图，字体图标，使用WebP）</p></li><li><p>将 CSS 样式放在页面的上方，将脚本移动到底部（包括内联的）</p></li><li><p>可以给 JavaScript 加上 async 标记，表示 JavaScript 的执行不会读取 DOM ，JavaScript 可以不被 CSS 阻塞，可以在空闲时间立刻执行。（正常来说在浏览器没有下载并解析完成使用 link 引入的 CSS 文件之前，JavaScript 是不会执行的）（defer 跟 async 非常相似，不会阻塞页面加载，但会等到 HTML 完成解析后再执行，并且会按出现的次序执行。）</p></li><li><p>预加载，预渲染：<br><a href="http://web.jobbole.com/84256/" target="_blank" rel="noopener">资源预加载</a>，<a href="https://mp.weixin.qq.com/s?__biz=MzUxMTcwOTM4Mg==&amp;mid=2247484163&amp;idx=1&amp;sn=16b9c907971683dd61cee251adcde79b&amp;chksm=f96edaaace1953bcaf65a1adcf30b6d3dd66cf7b648ae59c4bf807d3f8bf460d5cd638e54ca1&amp;token=946370022&amp;lang=zh_CN#rd" target="_blank" rel="noopener">有一种优化，叫Preload</a></p></li><li><p>懒加载</p></li><li><p>合理使用缓存，localstorage,sessionstorage</p></li><li><p>启用Http2</p></li><li><p>service workers做离线缓存</p></li></ol><hr><h3 id="二、文件体积"><a href="#二、文件体积" class="headerlink" title="二、文件体积"></a>二、文件体积</h3><ol><li><p>Gzip（不要对图片文件进行Gzip压缩！适得其反）</p></li><li><p>webpack打包优化<br><img src="/2017/08/05/web性能优化/1.jpg" alt="web性能优化"><br><img src="/2017/08/05/web性能优化/2.jpg" alt="web性能优化"></p></li></ol><hr><h3 id="三、浏览器渲染运行"><a href="#三、浏览器渲染运行" class="headerlink" title="三、浏览器渲染运行"></a>三、浏览器渲染运行</h3><ol><li><p>WebAssembly（体积小，解析时间短，更接近于机器码执行快，类型是确定的因此不需要JIT作重优化，垃圾回收是手动的）</p></li><li><p>防抖和节流</p></li><li><p>减少 DOM 操作的次数，避免不必要的重排和重绘</p></li><li><p>动画合理使用translate3d,opacity来启用单独图层渲染，硬件加速</p></li><li><p>使用 requestAnimationFrame 来更新页面</p></li><li><p>各种组件，例如轮播图。请等页面加载完毕20ms后再渲染，提升用户体验。</p></li><li><p>通过切换class或者使用元素的style.csstext属性去批量操作元素样式。</p></li><li><p>图片在渲染前指定大小：因为img元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。</p></li></ol><hr><h3 id="四、代码编写优化"><a href="#四、代码编写优化" class="headerlink" title="四、代码编写优化"></a>四、代码编写优化</h3><ol><li><p>CSS不要过多使用*，因为他的选择器匹配原则是从右到左</p></li><li><p>避免过多的css表达式，例如width=3*4px</p></li><li><p>避免js重复脚本。尽量少建立变量，耗费内存空间</p></li><li><p>eslint统一风格，优化代码结构</p></li></ol><hr><h3 id="五、服务器端"><a href="#五、服务器端" class="headerlink" title="五、服务器端"></a>五、服务器端</h3><ol><li><p>负载均衡，nginx搭建反向代理</p></li><li><p>Node.js处理IO密集型请求</p></li></ol><hr><h3 id="六、前端框架优化："><a href="#六、前端框架优化：" class="headerlink" title="六、前端框架优化："></a>六、前端框架优化：</h3><ol><li><p>按需加载，异步组件，组件懒加载</p></li><li><p>骨架屏，做必要的加载错误提示和必要的loading框</p></li><li><p>同构，服务端渲染</p></li><li><p>使用 prerender-spa-plugin 预渲染首屏（先指定 dist 目录和要渲染的路径。插件在 dist 目录中开启一个静态服务器，并且使用无头浏览器（puppeteer）访问对应的路径，执行 JS，抓取对应路径的 html。把抓到的内容写入 html，这样即使没有做服务器端渲染，也能达到跟服务器端渲染几乎相同的作用（不考虑动态数据的话））</p></li><li><p>使用动态 polyfill</p></li><li><p>线上引入生产环境的 Vue 文件、React文件</p></li><li><p>提取组件的 CSS 到单独到文件。当使用单文件组件时，组件内的 CSS 会以style标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，将所有组件的 CSS提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存</p></li><li><p>扁平化 Store 数据结构，data不宜嵌套过深</p></li><li><p>react用pure-component做componentShouldUpdate的优化</p></li><li><p>Vue可以利用Object.freeze()提升性能。Vue 在遇到像 Object.freeze() 这样被设置为不可配置之后的对象属性时，不会为对象加上 setter getter 等数据劫持的方法</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;web性能优化&quot;&gt;&lt;a href=&quot;#web性能优化&quot; class=&quot;headerlink&quot; title=&quot;web性能优化&quot;&gt;&lt;/a&gt;web性能优化&lt;/h3&gt;&lt;h3 id=&quot;一、资源加载&quot;&gt;&lt;a href=&quot;#一、资源加载&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码学习——笔记</title>
    <link href="http://yoursite.com/2017/08/02/jQuery%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/02/jQuery源码学习笔记/</id>
    <published>2017-08-01T16:00:00.000Z</published>
    <updated>2018-05-10T12:36:56.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-立即调用表达式"><a href="#1-立即调用表达式" class="headerlink" title="1.立即调用表达式"></a>1.立即调用表达式</h3><p>任何库与框架设计的第一个要点就是解决命名空间与变量污染的问题。jQuery就是利用了JavaScript函数作用域的特性，采用立即调用表达式包裹了自身的方法来解决这个问题。</p><p><strong>写法1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function(window,factory)&#123;</span><br><span class="line">    factory(window);</span><br><span class="line">&#125;(this,function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        //jQuery调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>写法1主要是为了判断jQuery在不同平台的下的加载逻辑，主流的库一般都有对 AMD 和 CommonJS 的支持代码。</p><p><strong>写法2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var factory = function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var jQuery = factory();</span><br></pre></td></tr></table></figure><p><strong>写法3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function(window,undefined)&#123;</span><br><span class="line">    var jQuery = function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    window.jQuery = window.$ = jQuery;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure><p>传递参数undefined的原因是：<br>Javascript 中的undefined并不是作为关键字，因此可以允许用户对其赋值，为了避免有人在外面给undefined赋了值，所以我们就把它设置为参数。设置undefined参数后，函数内部它默认就是undefined，不会产生歧义。</p><hr><h3 id="2-处理兼容性"><a href="#2-处理兼容性" class="headerlink" title="2.处理兼容性"></a>2.处理兼容性</h3><p>ie9以前的浏览器对xmlNode.method的存在检测有问题，如window.a == undefined达不到检测效果，而用typeof window.a == ‘undefined’能达到效果。</p><hr><h3 id="3-jq的面向对象的写法"><a href="#3-jq的面向对象的写法" class="headerlink" title="3.jq的面向对象的写法"></a>3.jq的面向对象的写法</h3><p>在jquery源码里面，面向对象的写法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function jQuery()&#123;</span><br><span class="line">    //这样写就能实现调用jQuery的时候，直接调用初始化方法，生成实例，这就省去了jq.init()这一步。</span><br><span class="line">    return new jQuery.prototype.init();</span><br><span class="line">&#125;</span><br><span class="line">jQuery.prototype.init = function()&#123;&#125;;</span><br><span class="line">jQuery.prototype.css = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//把init方法的原型指向jQuery的原型，使得它们共享一份原型，所以也就使得init可以用到jQuery原型上的方法了</span><br><span class="line">jQuery.prototype.init.prototype = jQuery.prototype;</span><br><span class="line"></span><br><span class="line">//就可以这样调用了</span><br><span class="line">jQuery().css();</span><br></pre></td></tr></table></figure></p><hr><h3 id="4-prototype两种写法的差异"><a href="#4-prototype两种写法的差异" class="headerlink" title="4.prototype两种写法的差异"></a>4.prototype两种写法的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这是往原型上去添加或修改属性、方法</span><br><span class="line">A.prototype.age = 18;</span><br><span class="line">A.prototype.name = &apos;lala&apos;;</span><br><span class="line"></span><br><span class="line">//这是重写原型，会覆盖掉默认生成的A.prototype.constructor，所以要把constructor写上</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    constructor:A,</span><br><span class="line">    age:18,</span><br><span class="line">    name:&apos;lala&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-init方法的参数处理"><a href="#5-init方法的参数处理" class="headerlink" title="5.init方法的参数处理"></a>5.init方法的参数处理</h3><p>我们在jQuery中用$()用得很多，它实际上调用的是jQuery的init方法，它可以接受以下这么几种参数，接受不同的参数，它的处理方式也是不一样的：</p><p>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;&quot;),$(null),$(undefined),$(false)</span><br></pre></td></tr></table></figure></p><p>这种情况就直接return this，不做其他处理。</p><p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;&lt;li&gt;1&lt;/li&gt;&quot;),$(&quot;&lt;div&gt;&quot;),$(&quot;#div1&quot;),$(&quot;div&quot;),$(&quot;#div1 div.box&quot;)</span><br></pre></td></tr></table></figure></p><p>遇到这种参数是字符串的，就会经过一系列判断、处理，最终生成这么一个对象格式：this = {0:’li’,1:’li’,length:2}。</p><p>(1)参数是字符串且匹配&lt;&gt;括号，说明是创建元素，那就调用parseHTML方法把它转化为元素节点数组，再调用merge方法转成上面所说到的this对象。</p><p>(2)参数是一个id选择器的，那就调用原生js的getElementById来获取它，然后也是再转化为this对象。</p><p>(3)参数是复杂多重选择器的，那就调用find方法（实现逻辑参见sizzle）来获取到元素节点。</p><p>3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(this),$(document)</span><br></pre></td></tr></table></figure></p><p>这种就会判断参数是不是一个node，是的话也是生成一个this对象。</p><p>4.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>如果参数是一个函数，就会在ready方法的回调中执行这个函数</p><p>5.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$([]),$(&#123;&#125;)</span><br></pre></td></tr></table></figure></p><hr><h3 id="6-pushStack方法"><a href="#6-pushStack方法" class="headerlink" title="6.pushStack方法"></a>6.pushStack方法</h3><p>jq对象的入栈（在slice,eq,map等方法中都是调用到这个方法）<br>它是一个栈结构，会先处理后入栈的对象，调用end()方法就会回溯到前一个对象</p><hr><h3 id="7-extend和-fn-extend"><a href="#7-extend和-fn-extend" class="headerlink" title="7.$.extend和$.fn.extend"></a>7.$.extend和$.fn.extend</h3><p>jq里面的继承是拷贝继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//扩展工具方法</span><br><span class="line">$.extend(&#123;</span><br><span class="line">    a:function()&#123;&#125;,</span><br><span class="line">    b:function()&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//调用：</span><br><span class="line">$.a();</span><br><span class="line">$.b();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//扩展jq实例方法</span><br><span class="line">$.fn.extend(&#123;</span><br><span class="line">    a:function()&#123;&#125;,</span><br><span class="line">    b:function()&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//调用：</span><br><span class="line">$().a();</span><br><span class="line">$().b();</span><br><span class="line"></span><br><span class="line">//对一个对象进行扩展</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">$.extend(a,&#123;age:18&#125;,&#123;name:&apos;lala&apos;&#125;)</span><br><span class="line"></span><br><span class="line">//深浅拷贝</span><br><span class="line">$.extend(a,b);//浅拷贝</span><br><span class="line">$.extend(true,a,b);//深拷贝</span><br></pre></td></tr></table></figure><hr><h3 id="8-extend方法详解"><a href="#8-extend方法详解" class="headerlink" title="8.extend方法详解"></a>8.extend方法详解</h3><p><strong>(1)生成唯一字符串(内部)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.expando</span><br></pre></td></tr></table></figure></p><p><strong>(2)解决冲突</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.noConflict()</span><br><span class="line">//写到上一个插件前面</span><br><span class="line">var aaa=$.noConflict();</span><br><span class="line">aaa(function()&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>(3)ready回调</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;&#125;) </span><br><span class="line">相当于</span><br><span class="line">$(document).ready(function()&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>DOM加载完就执行，它通过判断document.readyState或者给document加一个DOMContentLoaded事件监听来触发调用。<br>（ps：可以通过holdReady来控制同步异步，它的实现方式是以计数的方式判断是否能执行下去）</p><p><strong>(4)isWindow方法用来判断是不是window对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isWindow:function(obj)&#123;</span><br><span class="line">    return obj!=null &amp;&amp; obj===obj.window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(5)isNumeric方法用来判断是不是数值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNumeric:function(obj)&#123;</span><br><span class="line">    return !isNaN(parseFloat(obj)) &amp;&amp; isFinite(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(6)isPlainObject判断是不是对象自变量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isPlainObject:function(obj)&#123;</span><br><span class="line">    if(jQuery.type(obj)!==&quot;object&quot; || obj.nodeType || jQuery.isWindow(obj))&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        if(obj.constructor &amp;&amp; !core_hasOwn.call(obj.constructor.prototype,&quot;isPrototypeOf&quot;))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(7)parseHTML方法把标签字符串转换为html元素节点数组</strong></p><p>判断逻辑：</p><p>1.先用正则判断是不是单标签，是单标签就直接createElement</p><p>2.多标签就调用buildFragment</p><p><strong>(8)globalEval方法在全局执行传递进去的字符串参数</strong></p><p>判断逻辑：</p><p>如果是严格模式，那就新建一个script标签，标签里的内容是参数的内容，然后插入到文档中。</p><p>如果不是那就直接eval（因为严格模式下eval有自身的作用域，不是全局的作用域）</p><p><strong>(9)camelCase转驼峰写法（ps：ms前缀与众不同）</strong></p><p>ps:replace方法第二个参数可以是一个函数，这个函数有4个参数可以传入：第一个参数：正则所匹配到的字符；第二个参数：捕获括号所捕获到的字符；<br>第三个参数：正则匹配到的每段字符的第一个字符的索引；第四个参数：用于匹配的字符串主体；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">camelCase:function(str)&#123;</span><br><span class="line">    return str.replace(/^-ms-/,&quot;ms-&quot;).replace(/-([\da-z])/gi,(all,letter)=&gt;&#123;</span><br><span class="line">        return letter.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(10)nodeName方法判断节点的nodename</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeName:function(elem,name)&#123;</span><br><span class="line">    return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase()===name.toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(11)merge方法合并两个数组或形如{0:’a’,1:’b’,length:2}</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">merge:function(first,second)&#123;</span><br><span class="line">    var l = second.length,</span><br><span class="line">        i = first.length,</span><br><span class="line">        j = 0;</span><br><span class="line">    if(typeof l===&quot;number&quot;)&#123;</span><br><span class="line">        for(;j&lt;l;j++)&#123;</span><br><span class="line">            first[i++] = second[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        while(second[j]!==undefined)&#123;</span><br><span class="line">            first[i++] = second[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    first.length = i;</span><br><span class="line">    return first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(12)$(‘#div1’).width()</strong></p><p>它能够获取到即使display为none的元素的宽度，原生的offsetWidth是获取不到的</p><p>它的做法是先把display:none存起来，然后给元素加上display:block;visibility:hidden;position:absolute再获取它的offsetWidth，获取到之后再把刚才存起来的display:none还原，实现“偷梁换柱”（其实这种操作是依靠swap函数来实现的）</p><hr><h3 id="9-Callbacks-回调执行了解一下"><a href="#9-Callbacks-回调执行了解一下" class="headerlink" title="9.$.Callbacks()回调执行了解一下"></a>9.$.Callbacks()回调执行了解一下</h3><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var cb = $.Callbacks(options);</span><br><span class="line">options可以是：&apos;once&apos;,&apos;memory&apos;,&apos;unique&apos;,&apos;stopOnFalse&apos;</span><br><span class="line"></span><br><span class="line">//往回调数组中添加函数</span><br><span class="line">function a()&#123;&#125;</span><br><span class="line">function b()&#123;&#125;</span><br><span class="line">cb.add(a);</span><br><span class="line">cb.add(b);</span><br><span class="line"></span><br><span class="line">//依次调用</span><br><span class="line">cb.fire();</span><br></pre></td></tr></table></figure></p><p>首先有一个list数组来保存callbacks</p><p><strong>(0)options配置参数：</strong></p><p>once代表只能fire一次；</p><p>memory代表即使你的add在fire后面添加，但是也还能生效，他的实现原理是在add方法里面加上fire；</p><p>unique代表对list去重;</p><p>stopOnFlase代表如果回调函数里有return false的话，那就停止后面的执行。</p><p><strong>(1)add方法：</strong><br>往list里面push回调函数</p><p><strong>(2)remove方法：</strong><br>对list进行splice操作来移除某个回调函数</p><p><strong>(3)fire方法：</strong><br>遍历list，依次执行</p><hr><h3 id="10-Deferred-处理异步流程"><a href="#10-Deferred-处理异步流程" class="headerlink" title="10.$.Deferred()处理异步流程"></a>10.$.Deferred()处理异步流程</h3><p>实际上也是调用$.Callbacks()来处理。</p><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var dfd = $.Deferred();</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    alert(1);</span><br><span class="line">    dfd.resolve();  //这是成功触发，另外还有失败触发标志reject</span><br><span class="line">&#125;,1000);</span><br><span class="line">dfd.done(function()&#123;</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;)</span><br><span class="line">dfd.fail(function()&#123;</span><br><span class="line">    alert(3);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>done,fail方法对应callbacks的add方法，resolve,reject方法对应callbacks的fire方法。</p><p>resolve,done实际上对应的是$.Callbacks(‘once memory’)，有once是为了使状态不可逆，只触发一次；</p><p>reject,fail实际上对应的是$.Callbacks(‘once memory’)，有once是为了使状态不可逆，只触发一次；</p><p>notify,progress实际上对应的是$.Callbacks(‘memory’)。</p><p>内部还有一个自定义的promise对象来新增一些协助函数方法，它跟deferred不一样的地方就是它没有那三种状态，防止调用这个方法的时候把状态给改了。</p><p><strong>$.when()方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//相当于promise.all</span><br><span class="line">$.when(a(),b()).done(function()&#123;</span><br><span class="line">    alert(&apos;success&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>它会把参数放进一个数组里面并执行，内部有一个计数器，数值等于数组长度，每有一个参数完成计数器就减一，当计数器为0时那就执行内部新建的$.Deferred()</p><hr><h3 id="11-通过support进行功能检测"><a href="#11-通过support进行功能检测" class="headerlink" title="11.通过support进行功能检测"></a>11.通过support进行功能检测</h3><p>作为兼容性功能的判断实现，主要有样式兼容、h5兼容、js兼容等等。可以通过创建一些元素来检测不同浏览器下这些元素的表现行为、属性方法有什么异同，检测完之后就可以把元素给删掉。</p><p>而针对不同环境下作出不同的反应是通过hooks实现的，support只是一个兼容判断。</p><hr><h3 id="12-attr、prop和data"><a href="#12-attr、prop和data" class="headerlink" title="12.attr、prop和data"></a>12.attr、prop和data</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#div1&apos;).attr(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line">相当于</span><br><span class="line">document.getElementById(&apos;div1&apos;).setAttribute(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line"></span><br><span class="line">$(&apos;#div1&apos;).prop(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line">相当于</span><br><span class="line">document.getElementById(&apos;div1&apos;).name=&apos;lala&apos;;</span><br><span class="line"></span><br><span class="line">//当然不会这么简单直接设置，它们还会检测参数合法性，解决浏览器兼容问题等等</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这样不会内存泄漏</span><br><span class="line">$(&apos;#div1&apos;).data(&apos;name&apos;,obj);</span><br><span class="line">//这样有可能会内存泄漏</span><br><span class="line">$(&apos;#div1&apos;).attr(&apos;name&apos;,obj);</span><br><span class="line"></span><br><span class="line">//ps：DOM元素和对象之间相互引用，大部分浏览器就会出现内存泄漏</span><br><span class="line">var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">div1.name = obj;</span><br><span class="line">obj.age = div1;</span><br></pre></td></tr></table></figure><p>data方法是怎么做到消除内存泄漏的呢？</p><p>其实它是先新建一个cache对象来存放一种对应联系，建立元素绑定的属性和你自定义要绑定进去的属性之间的联系，就是说这是一种间接绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//cache就是类似于以下这样的结构</span><br><span class="line">this.cache=&#123;</span><br><span class="line">    1:&#123;name:&apos;lala&apos;&#125;,</span><br><span class="line">    2:&#123;name:&apos;lala&apos;,age:19&#125;</span><br><span class="line">&#125;</span><br><span class="line">//它会给每个data分配一个映射到实际属性的key：1、2、3...，同一个元素分配到的都是同一个key</span><br><span class="line">//元素上挂载的实际上是类似于这样的东西：</span><br><span class="line"></span><br><span class="line">&lt;div jquery784382547239469837=&quot;1&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//当this不是元素或者document节点时，这个cache会通过Object.defineProperty设置一个key为0，getter为&#123;&#125;的属性，这是处理非元素节点时用的</span><br></pre></td></tr></table></figure><hr><h3 id="13-jQuery的queue"><a href="#13-jQuery的queue" class="headerlink" title="13.jQuery的queue"></a>13.jQuery的queue</h3><p>跟数据结构里的队列是一样的，只不过它存放的是函数，出队列的时候就会调用这个函数,要前一个函数出了队列才会执行下一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//多个动画animate就用到了queue</span><br><span class="line">$(this).animate(&#123;width:300&#125;,2000);</span><br><span class="line">$(this).animate(&#123;height:100&#125;,2000);</span><br><span class="line">$(this).animate(&#123;left:500&#125;,2000);</span><br></pre></td></tr></table></figure><hr><h3 id="14-对class的操作"><a href="#14-对class的操作" class="headerlink" title="14.对class的操作"></a>14.对class的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#div1&apos;).addClass(&apos;box1 box2&apos;);</span><br><span class="line">$(&apos;#div1&apos;).removeClass(&apos;box1 box2&apos;);</span><br><span class="line">$(&apos;#div1&apos;).toggleClass(&apos;box1 box2&apos;);</span><br></pre></td></tr></table></figure><p>addClass实际上是对传进来的字符串进行检验、分割，然后再用indexOf判断元素原来的class里面有没有新增的class，没有才添加进去，有就不管。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-立即调用表达式&quot;&gt;&lt;a href=&quot;#1-立即调用表达式&quot; class=&quot;headerlink&quot; title=&quot;1.立即调用表达式&quot;&gt;&lt;/a&gt;1.立即调用表达式&lt;/h3&gt;&lt;p&gt;任何库与框架设计的第一个要点就是解决命名空间与变量污染的问题。jQuery就是利用了
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>fl效果器</title>
    <link href="http://yoursite.com/2017/07/12/fl%E6%95%88%E6%9E%9C%E5%99%A8/"/>
    <id>http://yoursite.com/2017/07/12/fl效果器/</id>
    <published>2017-07-11T16:00:00.000Z</published>
    <updated>2018-05-10T12:37:05.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录下fl效果器的效果"><a href="#记录下fl效果器的效果" class="headerlink" title="记录下fl效果器的效果"></a>记录下fl效果器的效果</h3><p>EQUO 音色粗细</p><p>Fabfilter simplon 电音</p><p>fruity chorus 和声</p><p>fruity convolver 空旷回声</p><p>fruity delay 2 重复音</p><p>fruity delay bank 重复音不同</p><p>fruity fast dist 电噪音</p><p>fruity flanger 多种回音</p><p>fruity flangus 电子跳音</p><p>fruity limiter 强弱</p><p>fruity love philter 未来电音</p><p>fruity multiband compressor 钝、干</p><p>fruity parametric EQ 铁质音</p><p>fruity parametric EQ2 多样铁质音</p><p>fruity phaser 多样</p><p>fruity reeverb2 场合音</p><p>fruity squeeze 噪铁</p><p>fruity stereo enhancer 立体音</p><p>fruity stereo shaper 左右声道多样</p><p>fruity vocoder 低小音</p><p>fruity waveshaper 噪</p><p>gross beat 多样重</p><p>hardcore 空灵噪</p><p>maximus 干电音</p><p>soundgoodizer 电</p><p>vocodex 弹东西的声音，赞</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;记录下fl效果器的效果&quot;&gt;&lt;a href=&quot;#记录下fl效果器的效果&quot; class=&quot;headerlink&quot; title=&quot;记录下fl效果器的效果&quot;&gt;&lt;/a&gt;记录下fl效果器的效果&lt;/h3&gt;&lt;p&gt;EQUO 音色粗细&lt;/p&gt;
&lt;p&gt;Fabfilter simplon
      
    
    </summary>
    
      <category term="电音" scheme="http://yoursite.com/categories/%E7%94%B5%E9%9F%B3/"/>
    
    
      <category term="fl" scheme="http://yoursite.com/tags/fl/"/>
    
  </entry>
  
  <entry>
    <title>CSS揭秘学习笔记</title>
    <link href="http://yoursite.com/2017/06/17/css%E6%8F%AD%E7%A7%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/17/css揭秘学习笔记/</id>
    <published>2017-06-16T16:00:00.000Z</published>
    <updated>2018-09-25T02:53:25.554Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、关于自适应媒体查询</strong></p><p>下面还有一些建议，可能会帮你避免不必要的媒体查询。</p><p>1.尝试使用与视口相关的单位（vw、vh、vmin和vmax），它们的值解析为视口宽度或高度的百分比。</p><p>2.当你需要在较大分辨率下得到固定宽度时，使用max-width而不是width，因为它可以适应较小的分辨率，而无需使用媒体查询。</p><p>3.不要忘记为替换元素（比如img、object、video、iframe等）设置一个max-width，值为100%。</p><p>4.假如背景图片需要完整地铺满一个容器，不管容器的尺寸如何变化，background-size:cover这个属性都可以做到。但是，我们也要时刻牢记——带宽并不是无限的，因此在移动网页中通过CSS把一张大图缩小显示往往是不太明智的。</p><p>5.当图片（或其他元素）以行列式进行布局时，让视口的宽度来决定列的数量。弹性盒布局（即Flexbox）或者display:inline-block加上常规的文本折行行为，都可以实现这一点。</p><p>6.在 使 用 多 列 文 本 时，指定column-width（列 宽）而 不 是 指 定column-count（列数），这样它就可以在较小的屏幕上自动显示为单列布局。</p><hr><p><strong>二、半透明边框</strong></p><p>默认状态下，背景会延伸到边框的区域下层。</p><p>我们可以通过background-clip属性来调整上述默认行为所带来的不便。这个属性的初始值是border-box，意味着背景会被元素的border  box（边框的外沿框）裁切掉。如果不希望背景侵入边框所在的范围，我们要做的就是把它的值设为padding-box，这样浏览器就会用内边距的外沿来把背景裁切掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid hsla(0,0%,100%,.5);</span><br><span class="line">background:white;</span><br><span class="line">background-clip:padding-box;</span><br></pre></td></tr></table></figure></p><hr><p><strong>三、利用投影实现多重边框</strong></p><p>唯一需要注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依次类推。因此，你需要按此规律调整扩张半径。比如说，在前面的代码中，我们想在外圈再加一道5px的外框，那就需要指定扩张半径的值为15px（10px+5px）。如果你愿意，甚至还可以在这些“边框”的底下再加一层常规的投影：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background:yellowgreen;</span><br><span class="line">box-shadow:0 0 0 10px #655,</span><br><span class="line">0 0 0 15px deeppink,</span><br><span class="line">0 2px 5px 15px rgba(0,0,0,.6);</span><br></pre></td></tr></table></figure><p>投影的行为跟边框不完全一致，因为它不会影响布局，而且也不会受到box-sizing属性的影响。不过，你还是可以通过内边距或外边距（这取决于投影是内嵌和还是外扩的）来额外模拟出边框所需要占据的空间。</p><p>上述方法所创建出的假“边框”出现在元素的外圈。它们并不会响应鼠标事件，比如悬停或点击。如果这一点非常重要，你可以给box-shadow属性加上inset关键字，来使投影绘制在元素的内圈。请注意，此时你需要增加额外的内边距来腾出足够的空隙。</p><hr><p><strong>四、background-position</strong></p><p>举例来说，如果想让背景图片跟右边缘保持20px的偏移量，同时跟底边保持10px的偏移量，同时兼容不支持这一特性的浏览器时，可以这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background:url(code-pirate.svg) no-repeat bottom right #58a;</span><br><span class="line">background-position:right 20px bottom 10px;</span><br></pre></td></tr></table></figure><hr><p><strong>五、利用background-origin改变背景区域</strong></p><p>在网页开发生涯中，你很可能多次写过类似background-position: top  left;这样的代码。你是否曾经有过疑惑：这个top  left到底是哪个左上角？你可能知道，每个元素身上都存在三个矩形框：border box（边框的外沿框）、paddingbox（内边距的外沿框）和content box（内容区的外沿框）。那background-position这个属性指定的到底是哪个矩形框的左上角？</p><p>默认情况下，background-position是以paddingbox为准的，这样边框才不会遮住背景图片。因此，topleft默认指的是padding  box的左上角。不过，我们得到了一个新的属性background-origin，可以用它来改变这种行为。在默认情况下，它的值是（闭着眼睛也猜得到）padding-box。如果把它的值改成content-box（参见下面的代码），我们在background-position属性中使用的边角关键字将会以内容区的边缘作为基准（也就是说，此时背景图片距离边角的偏移量就跟内边距保持一致了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">padding:10px;</span><br><span class="line">background:url(&quot;code-pirate.svg&quot;) no-repeat #58a</span><br><span class="line">bottom right; /* 或100% 100% */</span><br><span class="line">background-origin:content-box;</span><br></pre></td></tr></table></figure><p>这样就可以实现跟第四点一样的效果。</p><hr><p><strong>六、calc()</strong></p><p>请不要忘记在calc()函数内部的-和+运算符的两侧各加一个空白符，否则会产生解析错误！这个规则如此怪异，是为了向前兼容：未来，在calc()内部可能会允许使用关键字，而这些关键字可能会包含连字符。</p><p>让我们回顾一下本节开头的挑战：把背景图片定位到距离底边10px且距离右边20px的位置。如果我们仍然以左上角偏移的思路来考虑，其实就是希望它有一个100%  -20px的水平偏移量，以及100%  -  10px的垂直偏移量。谢天谢地，calc()函数允许我们执行此类运算，它可以完美地在background-position属性中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background:url(&quot;code-pirate.svg&quot;) no-repeat;</span><br><span class="line">background-position:calc(100% - 20px)calc(100% - 10px);</span><br></pre></td></tr></table></figure><hr><p><strong>七、利用linear-gradient实现多色条纹背景</strong></p><p>如果我们把第二个色标的位置值设置为0，那它的位置就总是会被浏览器调整为前一个色标的位置值。</p><p>水平条纹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background:linear-gradient(#fb3 33.3%,#58a 0,#58a 66.6%,yellowgreen 0);</span><br><span class="line">background-size:100% 45px;</span><br></pre></td></tr></table></figure><p>垂直条纹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background:linear-gradient(to right, /* 或90deg */</span><br><span class="line">#fb3 50%,#58a 0);</span><br><span class="line">background-size:30px 100%;</span><br></pre></td></tr></table></figure><p>斜向条纹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background:linear-gradient(45deg,</span><br><span class="line">#fb3 25%,#58a 0,#58a 50%,</span><br><span class="line">#fb3 0,#fb3 75%,#58a 0);</span><br><span class="line">background-size:30px 30px;</span><br></pre></td></tr></table></figure><hr><p><strong>八、border-radius</strong></p><p>说到border-radius，有一个鲜为人知的真相：它可以单独指定水平和垂直半径，只要用一个斜杠（/）分隔这两个值即可。这个特性允许我们在拐角处创建椭圆圆角（参见图3-3）。因此，如果我们有一个尺寸为200px×150px的元素，就可以把它圆角的两个半径值分别指定为元素宽高的一半，从而得到一个精确的椭圆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-radius:100px /75px;</span><br></pre></td></tr></table></figure><hr><p><strong>九、平行四边形</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;button&quot;&gt;按钮1&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.button &#123;</span><br><span class="line">position:relative;</span><br><span class="line">display:inline-block;</span><br><span class="line">/* 其他的文字颜色、内边距等样式……*/</span><br><span class="line">&#125;</span><br><span class="line">.button::before &#123;</span><br><span class="line">content: &apos;&apos;; /* 用伪元素来生成一个矩形*/</span><br><span class="line">position:absolute;</span><br><span class="line">top:0; right:0; bottom:0; left:0;</span><br><span class="line">z-index: -1;</span><br><span class="line">background:#58a;</span><br><span class="line">transform:skew(45deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>十、菱形相册</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.picture &#123;</span><br><span class="line">width:400px;</span><br><span class="line">transform:rotate(45deg);</span><br><span class="line">overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.picture &gt;img &#123;</span><br><span class="line">max-width:100%;</span><br><span class="line">transform: rotate(-45deg)scale(1.42);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，可以用clip-path的方法来实现，它还可以参与动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img &#123;</span><br><span class="line">clip-path:polygon(50% 0,100% 50%,</span><br><span class="line">50% 100%,0 50%);</span><br><span class="line">transition:1s clip-path;</span><br><span class="line">&#125;</span><br><span class="line">img:hover &#123;</span><br><span class="line">clip-path:polygon(0 0,100% 0,</span><br><span class="line">100% 100%,0 100%);</span><br></pre></td></tr></table></figure><hr><p><strong>十一、切角实现</strong></p><p>四个角都是切角：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">background:#58a;</span><br><span class="line">background:</span><br><span class="line">linear-gradient(135deg,transparent 15px,#58a 0)</span><br><span class="line">top left,</span><br><span class="line">linear-gradient(-135deg,transparent 15px,#58a 0)</span><br><span class="line">top right,</span><br><span class="line">linear-gradient(-45deg,transparent 15px,#58a 0)</span><br><span class="line">bottom right,</span><br><span class="line">linear-gradient(45deg,transparent 15px,#58a 0)</span><br><span class="line">bottom left;</span><br><span class="line">background-size:50% 50%;</span><br><span class="line">background-repeat:no-repeat;</span><br></pre></td></tr></table></figure><hr><p><strong>十二、单行打字动画</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@keyframes typing &#123;</span><br><span class="line">    from &#123; width: 0 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes caret &#123;</span><br><span class="line">    50% &#123; border-right-color: transparent; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">    font: bold 200% Consolas, Monaco, monospace;</span><br><span class="line">    /*width: 8.25em;*/</span><br><span class="line">    width: 15ch;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    border-right: .05em solid;</span><br><span class="line">    animation: typing 8s steps(15),</span><br><span class="line">               caret 1s steps(1) infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、关于自适应媒体查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面还有一些建议，可能会帮你避免不必要的媒体查询。&lt;/p&gt;
&lt;p&gt;1.尝试使用与视口相关的单位（vw、vh、vmin和vmax），它们的值解析为视口宽度或高度的百分比。&lt;/p&gt;
&lt;p&gt;2.当你需要在较大
      
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/06/15/hello-world/"/>
    <id>http://yoursite.com/2017/06/15/hello-world/</id>
    <published>2017-06-14T16:00:00.000Z</published>
    <updated>2018-03-18T11:27:05.387Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="其它" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
