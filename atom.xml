<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chambers个人博客</title>
  
  <subtitle>记录点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-27T14:00:09.343Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chambers</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="http://yoursite.com/2019/02/27/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/02/27/Linux学习笔记/</id>
    <published>2019-02-26T16:00:00.000Z</published>
    <updated>2019-02-27T14:00:09.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h3><ol><li><p>ls 查看目录中的内容<br>选项：<br>-a 显示所以文件，包括隐藏文件（点“.”开头的文件，是属于系统文件，不懂别乱动点开头点文件。）<br>-l 显示详细信息<br>-d 查看目录属性<br>-h 人性化显示文件大小（KB）<br>-i 显示inode<br>详细信息中的第一列信息：<br>如：-rwxr–r–<br>第一位是文件类型：<br>-代表文件  d代表目录  l代表软链接<br>2-4位    rwx代表“所有者”可读、可写、可执行。解释：文件所有者可以对文件进行的操作权限。<br>5-7位    r–代表“所属组”可读。解释：文件所分配的组可以对文件进行的操作权限。<br>8-10位    r–代表“其他人”可读。解释：其他用户可以对文件进行的操作权限。  </p></li><li><p>pwd 显示当前路径</p></li><li><p>mkdir 创建目录<br>选项：<br>-p 递归创建（即要在一个不存在的目录下创建目录，那就要加-p）</p></li><li><p>cd 切换目录<br>简化操作：<br>cd ~ 到家目录<br>cd .. 到上级目录<br>cd - 到上次去的目录</p></li><li><p>rmdir 删除空目录</p></li><li><p>rm 删除文件或目录<br>选项：<br>-r 删除目录<br>-f 强制  </p></li><li><p>cp 复制文件或目录<br>选项：<br>-r 复制目录<br>-p 连带文件属性复制<br>-d 如源文件是链接文件，则复制链接属性<br>-a 相当于-rpd  </p></li><li><p>ll 相当于ls -l</p></li><li><p>mv 剪切或改名文件或目录</p></li><li><p>ln 生成链接文件<br>选项：<br>-s 创建软链接（相当于快捷方式）</p></li><li><p>locate 在数据库中搜索文件的位置（所以比起find要快），它是根据/etc/updatedb.conf这个配置文件来搜索的，可以修改搜索配置</p></li><li><p>updatedb 更新数据库（数据库不是实时更新，所以要手动更新一下，才能让locate找到新创建的文件）</p></li><li><p>whereis 搜索命令及帮助文档所在位置</p></li><li><p>which 同上，不过多了alias的显示</p></li><li><p>find 搜索指定路径下的符合条件的文件</p></li><li><p>grep 搜索指定字符串在文件中的位置<br>选项：<br>-i 忽略大小写<br>-v 反选</p></li><li><p>man 获取命令帮助</p></li><li><p>zip 压缩文件或目录<br>选项：<br>-r 压缩目录  </p></li><li><p>unzip 解压</p></li><li><p>touch 新建文件</p></li><li><p>gzip 压缩为.gz格式的压缩文件，源文件会消失<br>选项：<br>-c 保留原文件<br>-r 压缩目录下所有子文件，但是不压缩目录<br>-d 解压（也可以用gunzip命令）  </p></li><li><p>bzip2 压缩为.bz2格式的压缩文件，源文件会消失（不能压缩目录）<br>选项：<br>-k 保留原文件<br>-d 解压（也可以用bunzip2命令）  </p></li><li><p>tar 打包成一个文件<br>选项：<br>-z 压缩为.tar.gz格式<br>-j 压缩为.tar.bz2格式<br>-c 打包<br>-x 解打包解压缩<br>-v 显示过程<br>-f 指定打包后的文件名   </p></li><li><p>shutdown 关机或重启<br>选项：<br>-c 取消前一个关机命令<br>-h 关机<br>-r 重启  </p></li><li><p>mount 查看已挂载设备<br>选项：<br>-a 依据/etc/fstab的内容自动挂载  </p></li><li><p>chmod 改变文件存取模式<br>如：chmod 751 file 表示给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限  </p></li><li><p>umount 卸载设备</p></li><li><p>w 查看用户信息</p></li><li><p>last 查看登录记录</p></li><li><p>lastlog 查看所有用户的最后一次登录记录</p></li><li><p>echo 输出<br>选项：<br>-e 使echo可以识别\n,\b等等这些符号  </p></li><li><p>alias 查看/设置命令的别名（临时生效）<br>vim ~/.bashrc 把别名写入环境变量配置文件（永久生效）  </p></li><li><p>unalias 删除别名（临时生效）  </p></li><li><p>cat 查看文件</p></li><li><p>vim 创建/编辑文件<br>vim + test.log 用vim打开并把光标定位到最后一行<br>vim +3 test.log 用vim打开并把光标定位到第三行<br>vim +/xxx test.log 用vim打开并把光标定位到xxx第一次出现的那行（进去文件后按n可以在多个xxx来回切换）<br>vim aa bb cc 打开/创建这三个文件（进去文件后可以在底行输入:n切换到下一个文件，输入:N切换到上一个文件）<br>:w 保存<br>:q 退出<br>:! 强制<br>:ls 列出vim打开的所有文件<br>:n 切换到下一个文件<br>:N 切换到上一个文件<br>:7 把光标移动到第7行<br>/xxx 把光标定位到当前光标所在位置之后xxx第一次出现的位置<br>?xxx 把光标定位到当前光标所在位置之前xxx第一次出现的位置<br>ctrl+f 向下翻页<br>ctrl+b 向上翻页<br>ctrl+d 向下翻半页<br>ctrl+u 向上翻半页<br>dd 删除光标所在行<br>o 在光标所在行的下方插入一行并切换到输入模式<br>yy 复制光标所在行<br>p 在光标所在行的下方粘贴<br>P 在光标所在行的上方粘贴  </p></li></ol><h3 id="二、基本格式"><a href="#二、基本格式" class="headerlink" title="二、基本格式"></a>二、基本格式</h3><ol><li>[root@localhost ~]#</li></ol><p>root:    当前登录用户<br>localhost:    主机名<br>~:    当前所在目录(家目录)  </p><p>#:    超级用户的提示符<br>$:    普通用户的提示符  </p><ol><li>sh脚本</li></ol><p>创建：vim hello.sh<br>第一行要加上#!/bin/bash<br>执行：<br>1.赋予执行权限，直接运行：<br>chmod 755 hello.sh<br>./hello.sh<br>2.通过Bash调用执行脚本<br>bash hello.sh  </p><ol><li><p>输出重定向<br>命令 &gt; 文件名，如：ifconfig &gt; text.log，就把ifconfig的结果覆盖写入到text.log下了（不想覆盖，只是追加写入的话用&gt;&gt;）<br>命令 2&gt;文件名，如：ifconsdfsdf 2&gt;text.log，就把这个报错结果覆盖写入到text.log下了（不想覆盖，只是追加写入的话用2&gt;&gt;）<br>命令 &gt;&gt; 文件名 2&gt;&amp;1，就可以无论正确错误都写入到文件中<br>命令 &amp;&gt;&gt;文件，同上<br>命令 &gt;&gt; 文件1 2&gt;&gt;文件2，正确写在文件1、错误写在文件2  </p></li><li><p>管道符 |<br>命令1 | 命令2  命令1的正确输出作为命令2的操作对象  </p></li></ol><h3 id="三、快捷键"><a href="#三、快捷键" class="headerlink" title="三、快捷键"></a>三、快捷键</h3><ol><li>ctrl+l 清屏  </li><li>ctrl+c 终止当前命令  </li><li>ctrl+a 光标移到命令行首  </li><li>ctrl+e 光标移到命令行尾  </li><li>ctrl+u 从光标所在位置删除到行首  </li><li>ctrl+z 把命令放入后台  </li><li>ctrl+r 在命令中搜索   </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、常用命令&quot;&gt;&lt;a href=&quot;#一、常用命令&quot; class=&quot;headerlink&quot; title=&quot;一、常用命令&quot;&gt;&lt;/a&gt;一、常用命令&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ls 查看目录中的内容&lt;br&gt;选项：&lt;br&gt;-a 显示所以文件，包括隐藏文件（点“.”开头
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>区块链应用——比特币</title>
    <link href="http://yoursite.com/2018/11/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>http://yoursite.com/2018/11/05/区块链应用——比特币/</id>
    <published>2018-11-04T16:00:00.000Z</published>
    <updated>2018-11-01T12:17:33.774Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-区块链应用场景"><a href="#1-区块链应用场景" class="headerlink" title="1.区块链应用场景"></a>1.区块链应用场景</h3><ul><li>资产：数字资产发行、支付（跨境支付）、交易、结算</li><li>记账：股权交易、供应链金融、商业积分</li><li>不可篡改：溯源、众筹、医疗证明、存在性证明</li><li>点对点：共享经济、物联网</li><li>隐私：匿名交易</li></ul><hr><h3 id="2-比特币是什么"><a href="#2-比特币是什么" class="headerlink" title="2.比特币是什么"></a>2.比特币是什么</h3><p>比特币首先是一种数字货币。</p><p>先说说数字货币。货币即一般等价物，那我们是不是也可以认为一串数字也可以是货币呢？当这串数字成为人们的共识，得到人们的信任，那么，这就是数字货币。</p><p>那你可能会问我们为什么要信任这串数字呢？它值得信任吗？</p><ol><li>财产只受自己控制。比特币的世界里面，财产只受自己控制，而不像现实世界中我们的钱币寄存在银行里面，具有被银行冻结的风险，即具有不可控性。</li><li>无通胀。比特币总数量是固定的（大概是2100万个），不会扩大发行。</li><li>无假钞。在比特币的世界里，任何作弊、作假的支付无法得到其他矿工的确认。</li><li>流通性好。点对点交易，特别是在国际交易、转账的应用场景里面优势更为明显。</li></ol><p>其次，比特币还是一种去中心化的记账系统。即它采用的是分布式数据库，数据会保存在每一个节点中，每一个节点都保存着相同的数据。而非集中在一台服务器、数据库中。</p><p>那么，如果有人偷偷篡改了账本的数据，我们是怎么发现的呢？即账本是如何验证其有效性的呢？</p><p>这里就引入一个概念：Hash。Hash函数的特点是同样的原始信息用同一个Hash函数总能得到相同的摘要信息，原始信息任何微小的变化都会哈希出完全不一样的摘要信息，并且，我们是无法从摘要信息逆向推算出原始信息。</p><p>所以，我们就可以从Hash值来推断出数据是否有被篡改过。一般来说，我们当前的区块是由这么几部分组成的：区块序号、记录时间戳、上一区块节点的hash值、当前区块的hash值、数据内容。当前区块的hash值的计算方式是：对区块序号、记录时间戳、上一区块节点的hash值和数据内容进行hash运算。下一区块节点的hash总是和上一个区块节点是相关的，因此，核对账本有效性时就只需要核对区块链中最后一个区块的有效性，就能知道整条区块链是否有效。</p><hr><h3 id="3-账户所有权问题"><a href="#3-账户所有权问题" class="headerlink" title="3.账户所有权问题"></a>3.账户所有权问题</h3><p>现实生活中，银行是通过核对开户人信息与当前操作者的信息来核实账户所有权问题的。<br>那比特币体系中是如何确定账户所有权问题的呢？</p><p>账本中只记录交易双方的地址，而不记录交易双方的个人信息（所以有很好的隐私性），谁通过这个地址来进行交易，谁就拥有这个账户的所有权。而一个地址对应着一个私钥，私钥泄露的话，比特币就有可能丢失了，所以我们一定要保管好这个私钥。（PS：私钥可以通过两次hash运算推导出地址，但是不能反过来从地址推导出私钥）</p><p>那么，我们怎么在不亮出私钥的前提下证明自己拥有这个私钥以通过其它节点的验证呢？<br>这里就用到了非对称加密技术。</p><ol><li>首先，我们对交易信息进行一次hash运算得到交易摘要Hash((2A234CCW…-&gt;SD87782… “2BTC”))，</li><li>然后，用这个交易摘要和自己的私钥进行签名运算，生成签名信息(sign)。</li><li>之后，产生交易的节点就会向其他节点广播以下内容：交易信息(2A234CCW…-&gt;SD87782… “2BTC”) + 刚才生成的签名(sign)。</li><li>其它节点验证（verify(签名信息sign,付款方地址)-&gt;交易摘要）通过后就会继续向他的相邻节点进行广播，直到所有节点都验证通过，这份交易记录就被认为是有效的，可以安心写入到帐本中了。</li></ol><hr><h3 id="4-挖矿过程"><a href="#4-挖矿过程" class="headerlink" title="4.挖矿过程"></a>4.挖矿过程</h3><p>记账其实是hash打包验证的过程，这里必定会消耗计算机资源，要付出成本，那为什么节点要参与记账呢？</p><p>完成记账的节点是可以获得一定数量的比特币作为奖励的，这个奖励其实也就是比特币发行的过程。<br>每次记账会发行一定数量的比特币，这就会引起节点的争相记账，如果大家都去记账的话，就会出现记账不一致的情况。为了解决这个问题，比特币体系也有自己的规则：一段时间（一般是10分钟）内只有一人可以记账成功，并且需要通过解决密码学难题（即工作量证明）竞争获得唯一的记账权，第一个节点计算出来之后，其他节点便复制记账结果。</p><p>计算当前节点的hash很简单，即通过上一个hash值和交易记录集可以算出。但是，为了增强挖矿的难度，规则规定，你不仅要通过上一个hash值和交易记录集来计算，还要加上一个随机数来hash计算出一个伪hash值（n个0再加上真hash值），这就是所谓的密码学难题，你为了算出这个值，必须花费一定的工作量来计算，也就是挖矿。</p><p>前面所说到的交易记录集指的是收集广播中还没有被记录账本的交易，然后校验这些交易的有效性，然后再添加一笔给自己转账的交易（挖矿奖励）。这样，当你是第一个算出来的节点，就有权把这笔交易写进账本里，使奖励生效。</p><hr><h3 id="5-共识机制"><a href="#5-共识机制" class="headerlink" title="5.共识机制"></a>5.共识机制</h3><p>那么问题来了，两个节点同时完成工作量证明，使用谁的区块？</p><p>节点选择出累计工作量最大（/最长）的区块链，再以此区块链通过不断挖矿来继续延长该区块链，共识机制就是来保证此要求。</p><p>例如，两个节点同时完成工作量证明，分别打包成3458A和3458B，周围的节点选择出累计工作量最大（/最长）的区块链为3458A后进行广播，以3458A作为主链，3458B作为备用。</p><hr><p>PS：<a href="https://github.com/cmh1996/easy-blockchain" target="_blank" rel="noopener">这是一个简单的入门demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-区块链应用场景&quot;&gt;&lt;a href=&quot;#1-区块链应用场景&quot; class=&quot;headerlink&quot; title=&quot;1.区块链应用场景&quot;&gt;&lt;/a&gt;1.区块链应用场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;资产：数字资产发行、支付（跨境支付）、交易、结算&lt;/li&gt;
&lt;li&gt;记账
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>该学学TypeScript了</title>
    <link href="http://yoursite.com/2018/11/02/%E8%AF%A5%E5%AD%A6%E5%AD%A6TypeScript%E4%BA%86/"/>
    <id>http://yoursite.com/2018/11/02/该学学TypeScript了/</id>
    <published>2018-11-01T16:00:00.000Z</published>
    <updated>2018-10-26T11:56:51.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、入门介绍"><a href="#一、入门介绍" class="headerlink" title="一、入门介绍"></a>一、入门介绍</h2><h3 id="1-基础类型"><a href="#1-基础类型" class="headerlink" title="1.基础类型"></a>1.基础类型</h3><p>先来看看它是怎么声明基础类型的type的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//布尔</span><br><span class="line">const is: boolean = true;</span><br><span class="line">//数值</span><br><span class="line">const isN: number = 110;</span><br><span class="line">//字符串</span><br><span class="line">const isS: string = &quot;&quot;;</span><br><span class="line">//数组</span><br><span class="line">const isA: Array&lt;any&gt; = [];</span><br><span class="line">const isA: any[] = [];</span><br><span class="line">//null</span><br><span class="line">const isNull: null = null;</span><br><span class="line">//undefined</span><br><span class="line">const isUndefined: undefined = undefined;</span><br><span class="line">//元组</span><br><span class="line">const x: [string, number] = [&quot;hello&quot;, 110]; </span><br><span class="line">//枚举</span><br><span class="line">enum Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue</span><br><span class="line">&#125;</span><br><span class="line">enum Color &#123;</span><br><span class="line">  Red = &quot;red&quot;,</span><br><span class="line">  Green = &quot;green&quot;</span><br><span class="line">&#125;</span><br><span class="line">//any</span><br><span class="line">let Ans: any = 4;</span><br><span class="line">let Ans: any = &quot;4&quot;;</span><br><span class="line">//void</span><br><span class="line">let unusable: void = undefined;</span><br><span class="line">//利用解构</span><br><span class="line">function a([f,s]:[number,string])&#123;&#125;;</span><br><span class="line">let &#123; a, b &#125;: &#123;a:number, b: number &#125; = o;</span><br></pre></td></tr></table></figure></p><hr><h3 id="2-函数＆类"><a href="#2-函数＆类" class="headerlink" title="2.函数＆类"></a>2.函数＆类</h3><p>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//限定函数入出参的类型</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">//可选参数和默认参数</span><br><span class="line">function sum(x: number = 2, y?: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">//解构参数</span><br><span class="line">function sum(...num: number[]): number &#123;</span><br><span class="line">  return num[0] + num[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类：</p><p>主要是几个修饰符的问题：</p><p>public 外部程序可以自由的访问</p><p>private 外部程序不可以自由的访问</p><p>protected 与 private 类似，唯一的不同是它可以在派生类中自由的访问</p><p>readonly 与词同意，只读</p><p>static 静态属性或方法</p><p>get/set getter/setter钩子（唯一要注意的是如果只定义了 get 钩子而没有定义 set 钩子的话，这个属性将是 readonly）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    public country: string;</span><br><span class="line">    private age: number;</span><br><span class="line">    protected name: string;</span><br><span class="line">    constructor(country: string)&#123;</span><br><span class="line">        this.country = country;</span><br><span class="line">        this.name = &apos;cmh&apos;;</span><br><span class="line">        this.age = 18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output() &#123;</span><br><span class="line">        return this.country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get fullName(): string &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set fullName(newValue: string) &#123;</span><br><span class="line">        this.name = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">abstract class Department &#123;</span><br><span class="line">    constructor(public name: string) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printName(): void &#123;</span><br><span class="line">        console.log(&apos;Department name: &apos; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract printMeeting(): void; // 必须在派生类中实现</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class AccountingDepartment extends Department &#123;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super(&apos;Accounting and Auditing&apos;); // 在派生类的构造函数中必须调用 super()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printMeeting(): void &#123;</span><br><span class="line">        console.log(&apos;The Accounting Department meets each Monday at 10am.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    generateReports(): void &#123;</span><br><span class="line">        console.log(&apos;Generating accounting reports...&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="3-接口"><a href="#3-接口" class="headerlink" title="3.接口"></a>3.接口</h3><p>接口规范了应用对象的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ISum &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    y?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sum (&#123; x, y &#125;: ISum): number &#123;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface IAb &#123;</span><br><span class="line">  a: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IBc extends IAb &#123;</span><br><span class="line">  b: string;</span><br><span class="line">  c: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>索引类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface IArrayC &#123;</span><br><span class="line">    [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line">const c: IArrayC = [&quot;icepy&quot;, &quot;hunan&quot;];</span><br><span class="line">c[0];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface IObjectO &#123;</span><br><span class="line">    [key: string]: number;</span><br><span class="line">&#125;</span><br><span class="line">const o: IObjectO = &#123;</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">o[age]</span><br></pre></td></tr></table></figure></p><p>implements接口实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    setTime(d: Date): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    constructor() &#123; </span><br><span class="line">        this.currentTime = new Date();</span><br><span class="line">    &#125;</span><br><span class="line">    setTime(d: Date) &#123;</span><br><span class="line">        this.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PS：as类型断言。<br>告诉编译器，我认为这个对象是XXX类型的，你别瞎操心了。要不然由于类型不对，编译器会阻止你赋值，编译的时候直接报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface ICheckPoint &#123;</span><br><span class="line">  x: number;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function create(config: ICheckPoint): void &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">create(&#123; xx: 0, x: 0, y: 1 &#125; as ICheckPoint)</span><br></pre></td></tr></table></figure></p><hr><h3 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4.泛型"></a>4.泛型</h3><p>基本用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function r&lt;T&gt;(args: T): T &#123;</span><br><span class="line">    return args;</span><br><span class="line">&#125;</span><br><span class="line">r(&quot;cmh&quot;);</span><br><span class="line">r(100);</span><br><span class="line">r(true);</span><br></pre></td></tr></table></figure></p><p>泛型类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class GenericsClass&lt;T&gt;&#123;</span><br><span class="line">  public add?: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const cls = new GenericsClass&lt;number&gt;();</span><br><span class="line">cls.add = (x: number, y: number): number =&gt; &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>泛型约束：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//extends 继承了一个接口进而对泛型的数据结构进行了限制</span><br><span class="line">interface Lengthwise &#123;</span><br><span class="line">  length:number</span><br><span class="line">&#125;</span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg:T):T &#123;</span><br><span class="line">  console.log(arg.length)</span><br><span class="line">  return arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="5-模块类型声明"><a href="#5-模块类型声明" class="headerlink" title="5.模块类型声明"></a>5.模块类型声明</h3><p>在目前的 Web 前端工程中，大部分情况下我们都会在 JavaScript 引入样式，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;./style.css&quot;</span><br></pre></td></tr></table></figure></p><p>当这样的范例有时候编译器并不能编译通过，也许我们可以定义一个通用的模块，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare module &quot;*.css&quot;;</span><br></pre></td></tr></table></figure></p><p>当然，你也可以使用 require 语句来导入一个样式文件。</p><p>由于在我们的工作中，会引用到很多第三方的模块，由于历史的原因，可能很多第三方模块，用了 AMD 或者 commonjs，或者它们压根就没有 TypeScript 的声明文件，重要的是我们都可以定义一个自己的描述文件，起码可以让程序 Run 起来。</p><p>举例：</p><p>我们在解析一个 url 时用了一个第三方包来完成，但是当他将第三方包引入到工程中时发现报错了，于是他自己定义了一个模块声明来处理这个错误，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare module &quot;url&quot; &#123;</span><br><span class="line">  export function parse(urlStr: string) =&gt; string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以在工程中创建一个 typing 目录，编译器会自动的读取这个声明文件。</p><p>但是目前看起来工程中的错误，还是没有解决，因为它是一个 commonjs 的模块，由于 commonjs 中定义了 module.exports 和 exports，根据官方给出的建议是使用 var d = require(“xxx”)，但是对于有风格洁癖的人来说，这很不好看，但是我们可以从中遵循它的规则，由于 exports 的关系，以及现代编译器编译的规则，假设是导出了主模块，那么我们可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import g from &quot;xx&quot;;</span><br><span class="line"></span><br><span class="line">g.default()</span><br></pre></td></tr></table></figure></p><p>假设，我们的 commonjs 是使用的 exports ，那么我们可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as g from &quot;xx&quot;;</span><br></pre></td></tr></table></figure></p><p>来解决这个问题。</p><hr><h3 id="6-type"><a href="#6-type" class="headerlink" title="6.type"></a>6.type</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;;</span><br><span class="line">function animation(dur: number, easing: Easing)&#123;</span><br><span class="line">    if (easing === &quot;ease-in&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; else if (easing === &quot;ease-out&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; else if (easing === &quot;ease-in-out&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new Error(&quot;animation easing error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二、与React结合"><a href="#二、与React结合" class="headerlink" title="二、与React结合"></a>二、与React结合</h2><h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>无状态组件指的是没有自身的state的组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export interface IProps &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">export const Bar: React.SFC&lt;IProps&gt; = (props: IProps) =&gt; &#123;</span><br><span class="line">    const &#123;name, age&#125; = props;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;span&gt;&#123;name&#125;&lt;span&gt;</span><br><span class="line">            &lt;span&gt;&#123;age&#125;&lt;span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h3><p>既有props，又有state的一般组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">export interface IProps &#123;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface IState &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends React.Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">  constructor(props: IProps) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public setName = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      name: &quot;chambers&quot;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public render()&#123;</span><br><span class="line">    const &#123; name &#125; = this.state;</span><br><span class="line">    const &#123; age &#125; = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">         &lt;div onClick=&#123;this.setName&#125;&gt; set name &lt;/div&gt;</span><br><span class="line">         &lt;div&gt;&#123;name&#125; &#123;age&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Router组件"><a href="#Router组件" class="headerlink" title="Router组件"></a>Router组件</h3><p>当要使用到react-router上的props时，往往要继承一下它的type。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import &#123; RouteComponentProps &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">export interface IProps extends RouteComponentProps&lt;any&gt;&#123;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface IState &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends React.Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">  constructor(props: IProps) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public routeTo = () =&gt; &#123;</span><br><span class="line">    this.props.history.push(&quot;/&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public render()&#123;</span><br><span class="line">    const &#123; name &#125; = this.state;</span><br><span class="line">    const &#123; age &#125; = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">         &lt;div onClick=&#123;this.routeTo&#125;&gt; route to &lt;/div&gt;</span><br><span class="line">         &lt;div&gt;&#123;name&#125; &#123;age&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、入门介绍&quot;&gt;&lt;a href=&quot;#一、入门介绍&quot; class=&quot;headerlink&quot; title=&quot;一、入门介绍&quot;&gt;&lt;/a&gt;一、入门介绍&lt;/h2&gt;&lt;h3 id=&quot;1-基础类型&quot;&gt;&lt;a href=&quot;#1-基础类型&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="TypeScript" scheme="http://yoursite.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>canvas世界</title>
    <link href="http://yoursite.com/2018/10/29/canvas%E4%B8%96%E7%95%8C/"/>
    <id>http://yoursite.com/2018/10/29/canvas世界/</id>
    <published>2018-10-28T16:00:00.000Z</published>
    <updated>2018-10-25T11:42:38.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基础详解"><a href="#一、基础详解" class="headerlink" title="一、基础详解"></a>一、基础详解</h2><h3 id="1-画线"><a href="#1-画线" class="headerlink" title="1.画线"></a>1.画线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;500&quot; &gt;&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">var canvas1 = document.getElementById(&quot;canvas&quot;);</span><br><span class="line">var ctx = canvas1.getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">ctx.moveTo(100,100);</span><br><span class="line">ctx.lineTo(300,300);</span><br><span class="line">ctx.lineTo(400,300);</span><br><span class="line">ctx.lineWidth = 10; //线粗</span><br><span class="line">ctx.strokeStyle = &apos;green&apos;;  //stroke的颜色</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>moveto和lineto方法可以多次使用。最后，还可以使用closePath方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。</p><hr><h3 id="2-要想独立开每个图形，可以用beginPath-来声明新路径的开始，否则，后面的状态会覆盖前面的状态"><a href="#2-要想独立开每个图形，可以用beginPath-来声明新路径的开始，否则，后面的状态会覆盖前面的状态" class="headerlink" title="2.要想独立开每个图形，可以用beginPath()来声明新路径的开始，否则，后面的状态会覆盖前面的状态"></a>2.要想独立开每个图形，可以用beginPath()来声明新路径的开始，否则，后面的状态会覆盖前面的状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">...</span><br><span class="line">ctx.stroke();</span><br><span class="line">ctx.beginPath();</span><br><span class="line">...</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><hr><h3 id="3-绘制封闭的多边形，用beginPath-和closePath"><a href="#3-绘制封闭的多边形，用beginPath-和closePath" class="headerlink" title="3.绘制封闭的多边形，用beginPath()和closePath();"></a>3.绘制封闭的多边形，用beginPath()和closePath();</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">...</span><br><span class="line">ctx.closePath();</span><br></pre></td></tr></table></figure><hr><h3 id="4-填充颜色"><a href="#4-填充颜色" class="headerlink" title="4.填充颜色"></a>4.填充颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillStyle = &apos;green&apos;;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><hr><h3 id="5-矩形绘制"><a href="#5-矩形绘制" class="headerlink" title="5.矩形绘制"></a>5.矩形绘制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ctx.rect(x,y,width,height);   //(左上角x坐标，左上角y坐标，宽，高)</span><br><span class="line"></span><br><span class="line">//下面更加方便的，上面的还要stroke或者fill：</span><br><span class="line">ctx.fillRect(x,y,width,height);</span><br><span class="line">ctx.strokeRect(x,y,width,height);</span><br><span class="line"></span><br><span class="line">//清除</span><br><span class="line">ctx.clearRect(x,y,width,height);</span><br></pre></td></tr></table></figure><hr><h3 id="6-线帽"><a href="#6-线帽" class="headerlink" title="6.线帽"></a>6.线帽</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.lineCap = &apos;butt&apos;;     //一般，不突出</span><br><span class="line">ctx.lineCap = &apos;round&apos;;    //圆形</span><br><span class="line">ctx.lineCap = &apos;square&apos;;   //方形</span><br></pre></td></tr></table></figure><hr><h3 id="7-虚线"><a href="#7-虚线" class="headerlink" title="7.虚线"></a>7.虚线</h3><p>用 setLineDash 方法和 lineDashOffset 属性来制定虚线样式. setLineDash 方法接受一个数组，来指定线段与间隙的交替；lineDashOffset属性设置起始偏移量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.setLineDash([20, 5]);  // [实线长度, 间隙长度]</span><br><span class="line">ctx.lineDashOffset = -0;</span><br><span class="line">ctx.strokeRect(50, 50, 210, 210);</span><br><span class="line"></span><br><span class="line">ps：</span><br><span class="line">getLineDash(); //返回一个包含当前虚线样式，长度为非负偶数的数组。</span><br></pre></td></tr></table></figure><hr><h3 id="8-线条交界处的表现形式"><a href="#8-线条交界处的表现形式" class="headerlink" title="8.线条交界处的表现形式"></a>8.线条交界处的表现形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.lineJoin=&quot;miter|bevel|round&quot;;//（尖角(默认)，斜角，圆角）</span><br><span class="line">ctx.miterLimit = 10;//（限制尖角的延伸，超过10就变成斜角）</span><br></pre></td></tr></table></figure><hr><h3 id="9-图形变换（效果会叠加）"><a href="#9-图形变换（效果会叠加）" class="headerlink" title="9.图形变换（效果会叠加）"></a>9.图形变换（效果会叠加）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.translate(x,y);   //左上角的原点移动到（x,y）处</span><br><span class="line">ctx.rotate(deg);  //旋转</span><br><span class="line">ctx.scale(sx,sy); //缩放（它不仅放大宽高，他还放大坐标、线宽！！）</span><br></pre></td></tr></table></figure><hr><h3 id="10-设置变换矩阵（略）"><a href="#10-设置变换矩阵（略）" class="headerlink" title="10.设置变换矩阵（略）"></a>10.设置变换矩阵（略）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.transform(a,b,c,d,e,f);</span><br><span class="line">ctx.setTransform(a,b,c,d,e,f);</span><br></pre></td></tr></table></figure><hr><h3 id="11-状态保存还原"><a href="#11-状态保存还原" class="headerlink" title="11.状态保存还原"></a>11.状态保存还原</h3><p>save方法用于保存上下文环境，restore方法用于恢复到上一次保存的上下文环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ctx.save();</span><br><span class="line"></span><br><span class="line">ctx.shadowOffsetX = 10;</span><br><span class="line">ctx.shadowOffsetY = 10;</span><br><span class="line">ctx.shadowBlur = 5;</span><br><span class="line">ctx.shadowColor = &apos;rgba(0,0,0,0.5)&apos;;</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = &apos;#CC0000&apos;;</span><br><span class="line">ctx.fillRect(10,10,150,100);</span><br><span class="line"></span><br><span class="line">ctx.restore();</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = &apos;#000000&apos;;</span><br><span class="line">ctx.fillRect(180,10,150,100);</span><br></pre></td></tr></table></figure></p><p>上面代码先用save方法，保存了当前设置，然后绘制了一个有阴影的矩形。接着，使用restore方法，恢复了保存前的设置，绘制了一个没有阴影的矩形。</p><hr><h3 id="12-渐变"><a href="#12-渐变" class="headerlink" title="12.渐变"></a>12.渐变</h3><p>线性渐变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var grd = ctx.createLinearGradient(xstart,ystart,xend,yend);      //创建线性渐变</span><br><span class="line">grd.addColorStop(stop,color);     //在某个位置创建某种颜色</span><br></pre></td></tr></table></figure></p><p>径向渐变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var grd = ctx.createRadialGradient(x0,y0,r0,x1,y1,r1);      //创建径向渐变</span><br><span class="line">grd.addColorStop(stop,color);     //在某个位置创建某种颜色</span><br></pre></td></tr></table></figure></p><hr><h3 id="13-创建样式"><a href="#13-创建样式" class="headerlink" title="13.创建样式"></a>13.创建样式</h3><p>图片型样式，第一个参数是一个img或者canvas或者video，第二个参数是’no-repeat’’repeat-x’’repeat-y’’repeat’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var pattern = createPattern(type,repeat-style);</span><br><span class="line">ctx.fillStyle = pattern;</span><br></pre></td></tr></table></figure></p><hr><h3 id="14-圆弧"><a href="#14-圆弧" class="headerlink" title="14.圆弧"></a>14.圆弧</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ctx.arc(圆心x，圆心y，r，起始度数，结束度数，顺时针为false|逆时针为true)</span><br><span class="line">ctx.moveTo(x0,y0);</span><br><span class="line">ctx.arcTo(x1,y1,x2,y2,r);     //x0,y0是起始点，x1,y1是控制点，x2,y2是结束点</span><br><span class="line"></span><br><span class="line">//顺逆时针分别画圆</span><br><span class="line">function draw(ctx, x) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, 500, 500);</span><br><span class="line">    if (x &lt; Math.PI*2) &#123;</span><br><span class="line">        x += 0.05;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        x = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.strokeStyle = &apos;#ff4444&apos;;</span><br><span class="line">    ctx.arc(80, 80, 50, 0, x, false); // 顺时针</span><br><span class="line">    ctx.stroke();</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.strokeStyle = &apos;#000&apos;;</span><br><span class="line">    ctx.arc(200, 80, 50, 0, Math.PI*2 - x, true); // 逆时针</span><br><span class="line">    ctx.stroke();</span><br><span class="line"></span><br><span class="line">    requestAnimationFrame(function () &#123;</span><br><span class="line">        draw(ctx, x);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">draw(ctx, 0);</span><br></pre></td></tr></table></figure><hr><h3 id="15-弯月示例"><a href="#15-弯月示例" class="headerlink" title="15.弯月示例"></a>15.弯月示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctx.arc(400,400,300,0.5*Math.PI,1.5*Math.PI,true);  //月亮的外弯</span><br><span class="line">ctx.moveTo(400,100);</span><br><span class="line">ctx.arcTo(1200,400,400,700,(400-100)*dis(400,100,1200,400)/(1200-400));     //月亮的内弯</span><br><span class="line">ctx.stroke();</span><br><span class="line">function dis(x1,y1,x2,y2)&#123;</span><br><span class="line">    return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));</span><br><span class="line">&#125;   //计算内弯半径</span><br></pre></td></tr></table></figure><hr><h3 id="16-用贝塞尔曲线绘制"><a href="#16-用贝塞尔曲线绘制" class="headerlink" title="16.用贝塞尔曲线绘制"></a>16.用贝塞尔曲线绘制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(x0,y0);</span><br><span class="line"></span><br><span class="line">//贝塞尔二次曲线，x0,y0是起始点，x1,y1是控制点，x2,y2是结束点</span><br><span class="line">ctx.quadraticCurveTo(x1,y1,x2,y2);  </span><br><span class="line"></span><br><span class="line">//贝塞尔三次曲线，x0,y0是起始点，x1,y1是控制点，x2,y2是控制点，x3,y3是结束点  </span><br><span class="line">ctx.bezierCurveTo(x1,y1,x2,y2,x3,y3);</span><br></pre></td></tr></table></figure><hr><h3 id="17-文字"><a href="#17-文字" class="headerlink" title="17.文字"></a>17.文字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var pattern = ctx.createPattern(img,&apos;repeat&apos;);</span><br><span class="line">ctx.fillStyle = pattern;      //这样可以把图片样式应用在文字上</span><br><span class="line">ctx.font = &apos;normal|italic|oblique     //font-style:普通，斜体字，倾斜字体</span><br><span class="line">            normal|small-caps         //font-variant:普通，字母样式改变</span><br><span class="line">            normal|lighter|bold|bolder    //font-weight:普通，细，加粗，更粗（但是浏览器渲染只有normal和bold两种表现形式）</span><br><span class="line">            40px </span><br><span class="line">            Arial&apos;;</span><br><span class="line">ctx.textAlign = &apos;left|center|right&apos;;  //文本左右对齐</span><br><span class="line">ctx.textBaseline = &apos;top|middle|bottom|alphabetic|ideographic&apos;;  //文本上下对齐</span><br><span class="line">ctx.fillText(string,x,y,maxWidth);</span><br><span class="line">ctx.strokeText(string,x,y,maxWidth);</span><br><span class="line">ctx.measureText(string).width;    //度量传入字符串在页面中渲染出来的宽度</span><br></pre></td></tr></table></figure><hr><h3 id="18-阴影"><a href="#18-阴影" class="headerlink" title="18.阴影"></a>18.阴影</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctx.shadowColor = &apos;black&apos;;    //阴影颜色</span><br><span class="line">ctx.shadowOffsetX = 20;       //阴影水平偏移</span><br><span class="line">ctx.shadowOffsetY = 20;       //阴影垂直偏移</span><br><span class="line">ctx.shadowBlur = 10;          //阴影模糊度</span><br></pre></td></tr></table></figure><hr><h3 id="19-全局透明度"><a href="#19-全局透明度" class="headerlink" title="19.全局透明度"></a>19.全局透明度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.globalAlpha = 0.6;  //1是默认不透明</span><br></pre></td></tr></table></figure><hr><h3 id="20-覆盖时产生的效果"><a href="#20-覆盖时产生的效果" class="headerlink" title="20.覆盖时产生的效果"></a>20.覆盖时产生的效果</h3><p>我们总是将一个图形画在另一个之上，对于其他更多的情况，仅仅这样是远远不够的。比如，对合成的图形来说，绘制顺序会有限制。不过，我们可以利用 globalCompositeOperation 属性来改变这种状况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//默认后面的覆盖前面的|前面的覆盖后面的（还有很多，详情上网看）</span><br><span class="line">ctx.globalCompositeOperation = &apos;source-over|destination-over&apos;</span><br></pre></td></tr></table></figure><hr><h3 id="21-裁剪"><a href="#21-裁剪" class="headerlink" title="21.裁剪"></a>21.裁剪</h3><p>把已经创建的路径转换成裁剪路径。裁剪路径的作用是遮罩。只显示裁剪路径内的区域，裁剪路径外的区域会被隐藏。ps：clip()只能遮罩在这个方法调用之后绘制的图像，如果是clip()方法调用之前绘制的图像，则无法实现遮罩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.clip();</span><br></pre></td></tr></table></figure></p><hr><h3 id="22-利用非零环绕原则实现剪纸效果"><a href="#22-利用非零环绕原则实现剪纸效果" class="headerlink" title="22.利用非零环绕原则实现剪纸效果"></a>22.利用非零环绕原则实现剪纸效果</h3><p>（从需要判断的区域射一条线到外面，经过的线条方向不一致那就是属于图形外，否则就是图形内）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(400,400,300,0,Math.PI*2,false);</span><br><span class="line">ctx.arc(400,400,150,0,Math.PI*2,true);</span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.fillStyle = &apos;#058&apos;;</span><br><span class="line">ctx.shadowColor = &apos;grey&apos;;</span><br><span class="line">ctx.shadowOffsetX = 10;</span><br><span class="line">ctx.shadowOffsetY = 10;</span><br><span class="line">ctx.shadowBlur = 10;</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure></p><hr><h3 id="23-判断鼠标所在位置是否在指定目标中"><a href="#23-判断鼠标所在位置是否在指定目标中" class="headerlink" title="23.判断鼠标所在位置是否在指定目标中"></a>23.判断鼠标所在位置是否在指定目标中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = e.clientX - canvas.getBoundingClientRect().left;  //获取鼠标在canvas中的x位置</span><br><span class="line">var y = e.clientY - canvas.getBoundingClientRect().top;   //获取鼠标在canvas中的y位置</span><br><span class="line">ctx.isPointInPath(x,y);   //在绘制图形内就为true，否则为false</span><br></pre></td></tr></table></figure><hr><h3 id="24-扩展context"><a href="#24-扩展context" class="headerlink" title="24.扩展context"></a>24.扩展context</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CanvasRenderingContext2D.prototype.fillStar = function()&#123;...&#125;</span><br><span class="line">//可以这样来记录上一个moveTo的点的地方</span><br><span class="line">var originalMoveTo = CanvasRenderingContext2D.prototype.moveTo;</span><br><span class="line">CanvasRenderingContext2D.prototype.lastMoveToLoc = &#123;&#125;;</span><br><span class="line">CanvasRenderingContext2D.prototype.moveTo = function(x,y)&#123;</span><br><span class="line">  originalMoveTo.apply(this,[x,y]);</span><br><span class="line">  this.lastMoveToLoc.x = x;    </span><br><span class="line">  this.lastMoveToLoc.y = y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="25-IE6-7-8的兼容问题"><a href="#25-IE6-7-8的兼容问题" class="headerlink" title="25.IE6,7,8的兼容问题"></a>25.IE6,7,8的兼容问题</h3><p>用explorecanvas</p><hr><h3 id="26-Canvas图形库"><a href="#26-Canvas图形库" class="headerlink" title="26.Canvas图形库"></a>26.Canvas图形库</h3><p>canvasplus：https:code.google.com/p/canvasplus/</p><p>artisan js：http:artisanjs.com/</p><p>Rgraph：https:roopons.com.au/wp-content/plugins/viral-optins/js/rgraph/</p><hr><h3 id="27-获取图像像素"><a href="#27-获取图像像素" class="headerlink" title="27.获取图像像素"></a>27.获取图像像素</h3><p>getImageData方法可以用来读取Canvas的内容，返回一个对象，包含了每个像素的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var imageData = ctx.getImageData(x,y,w,h);</span><br><span class="line">imageData.width;</span><br><span class="line">imageData.height;</span><br><span class="line">imageData.data;</span><br></pre></td></tr></table></figure></p><hr><h3 id="28-置入图像数据"><a href="#28-置入图像数据" class="headerlink" title="28.置入图像数据"></a>28.置入图像数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.putImageData(imageData,dx,dy,dirtyX,dirtyY,dirtyW,dirtyH)</span><br></pre></td></tr></table></figure><hr><h3 id="29-把图像画入画布"><a href="#29-把图像画入画布" class="headerlink" title="29.把图像画入画布"></a>29.把图像画入画布</h3><p>由于图像的载入需要时间，drawImage方法只能在图像完全载入后才能调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var image = new Image();</span><br><span class="line"></span><br><span class="line">image.onload = function() &#123;</span><br><span class="line">  var canvas = document.createElement(&apos;canvas&apos;);</span><br><span class="line">  canvas.width = image.width;</span><br><span class="line">  canvas.height = image.height;</span><br><span class="line">  canvas.getContext(&apos;2d&apos;).drawImage(image, 0, 0);</span><br><span class="line">  // 插入页面底部</span><br><span class="line">  document.body.appendChild(image);</span><br><span class="line">  return canvas;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">image.src = &apos;image.png&apos;;</span><br><span class="line"></span><br><span class="line">var imageData = ctx.createImageData(w,h);</span><br></pre></td></tr></table></figure></p><hr><h3 id="30-导出生成图片"><a href="#30-导出生成图片" class="headerlink" title="30.导出生成图片"></a>30.导出生成图片</h3><p>对图像数据做出修改以后，可以使用toDataURL方法，将Canvas数据重新转化成一般的图像文件形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function convertCanvasToImage(canvas) &#123;</span><br><span class="line">  var image = new Image();</span><br><span class="line">  image.src = canvas.toDataURL(&apos;image/png&apos;);</span><br><span class="line">  return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码将Canvas数据，转化成PNG data URI。</p><hr><h2 id="二、性能优化"><a href="#二、性能优化" class="headerlink" title="二、性能优化"></a>二、性能优化</h2><h3 id="31-离屏渲染"><a href="#31-离屏渲染" class="headerlink" title="31.离屏渲染"></a>31.离屏渲染</h3><p>我们可以把离屏 Canvas 理解为一个预渲染的机制，我们通过先绘制好整块图案，之后在局部区域时就不需要再进行反复的图片渲染，在 drawImage 中可以直接对图片进行裁剪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var m_canvas = document.createElement(&apos;canvas&apos;);</span><br><span class="line">m_canvas.width = 64;    // 渲染整体</span><br><span class="line">m_canvas.height = 64;</span><br><span class="line">var m_context = m_canvas.getContext(‘2d’);</span><br><span class="line">draw(m_context);</span><br><span class="line">function render() &#123;</span><br><span class="line">  context.drawImage(m_canvas, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="32-一次绘制"><a href="#32-一次绘制" class="headerlink" title="32.一次绘制"></a>32.一次绘制</h3><p>绘制操作会消耗比较多的资源，所以最好是一次绘制，将命令全部存储到缓冲区中。</p><p>优化前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; points.length - 1; i++) &#123;</span><br><span class="line">  var p1 = points[i];</span><br><span class="line">  var p2 = points[i+1];</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.moveTo(p1.x, p1.y);</span><br><span class="line">  context.lineTo(p2.x, p2.y);</span><br><span class="line">  context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优化后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath();</span><br><span class="line">for (var i = 0; i &lt; points.length - 1; i++) &#123;</span><br><span class="line">  var p1 = points[i];</span><br><span class="line">  var p2 = points[i+1];</span><br><span class="line">  context.moveTo(p1.x, p1.y);</span><br><span class="line">  context.lineTo(p2.x, p2.y);</span><br><span class="line">&#125;</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure></p><hr><h3 id="33-避免浮点数坐标"><a href="#33-避免浮点数坐标" class="headerlink" title="33.避免浮点数坐标"></a>33.避免浮点数坐标</h3><p>浏览器为了抗锯齿会对浮点数进行额外的处理，可以通过数学类函数进行取整操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.drawImage(myImage, Math.floor(0.3), Math.floor(0.5));</span><br></pre></td></tr></table></figure></p><hr><h3 id="34-使用多个画布渲染复杂的场景"><a href="#34-使用多个画布渲染复杂的场景" class="headerlink" title="34.使用多个画布渲染复杂的场景"></a>34.使用多个画布渲染复杂的场景</h3><p>对于一些复杂的场景，可以将不变的场景和变化的物体进行区分渲染，下面是一段 demo，这样需要变更并渲染的像素更小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;stage&quot;&gt;</span><br><span class="line">  &lt;canvas id=&quot;ui-layer&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;canvas id=&quot;game-layer&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;canvas id=&quot;background-layer&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style&gt;</span><br><span class="line">  #stage &#123;</span><br><span class="line">    width: 480px;</span><br><span class="line">    height: 320px;</span><br><span class="line">    position: relative;</span><br><span class="line">    border: 2px solid black</span><br><span class="line">  &#125;</span><br><span class="line">  canvas &#123; position: absolute; &#125;</span><br><span class="line">  #ui-layer &#123; z-index: 3 &#125;</span><br><span class="line">  #game-layer &#123; z-index: 2 &#125;</span><br><span class="line">  #background-layer &#123; z-index: 1 &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="35-如果不用透明度的话，可以关闭透明度"><a href="#35-如果不用透明度的话，可以关闭透明度" class="headerlink" title="35.如果不用透明度的话，可以关闭透明度"></a>35.如果不用透明度的话，可以关闭透明度</h3><p>如果你的游戏使用画布而且不需要透明，当使用 HTMLCanvasElement.getContext() 创建一个绘图上下文时把 alpha 选项设置为 false 。这个选项可以帮助浏览器进行内部优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ctx = canvas.getContext(&apos;2d&apos;, &#123; alpha: false &#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="36-有动画，请使用window-requestAnimationFrame-而不是window-setInterval"><a href="#36-有动画，请使用window-requestAnimationFrame-而不是window-setInterval" class="headerlink" title="36.有动画，请使用window.requestAnimationFrame() 而不是window.setInterval()"></a>36.有动画，请使用window.requestAnimationFrame() 而不是window.setInterval()</h3><hr><h3 id="37-尽量利用CSS"><a href="#37-尽量利用CSS" class="headerlink" title="37.尽量利用CSS"></a>37.尽量利用CSS</h3><p>背景图</p><p>如果有大的静态背景图，直接绘制到 canvas可能并不是一个很好的做法，如果可以，将这个大背景图作为 background-image 放在一个 DOM元素上(例如，一个div)，然后将这个元素放到 canvas后面，这样就少了一个canvas的绘制渲染。</p><p>transform变幻</p><p>CSS的 transform性能优于 canvas的 transfomr API，因为前者基于可以很好地利用 GPU，所以如果可以，transform变幻请使用 CSS来控制。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、基础详解&quot;&gt;&lt;a href=&quot;#一、基础详解&quot; class=&quot;headerlink&quot; title=&quot;一、基础详解&quot;&gt;&lt;/a&gt;一、基础详解&lt;/h2&gt;&lt;h3 id=&quot;1-画线&quot;&gt;&lt;a href=&quot;#1-画线&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
      <category term="canvas" scheme="http://yoursite.com/categories/canvas/"/>
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Rxjs学习笔记</title>
    <link href="http://yoursite.com/2018/10/22/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARxjs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/22/深入浅出Rxjs学习笔记/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-22T16:19:12.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入浅出Rxjs"><a href="#深入浅出Rxjs" class="headerlink" title="深入浅出Rxjs"></a>深入浅出Rxjs</h2><p>RxJS，简单来说，它将一切数据，包括HTTP请求，DOM事件或者普通数据等包装成流的形式，然后用强大丰富的操作符对流进行处理，使你能以同步编程的方式处理异步数据，并组合不同的操作符来轻松优雅的实现你所需要的功能。</p><h2 id="零、举个栗子"><a href="#零、举个栗子" class="headerlink" title="零、举个栗子"></a>零、举个栗子</h2><p>先从几个例子来认识一下Rxjs的书写方式</p><h3 id="1-测点击时间，然后上报给服务器"><a href="#1-测点击时间，然后上报给服务器" class="headerlink" title="1.测点击时间，然后上报给服务器"></a>1.测点击时间，然后上报给服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const mouseDown$ = Rx.Observable.fromEvent(this.btn.current, &quot;mousedown&quot;);</span><br><span class="line">const mouseUp$ = Rx.Observable.fromEvent(this.btn.current, &quot;mouseup&quot;);</span><br><span class="line">const holdTime$ = mouseUp$</span><br><span class="line">                    .timestamp()</span><br><span class="line">                    .withLatestFrom(mouseDown$.timestamp(), (muEvent, mdEvent) =&gt; &#123;</span><br><span class="line">                        return muEvent.timestamp - mdEvent.timestamp;</span><br><span class="line">                    &#125;);</span><br><span class="line">holdTime$.subscribe((ms) =&gt; &#123;</span><br><span class="line">    console.log(ms);</span><br><span class="line">&#125;);</span><br><span class="line">holdTime$.flatMap((ms) =&gt; &#123;</span><br><span class="line">    return Rx.Observable.ajax(&quot;as&quot; + ms);</span><br><span class="line">&#125;)</span><br><span class="line">.subscribe((res) =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="2-普通observable推送给observer"><a href="#2-普通observable推送给observer" class="headerlink" title="2.普通observable推送给observer"></a>2.普通observable推送给observer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const ob$ = Rx.Observable.create((observer: any) =&gt; &#123;</span><br><span class="line">    let num: number = 0;</span><br><span class="line">    const timer = setInterval(() =&gt; &#123;</span><br><span class="line">        if (num &gt; 3) &#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">            observer.error(&quot;wrong&quot;);</span><br><span class="line">            observer.complete();</span><br><span class="line">        &#125;</span><br><span class="line">        observer.next(++num);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">const subscription = ob$</span><br><span class="line">    .filter((val: number) =&gt; &#123;</span><br><span class="line">        return val &gt; 2;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map((val: number) =&gt; &#123;</span><br><span class="line">        return val * 2;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(</span><br><span class="line">        (val: number) =&gt; &#123;</span><br><span class="line">            console.log(val);</span><br><span class="line">        &#125;,</span><br><span class="line">        (err: string) =&gt; &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            console.log(&quot;end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">&#125;, 6000);</span><br></pre></td></tr></table></figure><hr><h3 id="3-React-Rxjs版计数器"><a href="#3-React-Rxjs版计数器" class="headerlink" title="3.React+Rxjs版计数器"></a>3.React+Rxjs版计数器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">export default class Index extends Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">    public sub$: any;</span><br><span class="line">    constructor(props: IProps) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            count: 0</span><br><span class="line">        &#125;;</span><br><span class="line">        this.sub$ = new Subject();</span><br><span class="line">        this.sub$</span><br><span class="line">            .scan((cur: number, sum: number) =&gt; &#123;</span><br><span class="line">                return cur + sum;</span><br><span class="line">            &#125;, 0)</span><br><span class="line">            .subscribe((val: number) =&gt; &#123;</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    count: val</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public countFn(num: number) &#123;</span><br><span class="line">        this.sub$.next(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;Index&quot;&gt;</span><br><span class="line">                &lt;span&gt;&#123;this.state.count&#125;&lt;/span&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.countFn.bind(this, -1)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.countFn.bind(this, 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="一、observable介绍"><a href="#一、observable介绍" class="headerlink" title="一、observable介绍"></a>一、observable介绍</h2><h3 id="4-of"><a href="#4-of" class="headerlink" title="4.of"></a>4.of</h3><p>同步依次输出的数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1 2 3 end</span><br><span class="line">const ob$ = Rx.Observable.of(1, 2, 3);</span><br><span class="line">const sub = ob$.subscribe(</span><br><span class="line">        (val: any) =&gt; console.log(val),</span><br><span class="line">        (err: any) =&gt; console.log(err),</span><br><span class="line">        () =&gt; console.log(&quot;end&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="5-range"><a href="#5-range" class="headerlink" title="5.range"></a>5.range</h3><p>同步依次输出给定范围值的数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1 2 3 4 5 end</span><br><span class="line">const ob$ = Rx.Observable.range(1, 5);</span><br><span class="line">const sub = ob$.subscribe(</span><br><span class="line">        (val: any) =&gt; console.log(val),</span><br><span class="line">        (err: any) =&gt; console.log(err),</span><br><span class="line">        () =&gt; console.log(&quot;end&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="6-generate"><a href="#6-generate" class="headerlink" title="6.generate"></a>6.generate</h3><p>类似于for循环的数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1 3 5 7 end</span><br><span class="line">const ob$ = Rx.Observable.generate(</span><br><span class="line">        1,</span><br><span class="line">        (x) =&gt; x &lt; 8,</span><br><span class="line">        (x) =&gt; x + 2,</span><br><span class="line">        (x) =&gt; x + &quot;&quot;</span><br><span class="line">);</span><br><span class="line">const sub = ob$.subscribe(</span><br><span class="line">        (val: any) =&gt; console.log(val),</span><br><span class="line">        (err: any) =&gt; console.log(err),</span><br><span class="line">        () =&gt; console.log(&quot;end&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="7-repeat"><a href="#7-repeat" class="headerlink" title="7.repeat"></a>7.repeat</h3><p>重复数据源</p><p>它要明确收到上一个数据源的complete指令(但不会执行)后才会unsubscribe当前的数据源，而开始下一个数据源，所有重复动作完成前是不会执行complete的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//start 1 2 unsubscribe start 1 2 end unsubscribe</span><br><span class="line">const ob$ = Rx.Observable.create((observer: any) =&gt; &#123;</span><br><span class="line">        console.log(&quot;start&quot;);</span><br><span class="line">        setTimeout(() =&gt; observer.next(1), 1000);</span><br><span class="line">        setTimeout(() =&gt; observer.next(2), 2000);</span><br><span class="line">        setTimeout(() =&gt; observer.complete(), 3000);</span><br><span class="line">        return &#123;</span><br><span class="line">        unsubscribe: () =&gt; &#123;</span><br><span class="line">                console.log(&quot;unsubscribe&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">const re$ = ob$.repeat(2);</span><br><span class="line">const sub = re$.subscribe(</span><br><span class="line">        (val: any) =&gt; console.log(val),</span><br><span class="line">        (err: any) =&gt; console.log(err),</span><br><span class="line">        () =&gt; console.log(&quot;end&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="8-empty"><a href="#8-empty" class="headerlink" title="8.empty"></a>8.empty</h3><p>空数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//end</span><br><span class="line">const ob$ = Rx.Observable.empty();</span><br><span class="line">const sub = ob$.subscribe(</span><br><span class="line">        (val: any) =&gt; console.log(val),</span><br><span class="line">        (err: any) =&gt; console.log(err),</span><br><span class="line">        () =&gt; console.log(&quot;end&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="9-throw"><a href="#9-throw" class="headerlink" title="9.throw"></a>9.throw</h3><p>直接报错数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Error:wrong</span><br><span class="line">const ob$ = Rx.Observable.throw(new Error(&quot;wrong&quot;));</span><br><span class="line">const sub = ob$.subscribe(</span><br><span class="line">        (val: any) =&gt; console.log(val),</span><br><span class="line">        (err: any) =&gt; console.log(err),</span><br><span class="line">        () =&gt; console.log(&quot;end&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="10-never"><a href="#10-never" class="headerlink" title="10.never"></a>10.never</h3><p>什么都没有数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const ob$ = Rx.Observable.never();</span><br><span class="line">const sub = ob$.subscribe(</span><br><span class="line">        (val: any) =&gt; console.log(val),</span><br><span class="line">        (err: any) =&gt; console.log(err),</span><br><span class="line">        () =&gt; console.log(&quot;end&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="11-提示"><a href="#11-提示" class="headerlink" title="11.提示"></a>11.提示</h3><p>never、empty和throw单独使⽤没有意义，但是，在组合Observable对象时，如果需要这些特殊的Observable对象，这三个操作符可以直接使⽤，例如，根据条件是否产⽣出错的数据流如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source$.concat(shouldEndWell ? Observable.empty() : Observable.throw(new Error()));</span><br></pre></td></tr></table></figure><hr><h3 id="12-interval"><a href="#12-interval" class="headerlink" title="12.interval"></a>12.interval</h3><p>每隔一段时间推送一次（类似于setinterval）（默认从0开始逐1递增）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//每隔1秒输出一次0 2 4 6 8。。。</span><br><span class="line">const ob$ = Rx.Observable.interval(1000);</span><br><span class="line">ob$</span><br><span class="line">.map((val) =&gt; val * 2)</span><br><span class="line">.subscribe(</span><br><span class="line">        console.log,</span><br><span class="line">        undefined,</span><br><span class="line">        undefined</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="13-timer"><a href="#13-timer" class="headerlink" title="13.timer"></a>13.timer</h3><p>隔一段时间才推送</p><p>（类似于settimeout，不过它第二个参数是interval，也就是说可以实现interval的功能）（默认从0开始逐1递增）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//等2秒后输出1，然后1秒后输出2，再隔1秒后输出3....</span><br><span class="line">const ob$ = Rx.Observable.timer(2000, 1000);</span><br><span class="line">ob$</span><br><span class="line">.map((val) =&gt; val + 1)</span><br><span class="line">.subscribe(</span><br><span class="line">        console.log,</span><br><span class="line">        undefined,</span><br><span class="line">        undefined</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="14-from"><a href="#14-from" class="headerlink" title="14.from"></a>14.from</h3><p>包容性极强，可以把参数（字符串、数组、类数组、generator、promise等等）转化为数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//a s</span><br><span class="line">const ob$ = Rx.Observable.from(&quot;as&quot;);</span><br><span class="line">const sub = ob$.subscribe(</span><br><span class="line">        console.log,</span><br><span class="line">        undefined,</span><br><span class="line">        undefined</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="14-fromPromise"><a href="#14-fromPromise" class="headerlink" title="14.fromPromise"></a>14.fromPromise</h3><p>把promise转化为数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">const ob$ = Rx.Observable.fromPromise(</span><br><span class="line">        new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(1);</span><br><span class="line">        &#125;)</span><br><span class="line">);</span><br><span class="line">const sub = ob$.subscribe(</span><br><span class="line">        console.log,</span><br><span class="line">        console.log,</span><br><span class="line">        undefined</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="15-fromEvent"><a href="#15-fromEvent" class="headerlink" title="15.fromEvent"></a>15.fromEvent</h3><p>事件源转化为数据源（DOM事件和eventEmitter都行）（fromEventPattern略）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const ob$ = Rx.Observable.fromEvent(this.btn.current, &quot;click&quot;);</span><br><span class="line">const sub = ob$</span><br><span class="line">.map((e: any) =&gt; e.target.innerText)</span><br><span class="line">.subscribe(</span><br><span class="line">        console.log</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="16-ajax"><a href="#16-ajax" class="headerlink" title="16.ajax"></a>16.ajax</h3><p>rxjs的ajax</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const ob$ = Rx.Observable.fromEvent(this.btn.current, &quot;click&quot;);</span><br><span class="line">ob$.subscribe(</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">        Rx.Observable.ajax(&quot;https://api.github.com/repos/ReactiveX/rxjs&quot;)</span><br><span class="line">        .subscribe((res) =&gt; &#123;</span><br><span class="line">            console.log(&quot;rxjs有&quot; + res.response.stargazers_count + &quot;颗星&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="17-repeatWhen"><a href="#17-repeatWhen" class="headerlink" title="17.repeatWhen"></a>17.repeatWhen</h3><p>控制何时执行重复获取数据源这个动作，次数为无限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//123一秒后123一秒后123.。。</span><br><span class="line">const src$ = Rx.Observable.of(1, 2, 3);</span><br><span class="line">src$.repeatWhen((notification$) =&gt; &#123;</span><br><span class="line">        //notification$是一个subject</span><br><span class="line">        return notification$.delay(1000);</span><br><span class="line">&#125;)</span><br><span class="line">.subscribe(console.log);</span><br></pre></td></tr></table></figure><p>这样的效果跟楼上一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src$.repeatWhen(() =&gt; &#123;</span><br><span class="line">        return Rx.Observable.interval(1000);</span><br><span class="line">&#125;)</span><br><span class="line">.subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="18-defer"><a href="#18-defer" class="headerlink" title="18.defer"></a>18.defer</h3><p>延迟执行（订阅时才会执行代理的数据源）</p><p>⽐如，我们希望通过AJAX来获取服务器端的数据，可是并不想在程序启动阶段就把AJAX请求发送出去，<br>就可以利⽤defer产⽣⼀个Observable对象，当这个Observable对象被subscribe的时候才发送AJAX请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const obsFactory = () =&gt; Rx.Observable.ajax(&quot;https://api.github.com/repos/ReactiveX/rxjs&quot;);</span><br><span class="line">const ob$ = Rx.Observable.defer(obsFactory);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        ob$.subscribe(console.log);</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure><hr><h2 id="二、合并数据流"><a href="#二、合并数据流" class="headerlink" title="二、合并数据流"></a>二、合并数据流</h2><h3 id="19-concat"><a href="#19-concat" class="headerlink" title="19.concat"></a>19.concat</h3><p>首尾相连多个数据流</p><p>工作原理：</p><p>假设concat有两个输⼊，分别称为source1$和source2$。<br>source1$产⽣的所有数据全都被concat直接转给了下游，当source1$完结的时候，concat会调⽤source1$.unsubscribe，<br>然后调⽤source2$.subscribe，继续从source2$中抽取数据传给下游。</p><p>PS:concat开始从下⼀个Observable对象抽取数据只能在前⼀个Observable对象完结之后，<br>所以参与到这个concat之中的Observable对象应该都能完结，如果⼀个Observable对象不会完结，<br>那排在后⾯的Observable对象永远没有上场的机会</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ob1$ = Rx.Observable.of(1);</span><br><span class="line">const ob2$ = Rx.Observable.of(2);</span><br><span class="line">const ob3$ = Rx.Observable.of(3);</span><br><span class="line">const concat$ = ob1$.concat(ob2$, ob3$);</span><br><span class="line">concat$.subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="20-merge"><a href="#20-merge" class="headerlink" title="20.merge"></a>20.merge</h3><p>先到先处理，按时间顺序有序处理合并过来的数据流</p><p>PS:merge的最后一个参数是允许处理的最大数据量，如这里是2，所以后面的ob3$会忽略掉（除非ob1$或者ob2$结束了，才有空位让它执行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//0A 0B 1A 1B 2A 2B...</span><br><span class="line">const ob1$ = Rx.Observable.timer(0, 1000).map((x) =&gt; x + &quot;A&quot;);</span><br><span class="line">const ob2$ = Rx.Observable.timer(500, 1000).map((x) =&gt; x + &quot;B&quot;);</span><br><span class="line">const ob3$ = Rx.Observable.timer(1000, 1000).map((x) =&gt; x + &quot;C&quot;);</span><br><span class="line">ob1$.merge(ob2$, ob3$, 2).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="21-zip"><a href="#21-zip" class="headerlink" title="21.zip"></a>21.zip</h3><p>拉链式合并数据流，一一对应组合成数组</p><p>吐出数据最少的上游Observable决定了zip产⽣的数据个数。<br>zip在完结的时候，会退订所有的上游数据，所以ob1$这个“永生的”⽣命也会被终结。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//[0,1]一秒后[1,2]一秒后[2,3] end</span><br><span class="line">const ob1$ = Rx.Observable.interval(1000);</span><br><span class="line">const ob2$ = Rx.Observable.of(1, 2, 3);</span><br><span class="line">ob1$.zip(ob2$).subscribe(console.log, undefined, () =&gt; console.log(&quot;end&quot;));</span><br></pre></td></tr></table></figure><hr><h3 id="22-combineLatest"><a href="#22-combineLatest" class="headerlink" title="22.combineLatest"></a>22.combineLatest</h3><p>每次数据源有更新就播报一次最新数据</p><p>只有当所有上游Observable对象都完结之后，combineLatest才会给下游⼀个complete信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//[0,0] [1,0] [1,1] [2,1] [2,2]...</span><br><span class="line">const ob1$ = Rx.Observable.timer(0, 1000);</span><br><span class="line">const ob2$ = Rx.Observable.timer(500, 1000);</span><br><span class="line">const res$ = ob1$.combineLatest(ob2$).subscribe(console.log);</span><br><span class="line"></span><br><span class="line">//[&apos;c&apos;,1] [&apos;c&apos;,2] [&apos;c&apos;,3]</span><br><span class="line">const ob1$ = Rx.Observable.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">const ob2$ = Rx.Observable.of(1, 2, 3);</span><br><span class="line">const res$ = ob1$.combineLatest(ob2$).subscribe(console.log);</span><br><span class="line"></span><br><span class="line">//[&apos;0a&apos;,&apos;0b&apos;] [&apos;1a&apos;,&apos;0b&apos;] [&apos;1a&apos;,&apos;1b&apos;] [&apos;2a&apos;,&apos;1b&apos;] [&apos;2a&apos;,&apos;2b&apos;]...</span><br><span class="line">const original$ = Observable.timer(0, 1000);</span><br><span class="line">const source1$ = original$.map((x) =&gt; x + &quot;a&quot;);</span><br><span class="line">const source2$ = original$.map((x) =&gt; x + &quot;b&quot;);</span><br><span class="line">const result$ = source1$.combineLatest(source2$).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="23-withLatestFrom"><a href="#23-withLatestFrom" class="headerlink" title="23.withLatestFrom"></a>23.withLatestFrom</h3><p>ob1$才能引发，引发时拿到ob2$的最新数据来组合成数据源（ob2$不能引发）（用弹珠图比较好理解）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//101 203 305 407....</span><br><span class="line">const ob1$ = Rx.Observable.timer(0, 2000).map((x) =&gt; 100 * x);</span><br><span class="line">const ob2$ = Rx.Observable.timer(500, 1000);</span><br><span class="line">const res$ = ob1$.withLatestFrom(ob2$, (a, b) =&gt; a + b).subscribe(console.log);</span><br><span class="line"></span><br><span class="line">//这个可以解决combineLatest对于同步数据的“非同步”问题</span><br><span class="line">//x:12,y:34 x:65,y:87</span><br><span class="line">const event$ = Rx.Observable.fromEvent(document.body, &quot;click&quot;);</span><br><span class="line">const x$ = event$.map((e: any) =&gt; e.x);</span><br><span class="line">const y$ = event$.map((e: any) =&gt; e.y);</span><br><span class="line">const result$ = x$.combineLatest(y$, (x, y) =&gt; `x: $&#123;x&#125;, y: $&#123;y&#125;`).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="24-race"><a href="#24-race" class="headerlink" title="24.race"></a>24.race</h3><p>谁快谁就占领整条水管</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//0a 1a 2a 3a...</span><br><span class="line">const source1$ = Observable.timer(0, 2000).map((x) =&gt; x + &quot;a&quot;);</span><br><span class="line">const source2$ = Observable.timer(500, 1000).map((x) =&gt; x + &quot;b&quot;);</span><br><span class="line">const winner$ = source1$.race(source2$).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="25-startWith"><a href="#25-startWith" class="headerlink" title="25.startWith"></a>25.startWith</h3><p>在数据源头部插一条数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//-1 0 1 2 3...</span><br><span class="line">const ob$ = Rx.Observable.timer(0, 1000);</span><br><span class="line">const res$ = ob$.startWith(-1).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="26-forkJoin"><a href="#26-forkJoin" class="headerlink" title="26.forkJoin"></a>26.forkJoin</h3><p>rxjs里面的promise.all</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//3秒后输出[&quot;0a&quot;,&quot;2b&quot;]</span><br><span class="line">const source1$ = Observable.interval(1000).map((x) =&gt; x + &quot;a&quot;).take(1);</span><br><span class="line">const source2$ = Observable.interval(1000).map((x) =&gt; x + &quot;b&quot;).take(3);</span><br><span class="line">const concated$ = Observable.forkJoin(source1$, source2$).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="27-concatAll"><a href="#27-concatAll" class="headerlink" title="27.concatAll"></a>27.concatAll</h3><p>高阶observable的concat</p><p>只有当第⼀个Observable对象完结的时候，才会去订阅第⼆个内部Observable对象。<br>也就是说，虽然⾼阶Observable对象已经产⽣了第⼆个Observable对象，<br>不代表concatAll会⽴刻去订阅它，因为这个Observable对象是懒执⾏，<br>所以不去订阅⾃然也不会产⽣数据，最后⽣成1:0的时间也就被推迟到产⽣0:1之后。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//0:0 0:1 1:0 1:1</span><br><span class="line">const ho$ = Rx.Observable.interval(1000).take(2)</span><br><span class="line">.map((x) =&gt; Observable.interval(1500).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class="line">const res$ = ho$.concatAll().subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="28-mergeAll"><a href="#28-mergeAll" class="headerlink" title="28.mergeAll"></a>28.mergeAll</h3><p>高阶observable的merge</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//0:0 1:0 0:1 1:1</span><br><span class="line">const ho$ = Rx.Observable.interval(1000).take(2)</span><br><span class="line">.map((x) =&gt; Observable.interval(1500).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class="line">const res$ = ho$.mergeAll().subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="29-zipAll"><a href="#29-zipAll" class="headerlink" title="29.zipAll"></a>29.zipAll</h3><p>高阶observable的zip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//[0:0,1:0,2:0] [0:1,1:1,2:1]</span><br><span class="line">const ho$ = Rx.Observable.interval(1000).take(3)</span><br><span class="line">.map((x) =&gt; Observable.interval(1500).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class="line">const res$ = ho$.zipAll().subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="30-combineAll"><a href="#30-combineAll" class="headerlink" title="30.combineAll"></a>30.combineAll</h3><p>高阶observable的combineLatest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//[0:0,1:0] [0:1,1:0] [0:1,1:1]</span><br><span class="line">const ho$ = Rx.Observable.interval(1000).take(2)</span><br><span class="line">.map((x) =&gt; Observable.interval(1500).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class="line">const res$ = ho$.combineAll().subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="31-switch"><a href="#31-switch" class="headerlink" title="31.switch"></a>31.switch</h3><p>高阶observable，有新的外部observable产生，就切换到它上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//0:0 1:0 2:0 2:1</span><br><span class="line">const ho$ = Observable.interval(1000).take(3)</span><br><span class="line">.map((x) =&gt; Observable.interval(700).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class="line">const res$ = ho$.switch().subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="32-exhaust"><a href="#32-exhaust" class="headerlink" title="32.exhaust"></a>32.exhaust</h3><p>高阶observable，耗尽一个外部observable，再找下一个来耗尽</p><p>对于这个例⼦，exhaust⾸先从第⼀个内部Observable对象获取数据，<br>然后再考虑后续的内部Observable对象。第⼆个内部Observable⽣不逢时，<br>当它产⽣的时候第⼀个内部Observable对象还没有完结，这时候exhaust会<br>直接忽略第⼆个Observable对象，甚⾄不会去订阅它；第三个内部<br>Observable对象会被订阅并提取数据，是因为在它出现之前，第⼀个内部Observable对象已经完结了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//0:0 0:1 2:0 2:1</span><br><span class="line">const ho$ = Observable.interval(1000).take(3)</span><br><span class="line">.map((x) =&gt; Observable.interval(700).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class="line">const result$ = ho$.exhaust().subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h2 id="三、辅助型操作符"><a href="#三、辅助型操作符" class="headerlink" title="三、辅助型操作符"></a>三、辅助型操作符</h2><h3 id="33-count"><a href="#33-count" class="headerlink" title="33.count"></a>33.count</h3><p>数据个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//2</span><br><span class="line">const ob$ = Rx.Observable.timer(1000).concat(Rx.Observable.timer(1000));</span><br><span class="line">const res = ob$.count().subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="34-min-max"><a href="#34-min-max" class="headerlink" title="34.min/max"></a>34.min/max</h3><p>最小/大的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//&#123; name: &quot;RxJS&quot;, year: 2011 &#125; &#123; name: &quot;Redux&quot;, year: 2015 &#125;</span><br><span class="line">const intialRelease$ = Observable.of(</span><br><span class="line">        &#123; name: &quot;RxJS&quot;, year: 2011 &#125;,</span><br><span class="line">        &#123; name: &quot;React&quot;, year: 2013 &#125;,</span><br><span class="line">        &#123; name: &quot;Redux&quot;, year: 2015 &#125;</span><br><span class="line">);</span><br><span class="line">const min$ = intialRelease$.min((a: any, b: any) =&gt; a.year - b.year).subscribe(console.log);</span><br><span class="line">const max$ = intialRelease$.max((a: any, b: any) =&gt; a.year - b.year).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="35-reduce"><a href="#35-reduce" class="headerlink" title="35.reduce"></a>35.reduce</h3><p>类似于数组的reduce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//55</span><br><span class="line">const src$ = Rx.Observable.range(1, 10);</span><br><span class="line">const res$ = src$.reduce((sum, cur) =&gt; sum + cur, 0).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="36-every"><a href="#36-every" class="headerlink" title="36.every"></a>36.every</h3><p>类似于数组的every</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//false</span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const every$ = source$.every((x) =&gt; x &lt; 3).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="37-find-findIndex"><a href="#37-find-findIndex" class="headerlink" title="37.find/findIndex"></a>37.find/findIndex</h3><p>类似于数组的find/findIndex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//4 2</span><br><span class="line">const source$ = Observable.of(3, 1, 4, 1, 5, 9);</span><br><span class="line">const find$ = source$.find((x) =&gt; x % 2 === 0).subscribe(console.log);</span><br><span class="line">const findIndex$ = source$.findIndex((x) =&gt; x % 2 === 0).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="38-isEmpty-defaultIfEmpty"><a href="#38-isEmpty-defaultIfEmpty" class="headerlink" title="38.isEmpty/defaultIfEmpty"></a>38.isEmpty/defaultIfEmpty</h3><p>检查⼀个上游Observable对象是不是没有吐出任何数据就完结的Observable对象/如果上游是empty，那就输出default值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1秒后输出true,asas</span><br><span class="line">const source$ = Observable.create((observer: any) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; observer.complete(1), 1000);</span><br><span class="line">&#125;);</span><br><span class="line">const isEmpty$ = source$.isEmpty().subscribe(console.log);</span><br><span class="line">const deEmpty$ = source$.defaultIfEmpty(&quot;asas&quot;).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h2 id="四、过滤型操作符"><a href="#四、过滤型操作符" class="headerlink" title="四、过滤型操作符"></a>四、过滤型操作符</h2><h3 id="39-filter"><a href="#39-filter" class="headerlink" title="39.filter"></a>39.filter</h3><p>过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//0 2 4 6...</span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const even$ = source$.filter((x) =&gt; x % 2 === 0).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="40-first-last"><a href="#40-first-last" class="headerlink" title="40.first/last"></a>40.first/last</h3><p>取第一个/最后一个到达的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//[4,2] [10,4]</span><br><span class="line">const source$ = Observable.of(3, 1, 4, 1, 10, 9);</span><br><span class="line">const first$ = source$.first((x) =&gt; x % 2 === 0, (value, index) =&gt; [value, index]).subscribe(console.log);</span><br><span class="line">const last$ = source$.last((x) =&gt; x % 2 === 0, (value, index) =&gt; [value, index]).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="41-take"><a href="#41-take" class="headerlink" title="41.take"></a>41.take</h3><p>取多少个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//0 1 2</span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const last$ = source$.take(3).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="42-takeLast"><a href="#42-takeLast" class="headerlink" title="42.takeLast"></a>42.takeLast</h3><p>取后几个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//1 5 9</span><br><span class="line">const source$ = Observable.of(3, 1, 4, 1, 5, 9);</span><br><span class="line">const last3$ = source$.takeLast(3).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="42-takeWhile"><a href="#42-takeWhile" class="headerlink" title="42.takeWhile"></a>42.takeWhile</h3><p>一直取直到不符合传进去的条件函数为止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//3 1</span><br><span class="line">const source$ = Observable.of(3, 1, 4, 1, 5, 9);</span><br><span class="line">const last3$ = source$.takeWhile((x) =&gt; x &lt; 4).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="43-takeUntil"><a href="#43-takeUntil" class="headerlink" title="43.takeUntil"></a>43.takeUntil</h3><p>一直取第一个observable直到第二个observable有数据出来就不取了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//0 1</span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const notifier$ = Observable.timer(2500);</span><br><span class="line">const takeUntil$ = source$.takeUntil(notifier$).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="44-skip"><a href="#44-skip" class="headerlink" title="44.skip"></a>44.skip</h3><p>跳过头几个数据才输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//4秒后才输出3 4 5...</span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const skip$ = source$.skip(3);</span><br></pre></td></tr></table></figure><hr><h3 id="45-skipWhile"><a href="#45-skipWhile" class="headerlink" title="45.skipWhile"></a>45.skipWhile</h3><p>跳过头几个数据才输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//3秒后才输出2 3 4</span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const skip$ = source$.skipWhile((x) =&gt; x &lt; 2).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="46-skipUntil"><a href="#46-skipUntil" class="headerlink" title="46.skipUntil"></a>46.skipUntil</h3><p>跳过头几个数据才输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//3秒后才输出2 3 4</span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const notifier$ = Observable.timer(2500);</span><br><span class="line">const skip$ = source$.skipUntil(notifier$).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="47-throttleTime-debounceTime"><a href="#47-throttleTime-debounceTime" class="headerlink" title="47.throttleTime/debounceTime"></a>47.throttleTime/debounceTime</h3><p>节流，指定时间内只能触发一次;防抖，一定时间内没有新数据流入才触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//0 3 6...</span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const filter$ = source$.filter((x) =&gt; x % 3 === 0);</span><br><span class="line">const result$ = filter$.throttleTime(2000).subscribe(console.log);</span><br><span class="line"></span><br><span class="line">//2秒后输出0 3 6...</span><br><span class="line">const result2$ = filter$.debounceTime(2000).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="48-throttle"><a href="#48-throttle" class="headerlink" title="48.throttle"></a>48.throttle</h3><p>以observable节流</p><p>这个过程，相当于throttle每往下游传递⼀个数据，都关上了上下游之间闸门，只有当durationSelector产⽣数据的时候才打开这个闸门。到了2000毫秒的时刻，durationSelector第⼀次被调⽤产⽣的Observable对象终于产⽣了⼀个数据，闸门被打开，source$产⽣的第⼆个数据2正好赶上，被传递给了下游，同时关上闸门，这时候throttle会⽴刻退订上⼀次durationSelector返回的Observable对象，重新⽤数据2作为参数调⽤durationSelector来获得⼀个新的Observable对象，这个新的Observable对象产⽣数据的时候，闸门才会再次打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"># call durationSelector with 0</span><br><span class="line">0</span><br><span class="line"># call durationSelector with 2</span><br><span class="line">2</span><br><span class="line"># call durationSelector with 4</span><br><span class="line">4</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const durationSelector = (value: number) =&gt; &#123;</span><br><span class="line">        console.log(`# call durationSelector with $&#123;value&#125;`);</span><br><span class="line">        return Observable.timer(2000);</span><br><span class="line">&#125;;</span><br><span class="line">const result$ = source$.throttle(durationSelector).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="49-debounce"><a href="#49-debounce" class="headerlink" title="49.debounce"></a>49.debounce</h3><p>以observable防抖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1 2 4 5 7 8 10...</span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const durationSelector = (value: number) =&gt; &#123;</span><br><span class="line">        return Observable.timer(value % 3 === 0 ? 2000 : 1000);</span><br><span class="line">&#125;;</span><br><span class="line">const result$ = source$.debounce(durationSelector).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="50-auditTime-audit"><a href="#50-auditTime-audit" class="headerlink" title="50.auditTime/audit"></a>50.auditTime/audit</h3><p>可以认为audit是做throttle类似的⼯作，不同的是在“节流时间”范围内，throttle把第⼀个数据传给下游，audit是把最后⼀个数据传给下游。</p><p>audit和auditTime的关系跟throttle/throttleTime一样，就不赘述了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//1 3 5.。。</span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const result$ = source$.auditTime(2000).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="51-sampleTime"><a href="#51-sampleTime" class="headerlink" title="51.sampleTime"></a>51.sampleTime</h3><p>sampleTime会记录每⼀个时间块上游推下来的最后⼀个数据，到了每个时间块结尾，就把这个时间块上游的最后⼀个数据推给下游。表⾯上看sampleTime和auditTime⾮常像，auditTime也会把时间块中最后⼀个数据推给下游，但是对于auditTime时间块的开始是由上游产⽣数据触发的，⽽sampleTime的时间块开始则和上游数据完全⽆关，所以，可以看到sampleTime产⽣的数据序列分布⼗分均匀。</p><p>注意，如果sampleTime发现⼀个时间块内上游没有产⽣数据，那在时间块结尾也不会给下游传递数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//A A B B C C</span><br><span class="line">const source$ = Observable.interval(500).take(2).mapTo(&quot;A&quot;)</span><br><span class="line">        .concat(Observable.interval(1000).take(3).mapTo(&quot;B&quot;))</span><br><span class="line">        .concat(Observable.interval(500).take(3).mapTo(&quot;C&quot;));</span><br><span class="line">const result$ = source$.sampleTime(800).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="52-sample"><a href="#52-sample" class="headerlink" title="52.sample"></a>52.sample</h3><p>通常sample的参数被称为notifier，当notifier产⽣⼀个数据的时候，sample就从上游拿最后⼀个产⽣的数据传给下游。<br>我们希望点击Sample按钮的时候，id为text的div中会显⽰逝去的时间，这种⽅式可以有很多实现⽅式，利⽤sample的实现⽅式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const notifer$ = Rx.Observable.fromEvent(document.querySelector(&quot;#sample&quot;), &quot;click&quot;);</span><br><span class="line">const tick$ = Rx.Observable.timer(0, 10).map((x) =&gt; x * 10);</span><br><span class="line">const sample$ = tick$.sample(notifer$);</span><br><span class="line">sample$.subscribe((value) =&gt; &#123;</span><br><span class="line">        document.querySelector(&quot;#text&quot;).innerText = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="53-distinct"><a href="#53-distinct" class="headerlink" title="53.distinct"></a>53.distinct</h3><p>去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source$ = Observable.of(0, 1, 1, 2, 0, 0, 1, 3, 3);</span><br><span class="line">const distinct$ = source$.distinct().subscribe(console.log);</span><br></pre></td></tr></table></figure><p>distinct还提供第⼆个可选的参数flush，第⼆个参数可以是⼀个Observable对象，每当这个Observable对象产⽣数据时，<br>distinct就清空为了判断是否重复而生成的“唯⼀数据集合”，⼀切重来，这样就避免了内存泄露。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source$ = Observable.interval(100).map((x) =&gt; x % 1000);</span><br><span class="line">const distinct$ = source$.distinct(null, Observable.interval(500));</span><br></pre></td></tr></table></figure><hr><h3 id="54-distinctUntilChanged"><a href="#54-distinctUntilChanged" class="headerlink" title="54.distinctUntilChanged"></a>54.distinctUntilChanged</h3><p>拿到⼀个数据不是和全部⽐较，⽽是直接和上⼀个数据⽐较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//0 1 2 0 1 3</span><br><span class="line">const source$ = Observable.of(0, 1, 1, 2, 0, 0, 1, 3, 3);</span><br><span class="line">const distinct$ = source$.distinctUntilChanged();</span><br></pre></td></tr></table></figure><hr><h3 id="55-ignoreElements"><a href="#55-ignoreElements" class="headerlink" title="55.ignoreElements"></a>55.ignoreElements</h3><p>忽略所有的元素，这⾥的元素是指上游产⽣的数据，忽略所有上游数据，只关⼼complete和error事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source$ = Observable.interval(1000).take(5);</span><br><span class="line">const result$ = source$.ignoreElements();</span><br></pre></td></tr></table></figure><hr><h3 id="56-elementAt"><a href="#56-elementAt" class="headerlink" title="56.elementAt"></a>56.elementAt</h3><p>elementAt把上游数据当数组，只获取指定下标的那⼀个数据，它的第⼆个参数可以指定没有对应下标数据时的默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//null</span><br><span class="line">const source$ = Observable.of(3, 1, 2);</span><br><span class="line">const result$ = source$.elementAt(3, null);</span><br></pre></td></tr></table></figure><hr><h3 id="57-single"><a href="#57-single" class="headerlink" title="57.single"></a>57.single</h3><p>检查上游是否只有⼀个满⾜对应条件的数据，如果答案为“是”，就向下游传递这个数据；如果答案为“否”，就向下游传递⼀个异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//0</span><br><span class="line">const source$ = Observable.interval(1000).take(2);</span><br><span class="line">const result$ = source$.single((x) =&gt; x % 2 === 0).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h2 id="五、转化型操作符"><a href="#五、转化型操作符" class="headerlink" title="五、转化型操作符"></a>五、转化型操作符</h2><h3 id="58-map-mapTo"><a href="#58-map-mapTo" class="headerlink" title="58.map/mapTo"></a>58.map/mapTo</h3><p>一对一映射转化/转化为某个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//0 2 4 6...</span><br><span class="line">const source$ = Observable.interval(1000);</span><br><span class="line">const result$ = source$.map((x) =&gt; x * 2).subscribe(console.log);</span><br><span class="line">//a a a a...</span><br><span class="line">const result$ = source$.mapTo(&quot;a&quot;).subscribe(console.log);</span><br></pre></td></tr></table></figure><p>ps:实现一下map操作符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function map(fn: (val: any) =&gt; any) &#123;</span><br><span class="line">    return new Observable((observer) =&gt; &#123;</span><br><span class="line">        const sub = this.subscribe(&#123;</span><br><span class="line">            next: (val: any) =&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    observer.next(fn(val));</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    observer.error(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: (err: any) =&gt; &#123;</span><br><span class="line">                observer.error(err);</span><br><span class="line">            &#125;,</span><br><span class="line">            complete: () =&gt; &#123;</span><br><span class="line">                observer.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return &#123;</span><br><span class="line">            unsubscribe: () =&gt; &#123;</span><br><span class="line">                sub.unsubscribe();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="59-pluck"><a href="#59-pluck" class="headerlink" title="59.pluck"></a>59.pluck</h3><p>只挑选指定key的value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//RxJS React React RxJS</span><br><span class="line">const source$ = Observable.of(</span><br><span class="line">        &#123; name: &#123;n:&quot;RxJS&quot;,m:1&#125;, version: &quot;v4&quot; &#125;,</span><br><span class="line">        &#123; name: &#123;n:&quot;React&quot;,m:1&#125;, version: &quot;v15&quot; &#125;,</span><br><span class="line">        &#123; name: &#123;n:&quot;React&quot;,m:1&#125;, version: &quot;v16&quot; &#125;,</span><br><span class="line">        &#123; name: &#123;n:&quot;RxJS&quot;,m:1&#125;, version: &quot;v5&quot; &#125;</span><br><span class="line">);</span><br><span class="line">const result$ = source$.pluck(&quot;name&quot;,&quot;n&quot;);</span><br></pre></td></tr></table></figure><hr><h3 id="60-windowTime"><a href="#60-windowTime" class="headerlink" title="60.windowTime"></a>60.windowTime</h3><p>如，windowTime的参数是400，也就会把时间划分为连续的400毫秒长度区块，<br>在每个时间区块中，上游传下来的数据不会直接送给下游，<br>⽽是在该时间区块的开始就新创建⼀个Observable对象推送给下游，<br>然后在这个时间区块内上游产⽣的数据放到这个新创建的Observable对象中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source$ = Observable.timer(0, 100);</span><br><span class="line">const result$ = source$.windowTime(300).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="61-bufferTime"><a href="#61-bufferTime" class="headerlink" title="61.bufferTime"></a>61.bufferTime</h3><p>其中的数据是数组形式，bufferTime会把时间区块内的数据缓存，<br>在时间区块结束的时候把所有缓存的数据放在⼀个数组⾥传给下游。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source$ = Observable.timer(0, 100);</span><br><span class="line">const result$ = source$.bufferTime(300).subscribe(console.log);</span><br></pre></td></tr></table></figure><hr><h3 id="62-windowCount-bufferCount"><a href="#62-windowCount-bufferCount" class="headerlink" title="62.windowCount/bufferCount"></a>62.windowCount/bufferCount</h3><p>跟上面一样，不同的是参数是数据数量而不是时间</p><hr><h3 id="63-windowWhen-bufferWhen"><a href="#63-windowWhen-bufferWhen" class="headerlink" title="63.windowWhen/bufferWhen"></a>63.windowWhen/bufferWhen</h3><p>略</p><hr><h3 id="64-windowToggle-bufferToggle"><a href="#64-windowToggle-bufferToggle" class="headerlink" title="64.windowToggle/bufferToggle"></a>64.windowToggle/bufferToggle</h3><p>windowToggle和bufferToggle需要两个参数，第⼀个参数opening$是⼀个Observable对象，<br>每当opening$产⽣⼀个数据，代表⼀个缓冲窗⼜的开始，<br>同时，第⼆个参数closingSelector也会被调⽤，⽤来获得缓冲窗⼜结束的通知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const source$ = Observable.timer(0, 100);</span><br><span class="line">const openings$ = Observable.timer(0, 400);</span><br><span class="line">const closingSelector = (value) =&gt; &#123;</span><br><span class="line">        return value % 2 === 0 ? Observable.timer(200) : Observable.timer(100);</span><br><span class="line">&#125;;</span><br><span class="line">const result$ = source$.windowToggle(openings$, closingSelector);</span><br></pre></td></tr></table></figure><p>其中，opening$每400毫秒产⽣⼀个数据，所以每400毫秒就会有⼀个缓冲区间开始。<br>每当opening$产⽣⼀个数据时，closingSelector就会被调⽤返回控制对应缓冲区间结束的Observable对象，<br>如果参数为偶数，就会延时200毫秒产⽣⼀个数据，否则就延时100毫秒产⽣⼀个数据。</p><hr><h3 id="65-window-buffer"><a href="#65-window-buffer" class="headerlink" title="65.window/buffer"></a>65.window/buffer</h3><p>它只⽀持⼀个Observable类型的参数，称为notifier$，<br>每当notifer$产⽣⼀个数据，既是前⼀个缓存窗⼜的结束，也是后⼀个缓存窗⼜的开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const source$ = Observable.timer(0, 100);</span><br><span class="line">const notifer$ = Observable.timer(400, 400);</span><br><span class="line">const result$ = source$.window(notifer$);</span><br></pre></td></tr></table></figure><hr><h3 id="66-concatMap"><a href="#66-concatMap" class="headerlink" title="66.concatMap"></a>66.concatMap</h3><p>高阶observable的map的concat形态（外层observable处理完自己的内层后才到下一个外层）</p><p>拖拽例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const box = document.querySelector(&quot;#box&quot;);</span><br><span class="line">const mouseDown$ = Rx.Observable.fromEvent(box, &quot;mousedown&quot;);</span><br><span class="line">const mouseUp$ = Rx.Observable.fromEvent(box, &quot;mouseup&quot;);</span><br><span class="line">const mouseOut$ = Rx.Observable.fromEvent(box, &quot;mouseout&quot;);</span><br><span class="line">const mouseMove$ = Rx.Observable.fromEvent(box, &quot;mousemove&quot;);</span><br><span class="line">const drag$ = mouseDown$.concatMap((startEvent) =&gt; &#123;</span><br><span class="line">        const initLeft = box.offsetLeft;</span><br><span class="line">        const initTop = box.offsetTop;</span><br><span class="line">        const stop$ = mouseOut$.merge(mouseUp$);</span><br><span class="line">        return mouseMove$.takeUntil(stop$).map((e) =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">                x: e.x - startEvent.x + initLeft,</span><br><span class="line">                y: e.y - startEvent.y + initTop</span><br><span class="line">        &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">drag$.subscribe((e) =&gt; &#123;</span><br><span class="line">        box.style.left = e.x + &quot;px&quot;;</span><br><span class="line">        box.style.top = e.y + &quot;px&quot;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="67-mergeMap"><a href="#67-mergeMap" class="headerlink" title="67.mergeMap"></a>67.mergeMap</h3><p>高阶observable的map的merge形态<br>（mergeMap对于每个内部Observable对象直接合并，也就是任何内部Observable对象中的数据，来⼀个给下游传⼀个，不做任何等待。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const sendButton = document.querySelector(&quot;#send&quot;);</span><br><span class="line">Rx.Observable.fromEvent(sendButton, &quot;click&quot;)</span><br><span class="line">    .mergeMap(() =&gt; &#123;</span><br><span class="line">        return Rx.Observable.ajax(apiUrl);</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe((result) =&gt; &#123;</span><br><span class="line">        // 正常处理AJAX返回的结果</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="68-switchMap"><a href="#68-switchMap" class="headerlink" title="68.switchMap"></a>68.switchMap</h3><p>⽤户点击按钮，⼀个AJAX请求发出去，这时候RxJS的star数为9907，不过因为⽹络速度⽐较慢的原因，<br>这个AJAX请求的延时⽐较⼤，⽤户等不及了，又点了⼀次按钮，又⼀个AJAX请求发出去了。<br>这时候，第⼀个AJAX请求已经获得了数据9907，⽽恰在此时世界某个地⽅的开发者也很喜欢RxJS，点击了RxJS项⽬的star，<br>于是RxJS的star数变成了9908，然后，⽤户触发的第⼆个AJAX也到了，拿到了9908的数据。只要涉及输⼊输出，延时就是不可预期的，<br>先发出去的AJAX未必就会先返回，完全有可能第⼆个AJAX请求的结果⽐第⼀个更早返回，这时候使⽤mergeMap就会出问题了，<br>⽤户会先看到9908，然后又会被第⼀个AJAX请求的返回修改为9907，毫⽆疑问，9907并不是最新的数据。<br>switchMap这个特点适⽤于总是要获取最新AJAX请求返回的应⽤，<br>只需要把上⾯使⽤mergeMap来合并AJAX请求的代码中改为⽤switchMap就可以了。</p><hr><h3 id="69-exhaustMap"><a href="#69-exhaustMap" class="headerlink" title="69.exhaustMap"></a>69.exhaustMap</h3><p>exhaustMap对数据的处理策略和switchMap正好相反，先产⽣的内部Observable优先级总是更⾼，<br>后产⽣的内部Observable对象被利⽤的唯⼀机会，就是之前的内部Observable对象已经完结。</p><hr><h3 id="70-concatMapTo-mergeMapTo-switchMapTo"><a href="#70-concatMapTo-mergeMapTo-switchMapTo" class="headerlink" title="70.concatMapTo/mergeMapTo/switchMapTo"></a>70.concatMapTo/mergeMapTo/switchMapTo</h3><p>作用跟楼上一样，<br>参数直接就是⼀个Observable对象，⽽不是⼀个返回Observable对象的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const source$ = Observable.interval(200);</span><br><span class="line">const result$ = source$.concatMapTo(Observable.interval(100).take(5));</span><br></pre></td></tr></table></figure><hr><h3 id="71-groupBy"><a href="#71-groupBy" class="headerlink" title="71.groupBy"></a>71.groupBy</h3><p>可以把groupBy看作⼀个分发器，对于上游推送下来的任何数据，检查这个数据的key值，<br>如果这个key值是第⼀次出现，就产⽣⼀个新的内部Observable对象，同时这个数据就是内部Observable对象的第⼀个数据；<br>如果key值已经出现过，就直接把这个数据塞给对应的内部Observable对象。</p><p>例子：事件委托，分class来处理元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const click$ = Rx.Observable.fromEvent(document, &quot;click&quot;);</span><br><span class="line">const groupByClass$ = click$.groupBy((event) =&gt; event.target.className);</span><br><span class="line">groupByClass$.filter((value) =&gt; value.key === &quot;foo&quot;).mergeAll().subscribe(fooEventHandler);</span><br><span class="line">groupByClass$.filter((value) =&gt; value.key === &quot;bar&quot;).mergeAll().subscribe(barEventHandler);</span><br></pre></td></tr></table></figure><hr><h3 id="72-partition"><a href="#72-partition" class="headerlink" title="72.partition"></a>72.partition</h3><p>partition接受⼀个判定函数作为参数，对上游的每个数据进⾏判定，<br>满⾜条件的放⼀个Observable对象，不满⾜条件的放到另⼀个Observable对象，就这样⼀分⼆。<br>partition是RxJS提供的操作符中唯⼀的不返回Observable对象的操作符，它返回的是⼀个数组，<br>包含两个元素，第⼀个元素是容纳满⾜判定条件的Observable对象，第⼆个元素⾃然是不满⾜判定条件的Observable对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const source$ = Observable.timer(0, 100);</span><br><span class="line">const [even$, odd$] = source$.partition((x) =&gt; x % 2 === 0);</span><br><span class="line">even$.subscribe((value) =&gt; console.log(&quot;even:&quot;, value));</span><br><span class="line">odd$.subscribe((value) =&gt; console.log(&quot;odd:&quot;, value));</span><br></pre></td></tr></table></figure><hr><h3 id="73-scan"><a href="#73-scan" class="headerlink" title="73.scan"></a>73.scan</h3><p>累加操作符</p><p>scan和reduce的区别在于scan对上游每⼀个数据都会产⽣⼀个规约结果，⽽reduce是对上游所有数据进⾏规约，<br>reduce最多只给下游传递⼀个数据，如果上游数据永不完结，那reduce也永远不会产⽣数据，<br>⽽scan完全可以处理⼀个永不完结的上游Observable对象。<br>scan可能是RxJS中对构建交互式应⽤程序最重要的⼀个操作符，因为它能够维持应⽤的当前状态，<br>⼀⽅⾯可以根据数据流持续更新这些状态，另⼀⽅⾯可以持续把更新的状态传给另⼀个数据流⽤来做必要处理。<br>在使⽤RxJS的应⽤中，如果需要维持应⽤的状态，scan是⾸选。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//0 1 3 6 .。。</span><br><span class="line">const source$ = Observable.interval(100);</span><br><span class="line">const result$ = source$.scan((accumulation, value) =&gt; &#123;</span><br><span class="line">        return accumulation + value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="六、错误处理操作符"><a href="#六、错误处理操作符" class="headerlink" title="六、错误处理操作符"></a>六、错误处理操作符</h2><h3 id="74-catch"><a href="#74-catch" class="headerlink" title="74.catch"></a>74.catch</h3><p>它接受一个函数参数，这个函数有两个参数，第⼀个参数是error，也就是被捕获的错误，第⼆个参数caught$，代表上游紧邻的那个Observable对象。<br>原本出现4的位置，被catch$⽤8来替换，但是因为发⽣了错误，正常的序列被打断，原本source$应该吐出的5不会有机会⾛到catch$的下游。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1 2 3 8</span><br><span class="line">const source$ = Observable.range(1, 5);</span><br><span class="line">const error$ = source$.map((value) =&gt; &#123;</span><br><span class="line">        if (value === 4) &#123;</span><br><span class="line">        throw new Error(&quot;unlucky number 4&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">&#125;);</span><br><span class="line">const catch$ = error$.catch((err, caught$) =&gt; Observable.of(8));</span><br></pre></td></tr></table></figure><hr><h3 id="75-retry"><a href="#75-retry" class="headerlink" title="75.retry"></a>75.retry</h3><p>作⽤就是让上游的Observable重新⾛⼀遍，达到重试的⽬的。这个操作符接受⼀个数值参数number，<br>number⽤于指定重试的次数，如果number为负数或者没有number参数，那么就是⽆限次retry，直到上游不再抛出错误异常为⽌。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1 2 3 1 2 3 1 2 3 8</span><br><span class="line">const source$ = Observable.range(1, 5);</span><br><span class="line">const error$ = source$.map((value) =&gt; &#123;</span><br><span class="line">        if (value === 4) &#123;</span><br><span class="line">        throw new Error(&quot;unlucky number 4&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">&#125;);</span><br><span class="line">const retry$ = error$.retry(2);</span><br><span class="line">const catch$ = retry$.catch((err) =&gt; Observable.of(8));</span><br></pre></td></tr></table></figure><hr><h3 id="76-retryWhen"><a href="#76-retryWhen" class="headerlink" title="76.retryWhen"></a>76.retryWhen</h3><p>接受⼀个函数作为参数，这个参数称为notifer，⽤于控制“重试”的节奏和次数，这⽐retry单纯只能控制重试次数要前进⼀步。<br>notifer有⼀个参数名为error$，注意这个参数名后⾯有⼀个$，表⽰它实际上代表的不是⼀个错误，<br>⽽是由⼀组错误组成的Observable对象；notifer返回⼀个Observable对象，当上游扔下来错误的时候，<br>retryWhen就会调⽤notifer，然后根据notifer返回的Observable对象来决定何时重试，<br>这个返回的Observable就是⼀个“节奏控制器”，“节奏控制器”每吐出⼀个数据，就会进⾏⼀次重试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const source$ = Observable.range(1, 5);</span><br><span class="line">const error$ = source$.map((value) =&gt; &#123;</span><br><span class="line">        if (value === 4) &#123;</span><br><span class="line">        throw new Error(&quot;unlucky number 4&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">&#125;);</span><br><span class="line">const retryWhen$ = error$.retryWhen((err$) =&gt; Observable.interval(1000));</span><br></pre></td></tr></table></figure><p>用retryWhen模拟实现retry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.retryCount = function(maxCount) &#123;</span><br><span class="line">        return this.retryWhen((err$) =&gt; &#123;</span><br><span class="line">        return err$.scan((errorCount, err) =&gt; &#123;</span><br><span class="line">                if (errorCount &gt;= maxCount) &#123;</span><br><span class="line">                throw err;</span><br><span class="line">                &#125;</span><br><span class="line">                return errorCount + 1;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="77-finally"><a href="#77-finally" class="headerlink" title="77.finally"></a>77.finally</h3><p>finally和do操作符很像，它们传⼊的函数⽆法影响数据流，所以要做点事只能通过其他副作⽤，<br>⽐如释放数据流之外的资源，输出⼀个⽇志信息之类。finally和do也有很⼤的不同，<br>finally的参数只在上游数据完结或者出错的时候才执⾏，⼀个数据流中finally只会发挥⼀次作⽤；⽽do是对上游吐出的每个数据均执⾏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const source$ = Observable.range(1, 10);</span><br><span class="line">const error$ = source$.map(throwOnUnluckyNumber);</span><br><span class="line">const final$ = error$</span><br><span class="line">        .retry(3)</span><br><span class="line">        .catch((err) =&gt; Observable.of(8))</span><br><span class="line">        .finally((x) =&gt; console.log(&quot;finally&quot;));</span><br></pre></td></tr></table></figure><hr><h2 id="七、多播subject"><a href="#七、多播subject" class="headerlink" title="七、多播subject"></a>七、多播subject</h2><h3 id="78-Hot和Cold"><a href="#78-Hot和Cold" class="headerlink" title="78.Hot和Cold"></a>78.Hot和Cold</h3><p>Observable都具有“懒”的特质，不过Cold更“懒”⼀些，两者的数据管道内逻辑都是只有存在订阅者存在才执⾏，<br>Cold Observable更“懒”体现在，如果没有订阅者，连数据都不会真正产⽣，对于HotObservable，没有订阅者的情况下，数据依然会产⽣，只不过不传⼊数据管道。所以，Cold Observable实现的是单播，Hot Observable实现的多播。</p><p>在RxJS的创建类操作符中，下⾯⼏个产⽣的是Hot Observable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fromPromise</span><br><span class="line">fromEvent</span><br><span class="line">fromEventPattern</span><br></pre></td></tr></table></figure><p>不难看出，这些产⽣Hot Observable对象的操作符数据源都在外部，或者是来⾃于Promise，<br>或者是来⾃于DOM，或者是来⾃于Event Emitter，真正的数据源和有没有Observer没有任何关系。</p><hr><h3 id="79-用subject实现多播"><a href="#79-用subject实现多播" class="headerlink" title="79.用subject实现多播"></a>79.用subject实现多播</h3><p>既然Subject既有Observable又有Observer的特性，那么，想象⼀下，<br>让⼀个Subject对象成为⼀个Cold Observable对象的下游，其他想要Hot数据源的Observer就不要去订阅那个ColdObservable对象了，<br>⽽是去订阅这个Subject对象。我们知道，Hot Observable可以认为是“⽣产者”独⽴于订阅⾏为之外的Observable，<br>现在，以Subject为中⼼，Subject就是这个Hot Observable，它所订阅的Cold Observable对象就是那个“⽣产者”。<br>Subject同时也是⼀个Observer，作为Observer会接受和消化“⽣产者”推过来的数据，最简单的消化⽅法，<br>就是把数据、错误和完结通知都⼀股脑原样推给Subject⾃⼰的Observer。</p><p>ps:实现makeHot()函数，让上游cold observable变为hot observable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.makeHot = function()&#123;</span><br><span class="line">    const cold$ = this;</span><br><span class="line">    const subject = new Subject();</span><br><span class="line">    cold$.subscribe(subject);</span><br><span class="line">    return Observable.create((observer) =&gt; subject.subscribe(observer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="80-当subject上游有多个observable时需要注意的"><a href="#80-当subject上游有多个observable时需要注意的" class="headerlink" title="80.当subject上游有多个observable时需要注意的"></a>80.当subject上游有多个observable时需要注意的</h3><p>虽然Subject理论上可以合并多个数据流，但是，因为任何⼀个上游数据流的完结或者出错信息都可以终结Subject对象的⽣命，<br>让Subject来做合并数据流的⼯作显得并不合适。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">observer 1: a</span><br><span class="line">observer 2: a</span><br><span class="line">observer 1: b</span><br><span class="line">observer 2: b</span><br><span class="line">observer 1: a</span><br><span class="line">observer 2: a</span><br><span class="line">*/</span><br><span class="line">const tick1$ = Observable.interval(1000).mapTo(&quot;a&quot;).take(2);</span><br><span class="line">const tick2$ = Observable.interval(1000).mapTo(&quot;b&quot;).take(2);</span><br><span class="line">const subject = new Subject();</span><br><span class="line">tick1$.subscribe(subject);</span><br><span class="line">tick2$.subscribe(subject);</span><br><span class="line">subject.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class="line">subject.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br></pre></td></tr></table></figure><p>因为tick1$是由take产⽣的，也就是说在吐出2个数据之后就会调⽤下游的complete函数，也就是调⽤subject的complete函数。<br>⼀个Subject对象是不能被重复使⽤的，只要complete函数被调⽤，它的⽣命周期也就结束了，再来调⽤它的next函数是不会有任何反应的。<br>tick2$传给下游的第⼆个b，发⽣在tick$完结之后，所以第⼆个数据b传给subject时它已经“死”了，⾃然不会得到任何输出。</p><hr><h3 id="81-subject错误处理"><a href="#81-subject错误处理" class="headerlink" title="81.subject错误处理"></a>81.subject错误处理</h3><p>有意思的是Subject有多个Observer的场景，如果Subject的某个下游数据流产⽣了⼀个错误异常，<br>⽽且这个错误异常没有被Observer处理，那这个Subject其他的Observer都会失败。直观上，<br>我们会觉得Subject对象的各个Observer是相互独⽴的，⼀个Observer没有处理错误异常，不应该影响其他的Observer，<br>但是，实际上并不是如此。</p><p>如果某个observer.next函数调⽤抛出错误异常怎么办呢？结果当然是其他的Observer也会受到牵连，⽆法接收到数据。</p><hr><h3 id="82-multicast"><a href="#82-multicast" class="headerlink" title="82.multicast"></a>82.multicast</h3><p>多播操作符，把cold变成hot，但需要自己手动调用connect才开始多播</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">observer 1: 0</span><br><span class="line">observer 1: 1</span><br><span class="line">observer 2: 1</span><br><span class="line">observer 1: 2</span><br><span class="line">observer 2: 2</span><br><span class="line">*/</span><br><span class="line">const coldSource$ = Observable.interval(1000).take(3);</span><br><span class="line">const tick$ = coldSource$.multicast(new Subject());</span><br><span class="line">tick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        tick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class="line">&#125;, 1500);</span><br><span class="line">tick$.connect();</span><br></pre></td></tr></table></figure><hr><h3 id="83-refCount"><a href="#83-refCount" class="headerlink" title="83.refCount"></a>83.refCount</h3><p>自动计数，对Observer的个数进⾏跟踪，当Observer数量⼤于1时订阅上游，<br>当Observer数量减少为0时退订上游，⽽这正是refCount函数的作⽤。也不用手动调用connect。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const coldSource$ = Observable.interval(1000).take(3);</span><br><span class="line">const tick$ = coldSource$.multicast(new Subject()).refCount();</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        tick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class="line">&#125;, 500);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        tick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure><p>不过，如果使⽤refCount，那么对应的multicast往往不能只是接受⼀个Subject对象作为参数，⽽是接受⼀个返回Subject对象的函数作为参数。</p><p>让hot又变成cold，多播管道之间互不影响（因为之前比如说observer1退订了，subject也会退订，这使得observer2也接收不到数据）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">observer 1: 0</span><br><span class="line">observer 1: 1</span><br><span class="line">observer 2: 1</span><br><span class="line">observer 1: 2</span><br><span class="line">observer 2: 2</span><br><span class="line">observer 3: 0</span><br><span class="line">observer 3: 1</span><br><span class="line">observer 3: 2</span><br><span class="line">*/</span><br><span class="line">const subjectFactory = () =&gt; new Subject();</span><br><span class="line">const coldSource$ = Observable.interval(1000).take(3);</span><br><span class="line">const tick$ = coldSource$.multicast(subjectFactory).refCount();</span><br><span class="line">tick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        tick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class="line">&#125;, 1500);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        tick$.subscribe((value) =&gt; console.log(&quot;observer 3: &quot; + value));</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure><hr><h3 id="84-publish"><a href="#84-publish" class="headerlink" title="84.publish"></a>84.publish</h3><p>封装版multicast</p><p>实现方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function publish(selector) &#123;</span><br><span class="line">    if (selector) &#123;</span><br><span class="line">        return this.multicast(() =&gt; new Subject(), selector);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return this.multicast(new Subject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到publish的实现极其简单，也有⼀个可选的selector参数，根据是否有selector⽅法，<br>决定调⽤multicast的时候是使⽤⼀个Subject对象，还是使⽤⼀个产⽣Subject对象的⼯⼚⽅法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">observer 1: 0</span><br><span class="line">observer 1: 1</span><br><span class="line">observer 1: 2</span><br><span class="line">*/</span><br><span class="line">const tick$ = Observable.interval(1000).take(3);</span><br><span class="line">const sharedTick$ = tick$.publish().refCount();</span><br><span class="line">sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure><hr><h3 id="85-share"><a href="#85-share" class="headerlink" title="85.share"></a>85.share</h3><p>封装版multicast</p><p>实现方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.share = function share() &#123;</span><br><span class="line">        This.multicast(() =&gt; new Subject()).refCount();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>考虑到Observer增加然后减少为0之后，新的Observer添加也希望获得数据的场景，<br>传递给multicast的不是Subject对象，⽽是产⽣Subject对象的⼯⼚函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">observer 1: 0</span><br><span class="line">observer 1: 1</span><br><span class="line">observer 1: 2</span><br><span class="line">observer 2: 0</span><br><span class="line">observer 2: 1</span><br><span class="line">observer 2: 2</span><br><span class="line">*/</span><br><span class="line">const tick$ = Observable.interval(1000).take(3);</span><br><span class="line">const sharedTick$ = tick$.share();</span><br><span class="line">sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure><hr><h3 id="86-publishLast和AsyncSubject"><a href="#86-publishLast和AsyncSubject" class="headerlink" title="86.publishLast和AsyncSubject"></a>86.publishLast和AsyncSubject</h3><p>多播的是上游的最后⼀个数据。</p><p>AsyncSubject对象表现得“可以重⽤”，即使上游Cold Observable完结时候调⽤了AsyncSubject对象的complete⽅法，<br>之后添加的Observer依然可以从AsyncSubject中获得数据，⽽且是⽴刻获得数据，当然，这⽴刻获得数据就是上游吐出的最后⼀个数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">observer 1: 2</span><br><span class="line">observer 2: 2</span><br><span class="line">*/</span><br><span class="line">const tick$ = Observable.interval(1000).take(3);</span><br><span class="line">const sharedTick$ = tick$.publishLast().refCount();</span><br><span class="line">sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure><hr><h3 id="87-pubishReplay和ReplaySubject"><a href="#87-pubishReplay和ReplaySubject" class="headerlink" title="87.pubishReplay和ReplaySubject"></a>87.pubishReplay和ReplaySubject</h3><p>replay就是把Observable对象吐出的数据重新⾛⼀遍，⽽不是让数据管道重新产⽣⼀遍数据，<br>参数接受一个n，n是relay后几个数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">source 0</span><br><span class="line">observer 1: 0</span><br><span class="line">source 1</span><br><span class="line">observer 1: 1</span><br><span class="line">source 2</span><br><span class="line">observer 1: 2</span><br><span class="line">observer 2: 1</span><br><span class="line">observer 2: 2</span><br><span class="line">*/</span><br><span class="line">const tick$ = Observable.interval(1000)</span><br><span class="line">        .take(3)</span><br><span class="line">        .do((x) =&gt; console.log(&quot;source &quot;, x));</span><br><span class="line">const sharedTick$ = tick$.publishReplay(2).refCount();</span><br><span class="line">sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure><hr><h3 id="88-publishBehavior和BehaviorSubject"><a href="#88-publishBehavior和BehaviorSubject" class="headerlink" title="88.publishBehavior和BehaviorSubject"></a>88.publishBehavior和BehaviorSubject</h3><p>可以提供⼀个“默认数据”，当添加Observer的时候，即使上游还没有吐出数据Observer也会⽴即获得这个“默认数据”；<br>⽽且，这个“默认数据”总是会被上游吐出的最新数据替代，也就是说，任何新添加的Observer都有⼀个⼤礼包在等着他，<br>这个⼤礼包要么是指定的“默认数据”，要么就是上游吐出的最新数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">observer 1: -1</span><br><span class="line">observer 1: 0</span><br><span class="line">observer 1: 1</span><br><span class="line">observer 2: 1</span><br><span class="line">observer 1: 2</span><br><span class="line">observer 2: 2</span><br><span class="line">*/</span><br><span class="line">const tick$ = Observable.interval(1000).take(3);</span><br><span class="line">const sharedTick$ = tick$.publishBehavior(-1).refCount();</span><br><span class="line">sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class="line">&#125;, 2500);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 3: &quot; + value));</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure><hr><h2 id="八、scheduler，掌握时间调度"><a href="#八、scheduler，掌握时间调度" class="headerlink" title="八、scheduler，掌握时间调度"></a>八、scheduler，掌握时间调度</h2><h3 id="89-在RxJS中，提供了下列Scheduler实例"><a href="#89-在RxJS中，提供了下列Scheduler实例" class="headerlink" title="89.在RxJS中，提供了下列Scheduler实例"></a>89.在RxJS中，提供了下列Scheduler实例</h3><p>·undefined/null，也就是不指定Scheduler，代表同步执⾏的Scheduler。</p><p>·asap，尽快执⾏的Scheduler。</p><p>·async，利⽤setInterval实现的Scheduler，⽤于基于时间吐出数据的场景。</p><p>·queue，利⽤队列实现的Scheduler，⽤于迭代⼀个⼤的集合的场景。</p><p>·animationFrame，⽤于动画场景的Scheduler。</p><p>RxJS默认选择Scheduler的原则是尽量减少并发运⾏。所以，对于range，就选择undefined；对于很⼤的数据，就选择queue；对于时间相关的操作符⽐如interval，就选择async。<br>asap和async两个Scheduler都是利⽤事件循环来实现异步的效果，两者的不同，就是asap会尽量使⽤Micro Task，⽽async利⽤的是Macro Task。<br>queue这个Scheduler，如果调⽤它的schedule函数式参数delay是0，<br>那它就⽤同步的⽅式执⾏，如果delay参数⼤于0，那queue的表现其实就和async⼀模⼀样。</p><hr><h3 id="90-observeOn-subscribeOn（略）"><a href="#90-observeOn-subscribeOn（略）" class="headerlink" title="90.observeOn/subscribeOn（略）"></a>90.observeOn/subscribeOn（略）</h3><p>调用scheduler的api</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">before subscribe</span><br><span class="line">after subscribe</span><br><span class="line">data：1</span><br><span class="line">data：2</span><br><span class="line">data：3</span><br><span class="line">*/</span><br><span class="line">const source$ = Observable.range(1, 3);</span><br><span class="line">const asapSource$ = source$.observeOn(asap);</span><br><span class="line">console.log(&quot;before subscribe&quot;);</span><br><span class="line">asapSource$.subscribe(</span><br><span class="line">        (value) =&gt; console.log(&quot;data: &quot;, value),</span><br><span class="line">        (error) =&gt; console.log(&quot;error: &quot;, error),</span><br><span class="line">        () =&gt; console.log(&quot;complete&quot;)</span><br><span class="line">);</span><br><span class="line">console.log(&quot;after subscribe&quot;);</span><br></pre></td></tr></table></figure><p>⼀般来说，observeOn在数据流管道接近末尾的位置使⽤，最好就是在调⽤subscribe之前，<br>因为通常RxJS默认的Scheduler已经⾜够合理，如果我们要修改Scheduler，在整个数据管道中只需要修改⼀处就⾜够，<br>既然数据管道中的数据是被Observer使⽤，当然应该在添加Observer的subscribe调⽤之前使⽤observeOn调整Scheduler最合适。</p><hr><h2 id="九、调试"><a href="#九、调试" class="headerlink" title="九、调试"></a>九、调试</h2><h3 id="91-提示"><a href="#91-提示" class="headerlink" title="91.提示"></a>91.提示</h3><p>不要⽤subscribe⽅法来增加输出log的调试代码，如果要增加调试代码，就⼀定要在数据管道中利⽤do这个操作符来增加。<br>这样，就可以在数据管道中不⽤do⽽是⽤debug来增加调试代码，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.prototype.debug = function(fn) &#123;</span><br><span class="line">        if (global.debug) &#123;</span><br><span class="line">        return this.do(fn);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        return this;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const source$ = original$.debug((x) =&gt; console.log(&quot;source$ data = &quot;, x));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深入浅出Rxjs&quot;&gt;&lt;a href=&quot;#深入浅出Rxjs&quot; class=&quot;headerlink&quot; title=&quot;深入浅出Rxjs&quot;&gt;&lt;/a&gt;深入浅出Rxjs&lt;/h2&gt;&lt;p&gt;RxJS，简单来说，它将一切数据，包括HTTP请求，DOM事件或者普通数据等包装成流的形式，
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Rxjs" scheme="http://yoursite.com/tags/Rxjs/"/>
    
  </entry>
  
  <entry>
    <title>一探Webpack模块化机制</title>
    <link href="http://yoursite.com/2018/07/12/%E4%B8%80%E6%8E%A2Webpack%E6%A8%A1%E5%9D%97%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/07/12/一探Webpack模块化机制/</id>
    <published>2018-07-11T16:00:00.000Z</published>
    <updated>2018-09-11T06:19:48.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack模块化"><a href="#Webpack模块化" class="headerlink" title="Webpack模块化"></a>Webpack模块化</h2><p>对于webpack的模块化的实现，我们可以大致分为三种类型：<strong>commonjs</strong>，<strong>es6 Module</strong>，<strong>code splitting</strong>。</p><hr><h3 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h3><p>当我们在代码中使用到commonjs的模块化时，webpack就会用hack的手段帮我们处理好这些模块的关系，例如，我们写出这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">//假设index.js是webpack的打包入口文件</span><br><span class="line">var a = require(&apos;./a&apos;);</span><br><span class="line">console.log(a.name);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    name:&apos;cmh&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后经过webpack的打包转化，大概会生成这样的代码（简化版）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//一个IIFE</span><br><span class="line">//参数modules是存放着各模块的一个json</span><br><span class="line">(function (modules) &#123;</span><br><span class="line">    //存放模块缓存的对象</span><br><span class="line">    var installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //webpack实现的require，参数是传入一个你要require的模块的id</span><br><span class="line">    function __webpack_require__(moduleId) &#123;</span><br><span class="line"></span><br><span class="line">        //如果这个模块已经缓存过，那就直接返回它的exports</span><br><span class="line">        if(installedModules[moduleId]) &#123;</span><br><span class="line">            return installedModules[moduleId].exports;</span><br><span class="line">        &#125;</span><br><span class="line">        //没有的话就进行缓存模块</span><br><span class="line">        var module = installedModules[moduleId] = &#123;</span><br><span class="line">            i: moduleId,    //模块id</span><br><span class="line">            l: false,       //模块是否被加载了</span><br><span class="line">            exports: &#123;&#125;     //重写exports，即导出的内容</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //执行这个要被require的函数</span><br><span class="line">        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">        //标志模块被加载了</span><br><span class="line">        module.l = true;</span><br><span class="line"></span><br><span class="line">        //返回导出</span><br><span class="line">        return module.exports;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //最后再返回导入入口文件</span><br><span class="line">    return __webpack_require__(__webpack_require__.s = &quot;./index.js&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">(&#123;</span><br><span class="line">&quot;./a.js&quot;:(function(module,exports)&#123;</span><br><span class="line">    eval(&quot;module.exports = &#123;name:&apos;cmh&apos;&#125;&quot;);</span><br><span class="line">&#125;),</span><br><span class="line">&quot;./index.js&quot;:(function(module,exports,__webpack_require__)&#123;</span><br><span class="line">    eval(</span><br><span class="line">        &quot;var a = __webpack_require__(/*! ./a */ \&quot;./a.js\&quot;);</span><br><span class="line">        console.log(a.name);&quot;</span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>定义了installedModules ，这个变量被用来缓存已加载的模块。</li><li>定义了<strong>webpack_require</strong>这个函数，函数参数为模块的id。这个函数用来实现模块的require。</li><li>webpack_require函数首先会检查是否缓存了已加载的模块，如果有则直接返回缓存模块的exports。</li><li><p>如果没有缓存，也就是第一次加载，则首先初始化模块，并将模块进行缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    i: moduleId,</span><br><span class="line">    l: false,</span><br><span class="line">    exports: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后调用模块函数，也就是前面webpack对我们的模块的包装函数，将module、module.exports和<strong>webpack_require</strong>作为参数传入。注意这里做了一个动态绑定，将模块函数的调用对象绑定为module.exports，这是为了保证在模块中的this指向当前模块。</p></li><li>调用完成后，模块标记为已加载。</li><li>返回模块exports的内容。</li><li>利用前面定义的<strong>webpack_require</strong>函数，require入口模块，在这里是index.js。</li></ol><p>可以看到，这是一个立即执行函数，它会把各个模块函数当作参数传入到这个函数当中，然后经过对require，module.exports这些的处理（详情看上面代码的注释），就完成了对模块的require，然后这个模块又会根据自己对其他模块的require，依次加载其他模块，最终形成一个依赖网状结构。webpack管理着这些模块的缓存，如果一个模块被require多次，那么只会有一次加载过程，而返回的是缓存的内容，这也是commonjs的规范。</p><hr><h3 id="es6-Module"><a href="#es6-Module" class="headerlink" title="es6 Module"></a>es6 Module</h3><p>然后再来看看当我们在代码中使用到es6的模块化时，webpack会怎么处理？<br>例如，我们写出这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">//入口文件</span><br><span class="line">import bar from &apos;./a&apos;;</span><br><span class="line">import &#123;foo&#125; from &apos;./a&apos;;</span><br><span class="line">bar();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">export function foo()&#123;</span><br><span class="line">    return &apos;foo&apos;;</span><br><span class="line">&#125;</span><br><span class="line">export default function bar()&#123;</span><br><span class="line">    return &apos;bar&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后说说它跟commonjs转换的不同之处（相同的就不赘述了）<br>主要的不同之处在于传入的模块的解析部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//这里先放几个在说明过程中需要用到的函数：</span><br><span class="line"></span><br><span class="line">//1.r函数</span><br><span class="line">//通过Object.defineProperty在__webpack_exports__上添加属性__esModule</span><br><span class="line">//值为true，表明这是一个es模块。（在commonjs和es6Module混用时会用到，在这里暂时没用）</span><br><span class="line">__webpack_require__.r = function(exports) &#123;</span><br><span class="line">    Object.defineProperty(exports, &apos;__esModule&apos;, &#123; value: true &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.d函数</span><br><span class="line">//export default和export都被转换成了类似于commonjs的exports.xxx，</span><br><span class="line">//export对象变为__webpack_exports__的属性。</span><br><span class="line">__webpack_require__.d = function(exports, name, getter) &#123;</span><br><span class="line">    if(!__webpack_require__.o(exports, name)) &#123;</span><br><span class="line">        Object.defineProperty(exports, name, &#123;</span><br><span class="line">            configurable: false,</span><br><span class="line">            enumerable: true,</span><br><span class="line">            get: getter</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//模块部分</span><br><span class="line">//在这里用到的r,d函数在上面有说明</span><br><span class="line">&quot;./a.js&quot;:(function(module, __webpack_exports__, __webpack_require__) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    eval(&quot;</span><br><span class="line">        __webpack_require__.r(__webpack_exports__);</span><br><span class="line">        __webpack_require__.d(__webpack_exports__, \&quot;foo\&quot;, function() &#123; return foo; &#125;);</span><br><span class="line">        __webpack_require__.d(__webpack_exports__, \&quot;default\&quot;, function() &#123; return bar; &#125;);</span><br><span class="line">        function foo()&#123;return &apos;foo&apos;;&#125;</span><br><span class="line">        function bar()&#123;return &apos;bar&apos;;&#125;</span><br><span class="line">    &quot;)</span><br><span class="line">&#125;),</span><br><span class="line">&quot;./index.js&quot;:(function(module, __webpack_exports__, __webpack_require__) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    eval(&quot;</span><br><span class="line">        __webpack_require__.r(__webpack_exports__);</span><br><span class="line">        var _a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./a */ \&quot;./a.js\&quot;);</span><br><span class="line">        Object(_a__WEBPACK_IMPORTED_MODULE_0__[\&quot;default\&quot;])();</span><br><span class="line">        Object(_a__WEBPACK_IMPORTED_MODULE_0__[\&quot;foo\&quot;])()</span><br><span class="line">    &quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>前面讲commonjs的时候已经分析过了，webpack生成的代码是一个IIFE，这个IIFE完成一系列初始化工作后，就会通过<code>__webpack_require__(__webpack_require__.s = &quot;./index.js&quot;)</code>启动入口模块。这个跟前面一样。</li><li>然后就是通过<strong>webpack_require</strong>(‘./a.js’)导入a.js模块，再然后通过module.xxx获取a.js中export的对应属性。注意这里有一个重要的点，就是所有引入的模块属性都会用Object()包装成对象，这是为了保证像Boolean、String、Number这些基本数据类型转换成相应的类型对象。</li><li>为什么可以通过module.xxx拿到a.js中export的值呢？就是因为webpack通过d函数把a.js的export对象变为a模块的exports属性，这样就能拿到了。</li></ol><hr><h3 id="通过import-进行code-splitting"><a href="#通过import-进行code-splitting" class="headerlink" title="通过import()进行code splitting"></a>通过import()进行code splitting</h3><p>webpack提供了import()的方法可以让我们对代码进行分割。<br>比如，我们可以利用这点来实现Vue组件的懒加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; import(&apos;./Foo.vue&apos;)</span><br></pre></td></tr></table></figure></p><p>ps:注意：如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。</p><p>那么，它的实现原理是怎样的呢？<br>首先，我们先新建两个文件：入口文件index.js和模块文件a.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">import(&apos;./a&apos;).then((foo)=&gt;&#123;</span><br><span class="line">    console.log(foo())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//a.js</span><br><span class="line">exports.foo = function()&#123;</span><br><span class="line">    return &apos;a&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后打包，我们发现这次的打包跟之前的不一样的是它生成了两个文件：<br>主文件index.js和模块文件0.js</p><h4 id="主文件index-js："><a href="#主文件index-js：" class="headerlink" title="主文件index.js："></a>主文件index.js：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这次没了a，是因为它被分离到另一个文件中去了</span><br><span class="line">&quot;./index.js&quot;:(function(module, exports, __webpack_require__) &#123;</span><br><span class="line">    eval(&quot;</span><br><span class="line">        __webpack_require__.e(/*! import() */ 0)</span><br><span class="line">        .then(function() &#123; </span><br><span class="line">            var module = __webpack_require__(/*! ./a */ \&quot;./a.js\&quot;); </span><br><span class="line">            return typeof module === \&quot;object\&quot; &amp;&amp; module &amp;&amp; module.__esModule ? module : Object.assign(&#123;/* fake namespace object */&#125;, typeof module === \&quot;object\&quot; &amp;&amp; module, &#123; \&quot;default\&quot;: module &#125;); &#125;)</span><br><span class="line">        .then((foo)=&gt;&#123;console.log(foo())&#125;)</span><br><span class="line">    &quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从上面我们可以看出，这个e函数起到了关键作用，并且它还返回promise实现了异步加载。</p><p>接下来我们来看看，e函数是何方神圣：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.e = function requireEnsure(chunkId) &#123;</span><br><span class="line">    var promises = [];</span><br><span class="line">    </span><br><span class="line">    var installedChunkData = installedChunks[chunkId];</span><br><span class="line">    if(installedChunkData !== 0) &#123;</span><br><span class="line"></span><br><span class="line">        if(installedChunkData) &#123;</span><br><span class="line">            promises.push(installedChunkData[2]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">                installedChunkData = installedChunks[chunkId] = [resolve, reject];</span><br><span class="line">            &#125;);</span><br><span class="line">            promises.push(installedChunkData[2] = promise);</span><br><span class="line"></span><br><span class="line">            var head = document.getElementsByTagName(&apos;head&apos;)[0];</span><br><span class="line">            var script = document.createElement(&apos;script&apos;);</span><br><span class="line"></span><br><span class="line">            script.charset = &apos;utf-8&apos;;</span><br><span class="line">            script.timeout = 120;</span><br><span class="line"></span><br><span class="line">            if (__webpack_require__.nc) &#123;</span><br><span class="line">                script.setAttribute(&quot;nonce&quot;, __webpack_require__.nc);</span><br><span class="line">            &#125;</span><br><span class="line">            script.src = jsonpScriptSrc(chunkId);</span><br><span class="line">            var timeout = setTimeout(function()&#123;</span><br><span class="line">                onScriptComplete(&#123; type: &apos;timeout&apos;, target: script &#125;);</span><br><span class="line">            &#125;, 120000);</span><br><span class="line">            script.onerror = script.onload = onScriptComplete;</span><br><span class="line">            function onScriptComplete(event) &#123;</span><br><span class="line">                script.onerror = script.onload = null;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                var chunk = installedChunks[chunkId];</span><br><span class="line">                if(chunk !== 0) &#123;</span><br><span class="line">                    if(chunk) &#123;</span><br><span class="line">                        var errorType = event &amp;&amp; (event.type === &apos;load&apos; ? &apos;missing&apos; : event.type);</span><br><span class="line">                        var realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;</span><br><span class="line">                        var error = new Error(&apos;Loading chunk &apos; + chunkId + &apos; failed.\n(&apos; + errorType + &apos;: &apos; + realSrc + &apos;)&apos;);</span><br><span class="line">                        error.type = errorType;</span><br><span class="line">                        error.request = realSrc;</span><br><span class="line">                        chunk[1](https://cdn.example.com/error?m=webp&q=80);</span><br><span class="line">                    &#125;</span><br><span class="line">                    installedChunks[chunkId] = undefined;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            head.appendChild(script);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.all(promises);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>e函数主要做了这些事：</p><ol><li>缓存查找：从缓存installedChunks中查找是否有缓存模块，如果缓存标识为0，则表示模块已加载过，直接返回promise；如果缓存为数组，表示缓存正在加载中，则返回缓存的promise对象<br>2.如果没有缓存，则创建一个promise，并将promise和resolve、reject缓存在installedChunks中<br>3.构建一个script标签，append到head标签中，src指向加载的模块脚本资源，实现动态加载js脚本<br>4.添加script标签onload、onerror事件，如果超时或者模块加载失败，则会调用reject返回模块加载失败异常<br>5.如果模块加载成功，则返回当前模块promise，对应于import()</li></ol><h4 id="分割出来的模块0-js："><a href="#分割出来的模块0-js：" class="headerlink" title="分割出来的模块0.js："></a>分割出来的模块0.js：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([[0],&#123;</span><br><span class="line">    &quot;./a.js&quot;:(function(module, exports) &#123;</span><br><span class="line">        eval(&quot;</span><br><span class="line">            exports.foo = function()&#123;</span><br><span class="line">                return &apos;a&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>这里的webpackJsonp类似于jsonp中的callback，作用是作为模块加载和执行完成的回调，从而触发import的resolve。</p><p>从上面我们可以看出，webpack通过<strong>webpack_require</strong>.e函数实现了动态加载，再通过webpackJsonp函数实现异步加载回调，把模块内容以promise的方式暴露给调用方，从而实现了对code splitting的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Webpack模块化&quot;&gt;&lt;a href=&quot;#Webpack模块化&quot; class=&quot;headerlink&quot; title=&quot;Webpack模块化&quot;&gt;&lt;/a&gt;Webpack模块化&lt;/h2&gt;&lt;p&gt;对于webpack的模块化的实现，我们可以大致分为三种类型：&lt;strong&gt;
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="模块化" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>读读Koa2源码</title>
    <link href="http://yoursite.com/2018/06/14/%E8%AF%BB%E8%AF%BBKoa2%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2018/06/14/读读Koa2源码/</id>
    <published>2018-06-13T16:00:00.000Z</published>
    <updated>2018-10-23T15:05:45.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读读Koa2源码"><a href="#读读Koa2源码" class="headerlink" title="读读Koa2源码"></a>读读Koa2源码</h2><p>本人因为一直用的都是Koa2作为nodejs的开发框架，所以也对Koa2的原理产生了兴趣。于是我便花了一点时间分析了一下Koa2的源码，看看这个轻量级框架到底有多“轻”。</p><p>koa2的源码只有四个主要文件，我们一个一个来分析：<br><code>application.js</code>，<code>context.js</code>，<code>request.js</code>，<code>response.js</code></p><hr><h3 id="application-js-主入口文件"><a href="#application-js-主入口文件" class="headerlink" title="application.js 主入口文件"></a>application.js 主入口文件</h3><h4 id="继承events"><a href="#继承events" class="headerlink" title="继承events"></a>继承events</h4><p>这个文件导出了一个类<code>Application</code>，它继承了Emitter类，这样做是为了让koa也能监听事件，<br>例如，我们在koa中是这样来监听错误的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//没有处理过的错误将在这里被捕获</span><br><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line">app.on(&apos;error&apos;, err =&gt; console.log(err));</span><br></pre></td></tr></table></figure></p><h4 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h4><p>然后我们继续往下看，看到listen函数。<br>listen函数用于监听端口，它其实是对原生http模块的listen做了一下封装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">    debug(&apos;listen&apos;);</span><br><span class="line">    const server = http.createServer(this.callback());</span><br><span class="line">    return server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="callback函数"><a href="#callback函数" class="headerlink" title="callback函数"></a>callback函数</h4><p>我们看到createSever的时候传入了一个callback函数，它是创建完服务器之后要执行的回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line">    const fn = compose(this.middleware);</span><br><span class="line"></span><br><span class="line">    if (!this.listenerCount(&apos;error&apos;)) this.on(&apos;error&apos;, this.onerror);</span><br><span class="line"></span><br><span class="line">    const handleRequest = (req, res) =&gt; &#123;</span><br><span class="line">      const ctx = this.createContext(req, res);</span><br><span class="line">      return this.handleRequest(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它首先会把传入的中间件都用compose来处理（这是中间件的处理函数，后面会说到），然后返回一个handleRequest函数：先用createContext函数创建一个context环境，然后再把ctx和中间件放到handleRequest中去处理。</p><h4 id="compose函数"><a href="#compose函数" class="headerlink" title="compose函数"></a>compose函数</h4><p>在koa中compose是交给了<code>koa-compose</code>来处理，所以我们找来了<code>koa-compose</code>库来看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function compose (middleware) &#123;</span><br><span class="line">  if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;)</span><br><span class="line">  for (const fn of middleware) &#123;</span><br><span class="line">    if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return function (context, next) &#123;</span><br><span class="line">    // last called middleware #</span><br><span class="line">    let index = -1</span><br><span class="line">    return dispatch(0)</span><br><span class="line">    function dispatch (i) &#123;</span><br><span class="line">      if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;))</span><br><span class="line">      index = i</span><br><span class="line">      let fn = middleware[i]</span><br><span class="line">      if (i === middleware.length) fn = next</span><br><span class="line">      if (!fn) return Promise.resolve()</span><br><span class="line">      try &#123;</span><br><span class="line">        return Promise.resolve(fn(context, function next () &#123;</span><br><span class="line">          return dispatch(i + 1)</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        return Promise.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它先对传进来的中间件数组做一些合法性检测，然后返回一个函数来通过递归去遍历执行所有的中间件函数。<br>通过在<code>Promise.resolve(fn)</code>的回调中执行fn即实现了对异步函数的处理。我们可以关注一下 最初是执行的是 dispatch(0) 也就是this.middleware数组中下标为0的函数，也就是说 最先进入的中间件函数会最先被执行就像一个执行队列。<br>执行完成以后执行next()到下一步处理，next就是下一个的中间件。</p><h4 id="use函数"><a href="#use函数" class="headerlink" title="use函数"></a>use函数</h4><p>use函数也很简单，就是把中间件push到中间件数组当中最后返回this来提供链式调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use(fn) &#123;</span><br><span class="line">    if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;);</span><br><span class="line">    if (isGeneratorFunction(fn)) &#123;</span><br><span class="line">      deprecate(&apos;Support for generators will be removed in v3. &apos; +</span><br><span class="line">                &apos;See the documentation for examples of how to convert old middleware &apos; +</span><br><span class="line">                &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;);</span><br><span class="line">      fn = convert(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;);</span><br><span class="line">    this.middleware.push(fn);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="createContext函数"><a href="#createContext函数" class="headerlink" title="createContext函数"></a>createContext函数</h4><p>在上面的callback函数中我们看到它是通过createContext来创建ctx，<br>平时使用koa2的时候，ctx用的比较多，我们在ctx上面既可以处理req，又可以处理res，那它是怎么做到的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">createContext(req, res) &#123;</span><br><span class="line">    const context = Object.create(this.context);</span><br><span class="line">    const request = context.request = Object.create(this.request);</span><br><span class="line">    const response = context.response = Object.create(this.response);</span><br><span class="line">    context.app = request.app = response.app = this;</span><br><span class="line">    context.req = request.req = response.req = req;</span><br><span class="line">    context.res = request.res = response.res = res;</span><br><span class="line">    request.ctx = response.ctx = context;</span><br><span class="line">    request.response = response;</span><br><span class="line">    response.request = request;</span><br><span class="line">    context.originalUrl = request.originalUrl = req.url;</span><br><span class="line">    context.cookies = new Cookies(req, res, &#123;</span><br><span class="line">      keys: this.keys,</span><br><span class="line">      secure: request.secure</span><br><span class="line">    &#125;);</span><br><span class="line">    request.ip = request.ips[0] || req.socket.remoteAddress || &apos;&apos;;</span><br><span class="line">    context.accept = request.accept = accepts(req);</span><br><span class="line">    context.state = &#123;&#125;;</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实它也就是把一些常用的属性挂载到ctx上，让ctx就像一个大管家那样，拥有许多的权力。</p><h4 id="handleRequest函数"><a href="#handleRequest函数" class="headerlink" title="handleRequest函数"></a>handleRequest函数</h4><p>上面的callback函数就是把经过createContext处理的ctx和经过compose处理的fn传入到这个函数中，最终返回这个handleRequest函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">    const res = ctx.res;</span><br><span class="line">    res.statusCode = 404;</span><br><span class="line">    const onerror = err =&gt; ctx.onerror(err);</span><br><span class="line">    const handleResponse = () =&gt; respond(ctx);</span><br><span class="line">    onFinished(res, onerror);</span><br><span class="line">    return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>handleRequest中首先先取出res，先把默认状态置为404，然后对执行中间件后的成功和失败状态注册方法，失败调用ctx.onerror捕获异常，成功调用respond方法处理结果。这里还是用了onFinished模块，onFinished能确保一个流在关闭、完成和报错时都会执行相应的回调函数，这里把我们的异常处理函数传入用以处理错误信息。而respond方法，里面做的，就是读取ctx信息，把数据写入res中并响应请求。</p><h4 id="respond函数"><a href="#respond函数" class="headerlink" title="respond函数"></a>respond函数</h4><p>koa是通过respond来把数据写入res中并响应请求的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function respond(ctx) &#123;</span><br><span class="line">  //ctx.respond不存在则return</span><br><span class="line">  if (false === ctx.respond) return;</span><br><span class="line">    </span><br><span class="line">  //writable 是原生的 response 对象的 writeable 属性, 检查是否是可写流</span><br><span class="line">  const res = ctx.res;</span><br><span class="line">  if (!ctx.writable) return;</span><br><span class="line"></span><br><span class="line">  let body = ctx.body;</span><br><span class="line">  const code = ctx.status;</span><br><span class="line"></span><br><span class="line">  //如果响应的statusCode是属于body为空的类型, 例如204,205,304将body置为null</span><br><span class="line">  if (statuses.empty[code]) &#123;</span><br><span class="line">    ctx.body = null;</span><br><span class="line">    return res.end();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  //如果是HEAD方法，检查 http 响应头部是否已经被发送，如果头部未被发送, 那么添加 length 头部</span><br><span class="line">  if (&apos;HEAD&apos; == ctx.method) &#123;</span><br><span class="line">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span><br><span class="line">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span><br><span class="line">    &#125;</span><br><span class="line">    return res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //body为空的情况，那就把body设为message或者code，并修改头部的type和length</span><br><span class="line">  if (null == body) &#123;</span><br><span class="line">    body = ctx.message || String(code);</span><br><span class="line">    if (!res.headersSent) &#123;</span><br><span class="line">      ctx.type = &apos;text&apos;;</span><br><span class="line">      ctx.length = Buffer.byteLength(body);</span><br><span class="line">    &#125;</span><br><span class="line">    return res.end(body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //分别针对buffer，字符串，stream类型作相应的反应</span><br><span class="line">  if (Buffer.isBuffer(body)) return res.end(body);</span><br><span class="line">  if (&apos;string&apos; == typeof body) return res.end(body);</span><br><span class="line">  if (body instanceof Stream) return body.pipe(res);</span><br><span class="line"></span><br><span class="line">  //对 body 为 json 格式的数据进行处理</span><br><span class="line">  body = JSON.stringify(body);</span><br><span class="line">  if (!res.headersSent) &#123;</span><br><span class="line">    ctx.length = Buffer.byteLength(body);</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="context-js"><a href="#context-js" class="headerlink" title="context.js"></a>context.js</h3><p>context主要做的就是：</p><ol><li><p>将 request, response对象上的属性方法代理到 context 对象上。也就是说例如 this.ctx.headersSent 相当于 this.response.headersSent。request对象与response对象的所有方法与属性都能在 ctx 对象上找到。</p></li><li><p>对在中间函数数组生成的 Promise 的 catch 中与 res 对象的 onFinished 函数的回调的错误进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">onerror(err) &#123;</span><br><span class="line">    if (null == err) return;</span><br><span class="line">    // 将错误转化为 Error 实例</span><br><span class="line">    if (!(err instanceof Error)) err = new Error(util.format(&apos;non-error thrown: %j&apos;, err));</span><br><span class="line"></span><br><span class="line">    let headerSent = false;</span><br><span class="line">    if (this.headerSent || !this.writable) &#123;</span><br><span class="line">      headerSent = err.headerSent = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 触发 koa 实例对象的 error 事件, application 上的 onerror 函数会执行</span><br><span class="line">    this.app.emit(&apos;error&apos;, err, this);</span><br><span class="line">    // 如果响应头部已经发送(或者 socket 不可写)则返回</span><br><span class="line">    if (headerSent) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const &#123; res &#125; = this;</span><br><span class="line">    // 如果出错那么之前中间件或者其他地方设置的 HTTP 头部就无效了, 应该清空设置</span><br><span class="line">    if (typeof res.getHeaderNames === &apos;function&apos;) &#123;</span><br><span class="line">      res.getHeaderNames().forEach(name =&gt; res.removeHeader(name));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res._headers = &#123;&#125;; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.set(err.headers);</span><br><span class="line">    // 出错后响应类型为 text/plain</span><br><span class="line">    this.type = &apos;text&apos;;</span><br><span class="line">    </span><br><span class="line">    // 对 ENOENT 错误进行处理, ENOENT 的错误 message 是文件或者路径不存在, 所以状态码应该是 404</span><br><span class="line">    if (&apos;ENOENT&apos; == err.code) err.status = 404;</span><br><span class="line">    // 默认设置状态码为 500</span><br><span class="line">    if (&apos;number&apos; != typeof err.status || !statuses[err.status]) err.status = 500;</span><br><span class="line"></span><br><span class="line">    const code = statuses[err.status];</span><br><span class="line">    const msg = err.expose ? err.message : code;</span><br><span class="line">    this.status = err.status;</span><br><span class="line">    this.length = Buffer.byteLength(msg);</span><br><span class="line">    this.res.end(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="request-js-和-response-js"><a href="#request-js-和-response-js" class="headerlink" title="request.js 和 response.js"></a>request.js 和 response.js</h3><p><code>request.js</code>和<code>response.js</code>主要是对原生的http模块的requets和response对象进行封装, 其实就是对request和response对象某些属性或方法通过重写<code>getter/setter</code>函数进行代理。<br>因为重写封装的比较多，所以具体的也不多说了，有兴趣可以看看源码：<br><a href="https://github.com/koajs/koa/blob/master/lib/request.js" target="_blank" rel="noopener">koa的request.js</a><br><a href="https://github.com/koajs/koa/blob/master/lib/response.js" target="_blank" rel="noopener">koa的response.js</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;读读Koa2源码&quot;&gt;&lt;a href=&quot;#读读Koa2源码&quot; class=&quot;headerlink&quot; title=&quot;读读Koa2源码&quot;&gt;&lt;/a&gt;读读Koa2源码&lt;/h2&gt;&lt;p&gt;本人因为一直用的都是Koa2作为nodejs的开发框架，所以也对Koa2的原理产生了兴趣。于
      
    
    </summary>
    
      <category term="nodejs" scheme="http://yoursite.com/categories/nodejs/"/>
    
    
      <category term="Koa2" scheme="http://yoursite.com/tags/Koa2/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端数据流管理方案（五）——Rxjs篇</title>
    <link href="http://yoursite.com/2018/05/28/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94Rxjs%E7%AF%87/"/>
    <id>http://yoursite.com/2018/05/28/浅谈前端数据流管理方案（五）——Rxjs篇/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2018-10-23T15:05:47.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rxjs"><a href="#Rxjs" class="headerlink" title="Rxjs"></a>Rxjs</h2><p>下面我们来说说第三个流派，响应式observable流式流派。代表库有RXJS，它是Observable的Javascript实现，是一个强大的Reactive编程（面向数据流和变化传播的编程范式）库，提供了强大的数据流组合与控制能力。</p><p>它给人最直观的感觉就是通过链式操作让数据流动起来，把观察者模式和迭代器模式结合起来：数据源有变化的话就通知下游，通知的方式则是采用了迭代器中的next思想。它通常不会有取值这个操作，因为它是push-based的，下游obsever被动接受observable传来的数据。</p><hr><h3 id="Rxjs擅长做什么？"><a href="#Rxjs擅长做什么？" class="headerlink" title="Rxjs擅长做什么？"></a>Rxjs擅长做什么？</h3><ol><li>同步和异步的“和谐共处”。它把用于实现某一功能的同步异步方法按一定顺序组合到一起，使得两者执行起来有条不紊。</li><li>可组合的数据变更过程。当多个复杂的异步或者事件组合到一起的时候，它能够按一定顺序去处理多个数据序列。</li><li>数据和视图的精确绑定。在observable中可以把DOM事件作为数据源，而在observer中也可以执行更新视图的操作。</li><li>在操作时间轴方面得心应手。Rxjs提供的几个操作时间轴的Operator（delay,timeout,throttle,debounce,audit,bufferTime等等）使得我们对同步异步的处理更加随心所欲。</li><li>在多个服务端实时消息流的应用场景中，我们可以把数据源通过 Rx 进行高阶处理，最后到 view 层就是很清晰的一个 Observable。</li></ol><hr><h3 id="Rxjs的几个角色"><a href="#Rxjs的几个角色" class="headerlink" title="Rxjs的几个角色"></a>Rxjs的几个角色</h3><p>我们先通过Rxjs的几个角色，几种概念来去认识它。</p><h4 id="Observable-被观察者，管道入口"><a href="#Observable-被观察者，管道入口" class="headerlink" title="Observable 被观察者，管道入口"></a>Observable 被观察者，管道入口</h4><p>它是一个数据或事件的流的集合，就像一个序列，里面的数据源会按顺序依次推送到下游，也可以同时处理同步和异步的操作。<br>虽然它跟观察者模式的observable名字一样，但是具体上还是有所区别：这里的observable没有一份需要维护的订阅者的列表，它只是一个函数，如果你想要订阅它的话，只需要通过subscribe()把observer传进回调函数就好了。<br>创建observable的方式：</p><ul><li>单值：of，empty，never</li><li>多值：from</li><li>定时：interval，timer</li><li>事件：fromEvent</li><li>promise：fromPromise</li><li>自定义：create</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var observable = Rx.Observable</span><br><span class="line">// 通过create方法创建一个Observable</span><br><span class="line">// 回调函数会接受observer参数，也就是观察者角色</span><br><span class="line">    .create(function(observer) &#123;</span><br><span class="line">        observer.next(&apos;hi&apos;);</span><br><span class="line">        observer.next(&apos;world&apos;);</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            observer.next(&apos;这一段是异步操作&apos;);</span><br><span class="line">        &#125;, 30)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">// 订阅这个 observable</span><br><span class="line">// 只有在订阅之后，才会在流Observable变化的时候，调用observer提供的方法，并通知他 </span><br><span class="line">// 订阅之后也可以取消订阅，调用unsubscribe()即可</span><br><span class="line">console.log(&apos;start&apos;)</span><br><span class="line">var subscription = observable.subscribe(function(value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;end&apos;)</span><br><span class="line">setTimeOut(()=&gt; &#123;</span><br><span class="line">  subscription.unsubscribe()</span><br><span class="line">&#125;, 5000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 程序会依次输出</span><br><span class="line">&apos;start&apos;</span><br><span class="line">&quot;hi&quot;</span><br><span class="line">&apos;world&apos;</span><br><span class="line">&apos;end&apos;</span><br><span class="line">&apos;这一段是异步操作&apos;</span><br></pre></td></tr></table></figure></p><p>Rx 中的 Observable 对象默认是 lazy 且 cold 的，lazy 说的是如果 Observable 对象的 subscribe 方法没有被调用，那么 Producer 函数也就不会被调用。cold 是说每调用一次 subscribe 方法，就会执行一次 Producer 来产生一个新的 Subscription 流，也就是不同的 Subscription 流内的状态不会相互影响。（ps：它也可以是hot的，调用share这个API来实现）<br>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let interval = Rx.Observable.create(observer =&gt; &#123; </span><br><span class="line">setInterval(() =&gt; observer.next(), 1000) </span><br><span class="line">&#125;).scan(x =&gt; x+1, 0); //累加器，从 0 开始，类似在内部定义了一个count，然后每次count++ </span><br><span class="line">// 1, 2, 3... </span><br><span class="line">interval.subscribe(count =&gt; console.log(&apos;count1:&apos;+count)); </span><br><span class="line">setTimeout(() =&gt; &#123; </span><br><span class="line">// 3s 后监听，同样得到 1, 2, 3... 而不是 4, 5, 6..</span><br><span class="line">interval.subscribe(count =&gt; console.log(&apos;count2:&apos;+count)); </span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure></p><h4 id="Operator-对数据流的操作器"><a href="#Operator-对数据流的操作器" class="headerlink" title="Operator 对数据流的操作器"></a>Operator 对数据流的操作器</h4><p>可以用来对observable进行各种各样的操作。接受传进来的observable，通过操作后返回新的observable（这有点像immutable）。<br>操作符：</p><ul><li>改变数据值：map，mapTo</li><li>过滤：filter，skip，first，last，take</li><li>操作时间轴：delay，timeout，throttle，debounce，audit，bufferTime</li><li>累加：scan</li><li>异常处理：throw，catch</li><li>条件执行：takeUntil，delayWhen，observeOn</li><li>多个数据的合并操作：concat，merge，combineLatest，withLatestFrom，zip</li></ul><h4 id="Scheduler-控制Observable订阅开始执行和数据送达的时机"><a href="#Scheduler-控制Observable订阅开始执行和数据送达的时机" class="headerlink" title="Scheduler 控制Observable订阅开始执行和数据送达的时机"></a>Scheduler 控制Observable订阅开始执行和数据送达的时机</h4><p>一般有这么几种Scheduler：</p><ul><li>queue：把递归阻塞。</li><li>asap：as soon as possible，表现形式为setTimeout(()=&gt;{},0)。多用于永不退订的observable，例如轮询。</li><li>async：使observable执行方式变为异步。</li><li>animationFrame：适合高频率UI动画触发，用requestAnimationFrame实现的。<br>使用例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var observable = Rx.Observable.create(function (observer) &#123;</span><br><span class="line">    observer.next(1);</span><br><span class="line">    observer.next(2);</span><br><span class="line">    observer.next(3);</span><br><span class="line">    observer.complete();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;before subscribe&apos;);</span><br><span class="line">observable.observeOn(Rx.Scheduler.async) // 本来是同步的，变成了异步</span><br><span class="line">.subscribe(&#123;</span><br><span class="line">    next: (value) =&gt; &#123; console.log(value); &#125;,</span><br><span class="line">    error: (err) =&gt; &#123; console.log(&apos;Error: &apos; + err); &#125;,</span><br><span class="line">    complete: () =&gt; &#123; console.log(&apos;complete&apos;); &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;after subscribe&apos;);</span><br><span class="line"></span><br><span class="line">// &quot;before subscribe&quot;</span><br><span class="line">// &quot;after subscribe&quot;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// &quot;complete&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Subject-数据流管道的分岔接口，可进可出"><a href="#Subject-数据流管道的分岔接口，可进可出" class="headerlink" title="Subject 数据流管道的分岔接口，可进可出"></a>Subject 数据流管道的分岔接口，可进可出</h4><p>Subject可以向多个observer多路推送数据。每个subject既可以是一个observerable，也可以是一个observer。subject内部有一份它下游的observer的列表，在接收到上游传过来的值时，就会遍历这份列表并把值传递下去。<br>普通的subject:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个Observable，一秒钟输出一个数字，只取三个就结束</span><br><span class="line">var source = Rx.Observable.interval(1000).take(3);</span><br><span class="line"></span><br><span class="line">// 定义两个observer对象</span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个subject —— 特殊的Observable</span><br><span class="line">var subject = new Rx.Subject()</span><br><span class="line"></span><br><span class="line">// observerA订阅Subject</span><br><span class="line">subject.subscribe(observerA)</span><br><span class="line"></span><br><span class="line">// Subject又以observer的身份订阅Observable</span><br><span class="line">source.subscribe(subject);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subject.subscribe(observerB);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">// 输出：</span><br><span class="line">// &quot;A next: 0&quot;</span><br><span class="line">// &quot;A next: 1&quot;</span><br><span class="line">// &quot;B next: 1&quot;</span><br><span class="line">// &quot;A next: 2&quot;</span><br><span class="line">// &quot;B next: 2&quot;</span><br><span class="line">// &quot;A complete!&quot;</span><br><span class="line">// &quot;B complete!&quot;</span><br><span class="line"> A、B两个observer互不影响，是独立的</span><br></pre></td></tr></table></figure></p><p>除了基本的subject外，它还有这么几种类型：</p><ol><li><p>BehaviorSubject：初始化的时候传入一个参数作为当前值，执行过后它会把最新的值记住，作为当前值，因此它是有状态的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// BehaviorSubject 在建立时就需要给定一个状态，并在之后任何一次订阅，就会先送出最新的状态。其实这种行为就是一种状态的表达而非单存的事件，就像是年龄跟生日一样，年龄是一种状态而生日就是事件；所以当我们想要用一个stream 来表达年龄时，就应该用BehaviorSubject 。</span><br><span class="line"></span><br><span class="line">var subject = new Rx.BehaviorSubject(0); // 0</span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.subscribe(observerA);</span><br><span class="line">// &quot;A next: 0&quot;</span><br><span class="line">subject.next(1);</span><br><span class="line">// &quot;A next: 1&quot;</span><br><span class="line">subject.next(2);</span><br><span class="line">// &quot;A next: 2&quot;</span><br><span class="line">subject.next(3);</span><br><span class="line">// &quot;A next: 3&quot;</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subject.subscribe(observerB); </span><br><span class="line">    // &quot;B next: 3&quot;</span><br><span class="line">&#125;,3000)</span><br></pre></td></tr></table></figure></li><li><p>ReplaySubject：在有新订阅时，重新发送最后的n个值，n是你传进来的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.ReplaySubject(2); // 重复发送最后俩个元素</span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.subscribe(observerA);</span><br><span class="line">subject.next(1);</span><br><span class="line">// &quot;A next: 1&quot;</span><br><span class="line">subject.next(2);</span><br><span class="line">// &quot;A next: 2&quot;</span><br><span class="line">subject.next(3);</span><br><span class="line">// &quot;A next: 3&quot;</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subject.subscribe(observerB);</span><br><span class="line">    // &quot;B next: 2&quot;</span><br><span class="line">    // &quot;B next: 3&quot;</span><br><span class="line">&#125;,3000)</span><br></pre></td></tr></table></figure></li><li><p>AsyncSubject：它会一直等等到complete后才会传值，传递最后一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var subject = new Rx.AsyncSubject();</span><br><span class="line">var observerA = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var observerB = &#123;</span><br><span class="line">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class="line">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class="line">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.subscribe(observerA);</span><br><span class="line">subject.next(1);</span><br><span class="line">subject.next(2);</span><br><span class="line">subject.next(3);</span><br><span class="line">subject.complete();</span><br><span class="line">// &quot;A next: 3&quot;</span><br><span class="line">// &quot;A complete!&quot;</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    subject.subscribe(observerB);</span><br><span class="line">    // &quot;B next: 3&quot;</span><br><span class="line">    // &quot;B complete!&quot;</span><br><span class="line">&#125;,3000)</span><br></pre></td></tr></table></figure></li></ol><h4 id="Observer-观察者，只进不出"><a href="#Observer-观察者，只进不出" class="headerlink" title="Observer 观察者，只进不出"></a>Observer 观察者，只进不出</h4><p>接受上游数据，并作出相应的反应。它的表现形式与迭代器模式相对应，形如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var observer = &#123;</span><br><span class="line">    next:function(value)&#123;&#125;, //接收到observable的数据时触发</span><br><span class="line">    error:function(err)&#123;&#125;,  //接收到错误时触发</span><br><span class="line">    complete:function()&#123;&#125;   //执行完毕的时候触发(处理完所有的next后)，complete一旦执行后，next就不会再执行了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="Rxjs流程图"><a href="#Rxjs流程图" class="headerlink" title="Rxjs流程图"></a>Rxjs流程图</h3><p><img src="https://user-gold-cdn.xitu.io/2017/8/1/e66826df704255809a7e9477996d60d7?imageslim" alt="Rxjs"></p><hr><h3 id="Observable和Promise的区别"><a href="#Observable和Promise的区别" class="headerlink" title="Observable和Promise的区别"></a>Observable和Promise的区别</h3><p>它们都可以用于对副作用进行归一化，但加以比较的话，使用 rxjs 来做更为适合。<br>首先事件机制与 rxjs 很像，另外 promise 只能返回一次，而且之后 resolve reject 两种状态，而 Observable 可以返回多次，而且没有内置的状态，所以可以更加灵活的表示状态。<br>我们可以把Observable看成是一个有可变数据量的Promise，而Promise只能处理一个数据。<br>在分发和联动关系多的时候，Rxjs才能够体现出它比起Promise,Generator的优势。<br>ps：这样可以把observable转化成promise：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const promise = observable.toPromise();</span><br></pre></td></tr></table></figure></p><hr><h3 id="Rxjs实际使用"><a href="#Rxjs实际使用" class="headerlink" title="Rxjs实际使用"></a>Rxjs实际使用</h3><p><strong>示例1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Observable = Rx.Observable  </span><br><span class="line">const input = document.querySelector(&apos;input&apos;)</span><br><span class="line"></span><br><span class="line">const search$ = Observable.fromEvent(input, &apos;input&apos;)  </span><br><span class="line">  .map(e =&gt; e.target.value)</span><br><span class="line">  .filter(value =&gt; value.length &gt;= 1)</span><br><span class="line">  .throttleTime(100)</span><br><span class="line">  .distinctUntilChanged()</span><br><span class="line">  .switchMap(term =&gt; Observable.fromPromise(wikiIt(term)))</span><br><span class="line">  .subscribe(</span><br><span class="line">    x =&gt; renderSearchResult(x),</span><br><span class="line">    err =&gt; console.error(err)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p><p>上面的代码做了以下事情：</p><p>监听 input 元素的 input 事件<br>一旦发生，把事件对象 e 映射成 input 元素的值<br>接着过滤掉值长度小于 1 的<br>并且还设置了一个 throttle ( 节流器 )，两次输入间隔不超过 100 毫秒为有效输入<br>如果该值和过去最新的值相等的话，忽略他<br>最后，拿到值便调用 Wikipedia 的一个 API<br>最后的最后，需要 subscribe 才能拿到 API 返回的数据</p><p><strong>示例2（拖拽）：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var box = document.getElementById(&apos;box&apos;);</span><br><span class="line"></span><br><span class="line">var scroll = Rx.Observable.fromEvent(document, &apos;scroll&apos;);</span><br><span class="line">var mouseDown = Rx.Observable.fromEvent(box, &apos;mousedown&apos;)</span><br><span class="line">var mouseUp = Rx.Observable.fromEvent(document, &apos;mouseup&apos;)</span><br><span class="line">var mouseMove = Rx.Observable.fromEvent(document, &apos;mousemove&apos;)</span><br><span class="line"></span><br><span class="line">var validValue = (value, max, min) =&gt; &#123;</span><br><span class="line">    return Math.min(Math.max(value, min), max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mouseDown</span><br><span class="line">    .map(e =&gt; mouseMove.takeUntil(mouseUp))</span><br><span class="line">    .concatAll()</span><br><span class="line">//   完整版拖拽</span><br><span class="line">//     .withLatestFrom(mouseDown, (move, down) =&gt; &#123;</span><br><span class="line">//         return &#123;</span><br><span class="line">//             x: validValue(move.clientX - down.offsetX, window.innerWidth - 320, 0),</span><br><span class="line">//             y: validValue(move.clientY - down.offsetY, window.innerHeight - 180, 0)</span><br><span class="line">//         &#125;</span><br><span class="line">//     &#125;)</span><br><span class="line">//  简单版拖拽</span><br><span class="line">    .map(event =&gt; (&#123; x: event.clientX, y: event.clientY &#125;))</span><br><span class="line">    .subscribe(pos =&gt; &#123;</span><br><span class="line">        box.style.top = pos.y + &apos;px&apos;;</span><br><span class="line">        box.style.left = pos.x + &apos;px&apos;;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p><strong>示例3（实时获取时间。如果某个用户停留在某个页面时间太长，评论上的时间信息会变得不准确，比如说，用户停留了一个小时，而它看到的信息还显示：5分钟之前发表了评论，实际时间是一个小时零5分钟以前的事了。）：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(1000).subscribe(() =&gt; &#123;</span><br><span class="line">  this.diff = moment(createAt).fromNow()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><hr><h3 id="结合Vue，Redux的使用"><a href="#结合Vue，Redux的使用" class="headerlink" title="结合Vue，Redux的使用"></a>结合Vue，Redux的使用</h3><p>在 React/Vue 应用中部分使用 Rx 是完全没有问题的。思路上来说就是把 React/Vue 组件的 local state 当做一个『中介』，在一个 Rx Observable 的 subscribe 回调里面更新组件状态。通过简单的绑定库支持，可以完全把 component state 作为一个实现细节封装掉，实现 Observable -&gt; view 的声明式绑定。</p><h4 id="结合Vue"><a href="#结合Vue" class="headerlink" title="结合Vue"></a>结合Vue</h4><p>比如我们可以在created时初始化一个observable，beforeDestroy时取消订阅observable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;  </span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    time: &apos;&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    this.timer$ = Rx.Observable.interval(1000)</span><br><span class="line">      .map(() =&gt; new Date())</span><br><span class="line">      .map(d =&gt; moment(d).format(&apos;hh:mm:ss&apos;))</span><br><span class="line">      .subscribe(t =&gt; &#123;</span><br><span class="line">        this.time = t</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    this.timer$.unsubscribe()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="结合Redux"><a href="#结合Redux" class="headerlink" title="结合Redux"></a>结合Redux</h4><p>可以通过redux-observable这个库来配合Redux。（下文会提到这个库）</p><hr><h3 id="Redux中间件redux-observable"><a href="#Redux中间件redux-observable" class="headerlink" title="Redux中间件redux-observable"></a>Redux中间件redux-observable</h3><p>Rxjs带来了两种新的开发方式，第一种是将一切前端副作用转化为数据源，因此副作用已经在数据源转换这一层完全隔离了，然后通过纯函数的操作，最后直接对接到 dom。另一种是类似 redux-observable，将 rxjs 数据流处理能力融合到已有数据流框架中。</p><p>redux-observable 将 action 与 reducer 改造为 stream 模式，对 action 中副作用行为，比如发请求，也提供了封装好的函数转化为数据源，因此，将 redux middleware 中的副作用，转移到了数据源转换，让 action 保持纯函数，同时增强了原本就是纯函数的 reducer 的数据处理能力。</p><p>如果说 redux-saga 解决了异步，那么 redux-observable 就是解决了副作用，同时赠送了 Rxjs 数据处理能力。</p><p>来看看它是怎么用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 定义两个action creator</span><br><span class="line">// 1. 拉取某用户数据</span><br><span class="line">const fetchUser = username =&gt; (&#123; type: &apos;GET_DATA&apos;, target: username &#125;);</span><br><span class="line">// 2. 拉取完成</span><br><span class="line">const fetchUserDone = data =&gt; (&#123; type: &apos;GET_SUCCESS&apos;, data&#125;);</span><br><span class="line"></span><br><span class="line">// 定义一个Epics函数</span><br><span class="line">const fetchEpics = (action$) =&gt; &#123;</span><br><span class="line">        return action$.ofType(&apos;GET_DATA&apos;)</span><br><span class="line">                      .mergeMap((action)=&gt;&#123;</span><br><span class="line">                          return ajax.getJson(`/api/users/$&#123;action.target&#125;`)</span><br><span class="line">                      &#125;)</span><br><span class="line">                      .map((data)=&gt;&#123;</span><br><span class="line">                          fetchUserDone(data)</span><br><span class="line">                      &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="Rxjs跟Redux的对比"><a href="#Rxjs跟Redux的对比" class="headerlink" title="Rxjs跟Redux的对比"></a>Rxjs跟Redux的对比</h3><p>基于Flux实现的方案中一个很大的痛点就是它的繁琐，造成它繁琐的原因就是它的自定义action，<br>如果不从根本上对事件这种机制进行抽象，就不可能彻底解决繁琐的问题。</p><p>基于Reactive理念的库天然就是为了处理对事件机制的抽象而出现的，所以用在这种场景下有奇效，它能把action的派发与处理过程描述得优雅精妙。在这样的机制里，我们可以很清楚地看到一块数据的来龙去脉，它最初是哪里来的，后来可能会被谁修改过。所有这样的数据都放置在管道中，除了指定的入口，不会有其他东西能够修改这些数据，视图可以很安全地订阅他们。</p><ol><li><p>数据转换逻辑。打个比方，同样是表达数据a到b这么一个转换，两者所关注的点可能是不一样的：<br>Redux：定义一个action叫做AtoB，在其实现中，把a转换成b。<br>Rx：定义两个数据流A和B，B是从A经过一次map转换得到的，map的表达式是把a转成b。</p></li><li><p>数据处理逻辑。在数据变更的链路较长时，Rx是具有很大优势的，它可以很简便地做多级状态变更的连接，也可以做数据变更链路的复用（比如存在a -&gt; b -&gt; c，又存在a -&gt; b -&gt; d，可以把a -&gt; b这个过程拿出来复用），还天生能处理好包括竞态在内的各种异步的情况，Redux可能要借助saga等理念才能更好地组织代码。</p></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过了这个系列文章的学习后，我们发现，Redux和Rxjs完全隔离了副作用，是因为他们有一个共性，那就是对前端副作用的抽象。redux 通过在 action 做副作用，将副作用隔离在 reducer 之外，使reducer成为了纯函数。rxjs将副作用先转化为数据源，将副作用隔离在管道流处理之外。<br>唯独 mobx，缺少了对副作用抽象这一层，所以导致了代码写的比redux和rxjs更爽，但副作用与纯函数混杂在一起，因此与函数式无缘。</p><p>综上，我们可以看出，现代前端数据流流动过程分为以下几个部分：<br>更新触发 -&gt; 副作用隔离 -&gt; 数据状态变更 -&gt; 视图渲染</p><ul><li>更新触发往往是视图层发送一个指令来传达某个状态需要改变。</li><li>副作用隔离就是把一切与数据本身修改无关的指令通通隔离，使得数据变更的这一过程变得“纯净”。</li><li>数据状态变更就是修改值，修改最新状态，在这里也有immutable和mutable之分。</li><li>视图渲染就是状态数据更新完成后到通知视图更新数据，再到经过virtualDom,diff等优化操作后将数据映射到视图上的过程。</li></ul><p>写到这里，前端数据流管理方案系列也告一段落了，从对这三者在特点、流程、角色上的学习也着实能感受到数据流的严谨、科学之处，数据流管理模式的探索肯定不会就此停滞，期待未来数据流管理的发展。</p><p>总而言之，数据状态管理没有银弹，不论黑猫白猫，抓到老鼠的才是好猫。(●’◡’●)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Rxjs&quot;&gt;&lt;a href=&quot;#Rxjs&quot; class=&quot;headerlink&quot; title=&quot;Rxjs&quot;&gt;&lt;/a&gt;Rxjs&lt;/h2&gt;&lt;p&gt;下面我们来说说第三个流派，响应式observable流式流派。代表库有RXJS，它是Observable的Javascrip
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="前端数据流" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
      <category term="Rxjs" scheme="http://yoursite.com/tags/Rxjs/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端数据流管理方案（四）——Redux篇</title>
    <link href="http://yoursite.com/2018/05/17/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Redux%E7%AF%87/"/>
    <id>http://yoursite.com/2018/05/17/浅谈前端数据流管理方案（四）——Redux篇/</id>
    <published>2018-05-16T16:00:00.000Z</published>
    <updated>2018-10-24T07:08:29.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理，属于Flux模式的具体实现之一，核心理念是在初始状态上依次叠加后续的变更，所得的就是当前的状态。</p><hr><h3 id="Redux各部分职能"><a href="#Redux各部分职能" class="headerlink" title="Redux各部分职能"></a>Redux各部分职能</h3><p>先来了解一下Redux的主要组成部分：</p><ul><li><p>Action：触发改变store中的state的唯一方法，它通过store.dispatch来将action传到store中。</p></li><li><p>Reducer：action只是描述事件的简单对象，而reducer会说明怎么更新state。reducer是一个纯函数：（(prevState,action)=&gt;newState）。因此你不能在reducer中执行这些操作：修改传入的参数；执行有副作用的操作；调用非纯函数（如Date.now(),Math.random()等等）。</p></li><li><p>Store：存放整个应用的state，并将action和reducer联系起来。store可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。Redux应用只有一个单一的store。当需要拆分数据处理逻辑时，你应该使用 reducer 组合而不是创建多个 store。它提供了以下四个方法：</p><ol><li>dispatch:用于action的分发。在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。</li><li>subscribe：监听state的变化。这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。 let unsubscribe = store.subscribe(() =&gt; {console.log(‘state发生了变化’)})</li><li>getState：获取store中的state。当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。</li><li>replaceReducer:替换reducer，改变state修改的逻辑。</li></ol></li><li><p>View：触发action以改变state，以及接收state数据以渲染界面。以react视图层为例，react通过react-redux把store绑定到视图上。</p></li></ul><hr><h3 id="Redux流程"><a href="#Redux流程" class="headerlink" title="Redux流程"></a>Redux流程</h3><p>那么这几个部分是怎么串联起来，相互配合，实现单向数据流的呢？</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg" alt="Redux流程示意图"></p><p><strong>一、初始化</strong></p><ol><li>创建好store。根reducer通过combineReducers()合并了reducers，然后作为参数传入createStore()中，生成唯一的store。</li><li>建立store与组件间的通信。通过Provider组件建立联系，Provider实质上是创建了一个用于更新视图的网络，智能组件通过connect()连入网络，以获取state更新。</li><li>在组件中准备好action的回调函数。 为了让木偶组件更容易处理动作，智能组件可以使用bindActionCreators()来设置action回调函数。 这样，他们可以将回调函数传递给木偶组件。</li></ol><p><strong>二、触发数据流</strong></p><ol><li>视图发出一个action，actionCreator将它格式化并返回它。</li><li>这个action要么被自动dispatch（使用了bindActionCreators()），要么由view手动dispatch。</li><li>store接收到这个action后，将当前的状态树和action传给了根reducer。</li><li>根reducer将整个状态树分割成一个个小块，然后将某个小块分发给知道该怎么处理这部分内容的子reducer。</li><li>子reducer将传入的一小块状态树进行拷贝，然后在这个副本上进行修改，最终将修改后的副本返回给根reducer。</li><li>根reducer将子reducer返回过来的部分再次组合成一棵新的状态树，然后把它交给store，store就会把当前的状态置为这棵最新的状态树。</li><li>store告诉view状态更新了，view让store把更新的状态传过去，之后view触发rerender进行重新渲染。</li></ol><hr><h3 id="Redux三大原则"><a href="#Redux三大原则" class="headerlink" title="Redux三大原则"></a>Redux三大原则</h3><p>Redux有三大基本原则：</p><ul><li>单一数据源：整个应用的状态state都是存储在一棵树上，并且这棵状态树只存在于唯一一个store中。</li><li>state是只读的：对state的修改的唯一做法是触发action，不能直接修改state。</li><li>用纯函数执行修改：reducer根据旧状态和传进来的action来生成一个新的state，不直接修改state。<br>（ps：纯函数是什么？<br>纯函数就是有相同输入值时只会产生相同的输出的函数，而且纯函数中不包含任何产生副作用的语句。）</li></ul><hr><h3 id="Redux处理异步的中间件"><a href="#Redux处理异步的中间件" class="headerlink" title="Redux处理异步的中间件"></a>Redux处理异步的中间件</h3><p>Redux针对异步数据流的情况，也设计出中间件这个概念来隔离异步所带来的副作用。它的主要目的就是控制异步dispatch，分离副作用。</p><p>接下来说说最具代表性的两个异步中间件：redux-thunk 和 redux-saga。</p><h4 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h4><p>它是一个dispatch的改造者，先来看看它是怎么用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async function getUserName(dispatch, getState, id) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        const user = await axios.get(`xxxx`);</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: &apos;GETUSERNAME_SUCCESS&apos;,</span><br><span class="line">            data: name</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: &apos;GETUSERNAME_FAILED&apos;,</span><br><span class="line">            error: err</span><br><span class="line">        &#125;);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch(getUserName);</span><br></pre></td></tr></table></figure></p><p>redux-thunk把dispatch改造成可以接受一个函数作为参数。这个函数往往就是我们定义的一个异步处理函数。如上例，我们在里面发起了一个异步的网络请求，当有数据返回的时候，就会执行成功或失败所对应的dispatch（这个dispatch就是我们平常用的dispatch），同步提交action。</p><p>接下来看看它的源码。<br>redux-thunk的源码只有短短的11行，对，你没看错，就是11行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createThunkMiddleware(extraArgument) &#123;</span><br><span class="line">  return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">    if (typeof action === &apos;function&apos;) &#123;</span><br><span class="line">      return action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line">    return next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line">export default thunk;</span><br></pre></td></tr></table></figure></p><p>这个中间件做的工作主要是判断传进来的参数是不是一个函数，是的话就执行传进来的函数（正常来说dispatch里面传的是一个plainObject，也就是一个action，但是redux-thunk使得dispatch里能传一个函数，这个函数就是包含异步处理逻辑的函数），不是的话交给下一个中间件处理。</p><h4 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h4><p>它是redux的集中处理副作用的异步处理中间件，被实现为generator，以监听=&gt;执行的工作形式来运行。</p><p><img src="https://wx4.sinaimg.cn/mw690/768c39d5gy1fqvrrtolovj20tw09tq4f.jpg" alt="redux-saga流程"></p><p>按照惯例，先说说redux-saga是怎么用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//1.put:相当于redux的dispatch</span><br><span class="line">yield put(&#123;type:&apos;LOGIN&apos;&#125;); </span><br><span class="line"></span><br><span class="line">//2.select:相当于redux的getState</span><br><span class="line">const name = yield select(state=&gt;state.name);</span><br><span class="line"></span><br><span class="line">//3.take:监听action，当GETNAME这个action被触发才会往下执行（参数也可以是*，代表所有action）</span><br><span class="line">while(true)&#123;</span><br><span class="line">    yield take(&apos;GETNAME&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//4.takeEvery:一直监听action，takeEvery 是每次 action 触发的时候都响应，而 take 则是执行流执行到 take 语句时才响应。</span><br><span class="line">yield takeEvery(&apos;*&apos;,function* logger(action)&#123;</span><br><span class="line">    console.log(action)</span><br><span class="line">&#125;);</span><br><span class="line">//takeEvery的模拟实现</span><br><span class="line">function* takeEvery(pattern, saga, ...args) &#123;</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    const action = yield take(pattern)</span><br><span class="line">    yield fork(saga, ...args.concat(action))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//5.call:阻塞型调用，一般用于获取网络请求数据</span><br><span class="line">const members = yield call(fetchMembers, project.id);</span><br><span class="line">//并行发起请求</span><br><span class="line">const [users, products] = yield [</span><br><span class="line">  call(fetch, &apos;/users&apos;),</span><br><span class="line">  call(fetch, &apos;/products&apos;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//6.fork:非阻塞型调用</span><br><span class="line">const countTaskId = yield fork(count, number);</span><br></pre></td></tr></table></figure></p><p>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export function* loginSaga() &#123;</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    const &#123; user, pass &#125; = yield take(LOGIN_REQUEST) //等待 Store 上指定的 action LOGIN_REQUEST</span><br><span class="line">    try &#123;</span><br><span class="line">      let &#123; data &#125; = yield call(loginRequest, &#123; user, pass &#125;); //阻塞，请求后台数据</span><br><span class="line">      yield fork(loadUserData, data.uid); //非阻塞执行loadUserData</span><br><span class="line">      yield put(&#123; type: LOGIN_SUCCESS, data &#125;); //发起一个action，类似于dispatch</span><br><span class="line">    &#125; catch(error) &#123;</span><br><span class="line">      yield put(&#123; type: LOGIN_ERROR, error &#125;);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function* loadUserData(uid) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield put(&#123; type: USERDATA_REQUEST &#125;);</span><br><span class="line">    let &#123; data &#125; = yield call(userRequest, `/users/$&#123;uid&#125;`);</span><br><span class="line">    yield put(&#123; type: USERDATA_SUCCESS, data &#125;);</span><br><span class="line">  &#125; catch(error) &#123;</span><br><span class="line">    yield put(&#123; type: USERDATA_ERROR, error &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以把redux-saga理解为启动了一个“监听线程”，这个线程处理的输入是action，输出也是action，中间的逻辑就可以自己自由处理了。是在action和reducer之外的一层逻辑，使用saga会保持action的简单。</p><p>比起redux-thunk有这么几个优点：</p><ol><li>生命周期有所不同，redux-saga 可以理解成一直运行于后台的“LLT”（长时事务），而 redux-thunk 是一个 action，因而 redux-saga 能做的事情更多。</li><li>比起thunk，saga提供了更多的流程控制能力。redux-saga 有诸多常用并且声明式易测的 Effects，比如它可以无阻塞地调用一个 generator（fork）、中断一个generator（cancel）。这些特性在业务逻辑复杂的场景下非常适用。</li><li>redux-saga 最具魅力的地方，是它保持了 action 的原义，保持 action 的简洁，把所有有副作用的地方独立开来。dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满 “黑魔法” thunk function。这种特性让 redux-saga 在业务逻辑简单的场景下，也能保持代码清晰简洁，也就是说 redux-saga 的适用性较为普遍。</li></ol><h4 id="redux-observable"><a href="#redux-observable" class="headerlink" title="redux-observable"></a>redux-observable</h4><p>在《浅谈前端数据流管理方案（五）——Rxjs篇》有提到，这里先不说。</p><hr><h3 id="连接React和Redux的桥梁：React-Redux"><a href="#连接React和Redux的桥梁：React-Redux" class="headerlink" title="连接React和Redux的桥梁：React-Redux"></a>连接React和Redux的桥梁：React-Redux</h3><p><img src="https://raw.githubusercontent.com/bailicangdu/react-pxq/master/screenshot/all_redux.png" alt="redux配合react流程示意图"></p><h4 id="react-redux主要提供了这么两个方法："><a href="#react-redux主要提供了这么两个方法：" class="headerlink" title="react-redux主要提供了这么两个方法："></a>react-redux主要提供了这么两个方法：</h4><ol><li><p>provider。相当于一个高阶组件，包在整个组件树的最外层，让所有子孙组件都能使用connect来绑定store。它利用了 React 的 context 这一特性，只要在最外层的组件实现一个 getChildContext这个方法（React内置的），返回一个对象，内部的组件都可以通过 this.context 拿到这个对象。</p></li><li><p>connect。若一个组件想响应状态的变化，就把自己作为参数传给connect。<br>我们先看一下 connect 一般情况下是怎么使用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(MyComponent)</span><br></pre></td></tr></table></figure></li></ol><p>首先，export 出去的是一个增强过的 react 组件，也就是说 connect(mapStateToProps, mapDispatchToProps) 第一步首先返回了一个高阶组件。connect()()有两次执行，那么 connect 第二步具体做了什么呢？被这样包裹了一层之后，相应的组件变成了 Container / Smart Component，可以通过 this.props 来获取 store 里的 state，以及 dispatch 这个方法。这样一来，store.state 的更新也就触发了 this.props 的更新，继而触发了容器组件的 re-render。所以，connect 第二步就是把 mapStateToProps 和 mapDispatchToProps 里的返回的属性，以及本身的 props 一起，作为 props 传递给了被包裹的组件。<br>那么，connect 是怎么做到监听 store 变化的呢？答案是用到了Redux的subscribe这个API。综上，connect的内部应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function connect(mapStateToProps, mapDispatchToProps) &#123;</span><br><span class="line">  return function createHOC(WrappedComponent) &#123;</span><br><span class="line">    class Connect extends React.Component &#123;</span><br><span class="line">      constructor(props, context) &#123;</span><br><span class="line">        this.store = context.store // &lt;Provider /&gt; 提供</span><br><span class="line">      &#125;</span><br><span class="line">      componentDidMount() &#123;</span><br><span class="line">        this.unsubscribe = this.store.subscribe(this.handleChange.bind(this))</span><br><span class="line">      &#125;</span><br><span class="line">      componentWillUnmount() &#123;</span><br><span class="line">        this.unsubscribe()</span><br><span class="line">      &#125;</span><br><span class="line">      handleChange() &#123;</span><br><span class="line">        this.forceUpdate()</span><br><span class="line">      &#125;</span><br><span class="line">      render() &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;WrappedComponent </span><br><span class="line">            &#123;...this.props&#125;</span><br><span class="line">            &#123;...mapStateToProps(this.store.getState(), this.props)&#125;</span><br><span class="line">            &#123;...mapDispatchToProps(this.store.dispatch, this.props)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Connect.displayName = `Connect($&#123;WrappedComponent.name </span><br><span class="line">                              || WrappedComponent.displayName&#125;)`</span><br><span class="line">    return Connect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="考虑使用Immutable优化纯函数的操作"><a href="#考虑使用Immutable优化纯函数的操作" class="headerlink" title="考虑使用Immutable优化纯函数的操作"></a>考虑使用Immutable优化纯函数的操作</h3><p>Redux的宗旨就是单一数据流，可追溯，这两点恰恰是immutable.js的优势。<br>Immutable Data就是一旦创建，就不能再被更改的数据。对Immutable对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是持久化数据结构，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免深拷贝把所有节点都复制一遍带来的性能损耗，Immutable 使用了结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p><p>示例图：<br><img src="http://img.alicdn.com/tps/i2/TB1zzi_KXXXXXctXFXXbrb8OVXX-613-575.gif" alt="Immutable结构共享"></p><p>比如说，我们可以在reducer中这样用immutable：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">export const proData = (state = defaultState, action) =&gt; &#123;</span><br><span class="line">  let imuDataList;</span><br><span class="line">  let imuItem;</span><br><span class="line">  switch(action.type)&#123;</span><br><span class="line">    case pro.GETPRODUCTION: </span><br><span class="line">      return &#123;...state, ...action&#125;</span><br><span class="line">    case pro.TOGGLESELECT:</span><br><span class="line">      //避免引用类型数据，使用immutable进行数据转换 </span><br><span class="line">      imuDataList = Immutable.List(state.dataList);</span><br><span class="line">      imuItem = Immutable.Map(state.dataList[action.index]);</span><br><span class="line">      imuItem = imuItem.set(&apos;selectStatus&apos;, !imuItem.get(&apos;selectStatus&apos;));</span><br><span class="line">      imuDataList = imuDataList.set(action.index, imuItem);</span><br><span class="line">      // redux必须返回一个新的state</span><br><span class="line">      return &#123;...state, ...&#123;dataList: imuDataList.toJS()&#125;&#125;;</span><br><span class="line">    case pro.EDITPRODUCTION:</span><br><span class="line">      //避免引用类型数据，使用immutable进行数据转换 </span><br><span class="line">      imuDataList = Immutable.List(state.dataList);</span><br><span class="line">      imuItem = Immutable.Map(state.dataList[action.index]);</span><br><span class="line">      imuItem = imuItem.set(&apos;selectNum&apos;, action.selectNum);</span><br><span class="line">      imuDataList = imuDataList.set(action.index, imuItem);</span><br><span class="line">      // redux必须返回一个新的state</span><br><span class="line">      return &#123;...state, ...&#123;dataList: imuDataList.toJS()&#125;&#125;;</span><br><span class="line">    // 清空数据</span><br><span class="line">    case pro.CLEARSELECTED:</span><br><span class="line">      imuDataList = Immutable.fromJS(state.dataList);</span><br><span class="line">      for (let i = 0; i &lt; state.dataList.length; i++) &#123;</span><br><span class="line">        imuDataList = imuDataList.update(i, item =&gt; &#123;</span><br><span class="line">          item = item.set(&apos;selectStatus&apos;, false);</span><br><span class="line">          item = item.set(&apos;selectNum&apos;, 0);</span><br><span class="line">          return item</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      return &#123;...state, ...&#123;dataList: imuDataList.toJS()&#125;&#125;;</span><br><span class="line">    default: </span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Immutable带来的优点"><a href="#Immutable带来的优点" class="headerlink" title="Immutable带来的优点"></a>Immutable带来的优点</h4><ol><li>Immutable 降低了 Mutable 带来的复杂度。可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function touchAndLog(touchFn) &#123;</span><br><span class="line">  let data = &#123; key: &apos;value&apos; &#125;;</span><br><span class="line">  touchFn(data);</span><br><span class="line">  console.log(data.key); // 猜猜会打印什么？</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在不查看 <code>touchFn</code> 的代码的情况下，因为不确定它对 <code>data</code> 做了什么，你是不可能知道会打印什么。但如果 <code>data</code> 是 <code>Immutable</code> 的呢，你可以很肯定的知道打印的是 <code>value</code>。</p><ol><li>节省内存。Immutable.js 使用了结构共享，会尽量复用内存。没有被引用的对象会被垃圾回收。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Map&#125; from &apos;immutable&apos;;</span><br><span class="line">let a = Map(&#123;</span><br><span class="line">  select: &apos;users&apos;,</span><br><span class="line">  filter: Map(&#123; name: &apos;Cam&apos; &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">let b = a.set(&apos;select&apos;, &apos;people&apos;);</span><br><span class="line"></span><br><span class="line">a === b; // false</span><br><span class="line"></span><br><span class="line">a.get(&apos;filter&apos;) === b.get(&apos;filter&apos;); // true</span><br></pre></td></tr></table></figure></li></ol><p>上面 a 和 b 共享了没有变化的 <code>filter</code> 节点。</p><ol><li>可回溯，时间旅行这些功能做起来小菜一碟。因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。</li></ol><hr><h3 id="Redux和Flux的区别"><a href="#Redux和Flux的区别" class="headerlink" title="Redux和Flux的区别"></a>Redux和Flux的区别</h3><ol><li>Redux只有一个store，且在reducer中执行更新逻辑；Flux有多个store且在store中执行更新逻辑。</li><li>Redux没有dispatcher，它是通过reducer来处理数据（reducer是一个纯函数，(prevState,action)=&gt;newState）。在Redux中可能有多个reducer，单个reducer负责维护应用整体state树中的某一部分，多个reducer通过combineReducers合成一个根reducer来维护整个state。</li><li>Redux概念太超前了，一步到位强制把副作用隔离掉了，但自己又没有深入解决带来的代码冗余问题。</li></ol><hr><h3 id="Redux优缺点"><a href="#Redux优缺点" class="headerlink" title="Redux优缺点"></a>Redux优缺点</h3><p>优点：</p><ol><li>纯函数的开发模式，无副作用。</li><li>单向数据流流动自然清晰，任何的dispatch都会通知到reducer来处理，增强更新粒度可控性。</li><li>利用中间件的模式来解决异步带来的副作用问题。</li><li>可时间回溯。为了解决阻碍回溯的“对象引用”机制，将 immutable应用到了前端。这下所有状态都不会被修改，基于此的redux-dev-tools提高了开发体验。</li></ol><p>缺点：</p><ol><li>代码书写啰嗦，造成代码冗余。</li><li>函数式编程对于习惯于面向对象思维的开发人员比较难接受。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redux&quot;&gt;&lt;a href=&quot;#Redux&quot; class=&quot;headerlink&quot; title=&quot;Redux&quot;&gt;&lt;/a&gt;Redux&lt;/h2&gt;&lt;p&gt;Redux 是 JavaScript 状态容器，提供可预测化的状态管理，属于Flux模式的具体实现之一，核心理念是在
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="前端数据流" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端数据流管理方案（三）——Vuex篇</title>
    <link href="http://yoursite.com/2018/05/05/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Vuex%E7%AF%87/"/>
    <id>http://yoursite.com/2018/05/05/浅谈前端数据流管理方案（三）——Vuex篇/</id>
    <published>2018-05-04T16:00:00.000Z</published>
    <updated>2018-09-11T05:59:35.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>先来看看官网对Vuex的描述：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>Vuex也是属于Flux流派的一种，通过单向数据流的方式来管理数据。但是它是专门为Vue定制的数据管理框架，主要是为了配合Vue本身的响应式机制，对框架的依赖性更高。</p><h3 id="Vuex各部分职能："><a href="#Vuex各部分职能：" class="headerlink" title="Vuex各部分职能："></a>Vuex各部分职能：</h3><ul><li>Store：存储数据和管理数据方法的仓库。</li><li>State：状态数据。</li><li>Getters：computed过后的状态，对State进行的二次包装。</li><li>Mutations：所有状态修改都是通过它来提交，必须是同步的。</li><li>Actions：允许异步执行，其本质是在回调中提交Mutations。</li><li>Modules：为解决Store过大，分化Store到每个Module中。</li></ul><hr><h3 id="Vuex流程："><a href="#Vuex流程：" class="headerlink" title="Vuex流程："></a>Vuex流程：</h3><p>Vuex流程示意图：<br><img src="https://vuex.vuejs.org/zh-cn/images/vuex.png" alt="Vuex流程示意图"></p><ol><li>在Vue组件中手动触发Action，Action中执行异步操作，并在回调中commit到mutation。（如果是同步操作，你可以直接在Vue组件中直接触发mutation）。</li><li>mutation同步修改state。</li><li>state修改完成之后，通知Vue组件进行rerender。这样一来，一次数据的单向流动就完成了。</li></ol><hr><h3 id="与同门师兄Redux的区别："><a href="#与同门师兄Redux的区别：" class="headerlink" title="与同门师兄Redux的区别："></a>与同门师兄Redux的区别：</h3><ol><li>Vuex是一个针对Vue特化的Flux，能够很好地去配合Vue自身的响应式机制。</li><li>Vuex没有强制immutability，并不像Redux的纯函数那么严格，你可以在mutation中直接修改state，或是引发一些副作用，这一点比较宽松。这么做的原因和 Vue 的运行机制有关系，Vue 基于 ES5 中的 getter/setter 来实现视图和数据的双向绑定，因此 Vuex 中 state 的变更可以通过 setter 通知到视图中对应的指令来实现视图更新。</li><li>在异步流程处理这方面，Vuex通过action和mutation之间的配合来实现：action可以是异步的（下面的源码解析也会说到action在Vuex内部会被包装成Promise），然后异步处理完后，commit给mutation必须是同步的。而Redux通过引入中间件（如redux-thunk 、redux-saga等等）来处理异步流程。</li></ol><h4 id="ps：为什么mutation中必须是同步提交的？"><a href="#ps：为什么mutation中必须是同步提交的？" class="headerlink" title="ps：为什么mutation中必须是同步提交的？"></a>ps：为什么mutation中必须是同步提交的？</h4><p>尤大原话：同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。</p><p>因此mutations和状态树正确的对应关系是实现时间旅行的关键，异步的话不能保证这点。</p><hr><h3 id="Vuex源码解读："><a href="#Vuex源码解读：" class="headerlink" title="Vuex源码解读："></a>Vuex源码解读：</h3><p>Vuex的源码不多，适合阅读学习~</p><h4 id="1-入口文件index-js"><a href="#1-入口文件index-js" class="headerlink" title="1.入口文件index.js"></a>1.入口文件index.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Store, install &#125; from &apos;./store&apos;</span><br><span class="line">import &#123; mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers &#125; from &apos;./helpers&apos;</span><br><span class="line"></span><br><span class="line">//导出store类，install方法，版本，一些操作state,mutations,actions,getters的语法糖</span><br><span class="line">export default &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install,</span><br><span class="line">  version: &apos;__VERSION__&apos;,</span><br><span class="line">  mapState,</span><br><span class="line">  mapMutations,</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions,</span><br><span class="line">  createNamespacedHelpers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入口文件的主要功能就是把个模块部分实现的方法、属性等等聚合起来，然后再提供一个出口供外部来调用。</p><h4 id="2-将store注入Vue实例"><a href="#2-将store注入Vue实例" class="headerlink" title="2.将store注入Vue实例"></a>2.将store注入Vue实例</h4><p>接下来看看Vuex是如何把store注入到每个Vue实例中，使得每个Vue实例拿到同一份store。这里的实现逻辑主要是在mixin.js文件中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Vue2.x和Vue1.x的注入方式有点不同</span><br><span class="line">const version = Number(Vue.version.split(&apos;.&apos;)[0])</span><br><span class="line">if (version &gt;= 2) &#123;</span><br><span class="line">  Vue.mixin(&#123; beforeCreate: vuexInit &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  const _init = Vue.prototype._init</span><br><span class="line">  Vue.prototype._init = function (options = &#123;&#125;) &#123;</span><br><span class="line">    options.init = options.init</span><br><span class="line">      ? [vuexInit].concat(options.init)</span><br><span class="line">      : vuexInit</span><br><span class="line">    _init.call(this, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//注入实现逻辑</span><br><span class="line">function vuexInit () &#123;</span><br><span class="line">  const options = this.$options</span><br><span class="line">  // store injection</span><br><span class="line">  if (options.store) &#123;</span><br><span class="line">    this.$store = typeof options.store === &apos;function&apos;</span><br><span class="line">      ? options.store()</span><br><span class="line">      : options.store</span><br><span class="line">  &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">    this.$store = options.parent.$store</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里只说下Vue2.x的注入流程：调用Vue的mixin方法把vuexInit方法混入到每个组件的beforeCreate钩子中。在vuexInit中通过vm.$options判断有没有store，有就说明是root组件（因为在vue初始化root组件的时候会注入），没有的话就从它的parent那里获取。这样一来，所有组件都能拿到同一份store了。</p><h4 id="3-重头戏store-js"><a href="#3-重头戏store-js" class="headerlink" title="3.重头戏store.js"></a>3.重头戏store.js</h4><p>这个文件是Vuex的主文件，定义了Vuex的运行逻辑、方法等等。先说说它初始化的一些东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//定义的一些内部变量</span><br><span class="line">//判断是否通过mutation来修改state，严格模式实现的主要参数（下文会说怎么实现严格模式）</span><br><span class="line">this._committing = false</span><br><span class="line">//存放actions</span><br><span class="line">this._actions = Object.create(null)</span><br><span class="line">//存放mutations</span><br><span class="line">this._mutations = Object.create(null)</span><br><span class="line">//存放getters</span><br><span class="line">this._wrappedGetters = Object.create(null)</span><br><span class="line">this._modules = new ModuleCollection(options)</span><br><span class="line">this._modulesNamespaceMap = Object.create(null)</span><br><span class="line">//存放订阅者</span><br><span class="line">this._subscribers = []</span><br><span class="line">//借用这个vue实例来使用它的watch方法</span><br><span class="line">this._watcherVM = new Vue()</span><br></pre></td></tr></table></figure></p><p>两个主要方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装各个module，给不同的module加上不同的命名空间，避免命名污染，遍历注册mutation、action、getter、子module。</span><br><span class="line">installModule(this, state, [], this._modules.root)</span><br><span class="line"></span><br><span class="line">//通过vm重设store，利用vue的响应式使得vuex的数据也变得响应式</span><br><span class="line">resetStoreVM(this, state)</span><br></pre></td></tr></table></figure></p><h4 id="4-着重说说resetStoreVM方法"><a href="#4-着重说说resetStoreVM方法" class="headerlink" title="4.着重说说resetStoreVM方法"></a>4.着重说说resetStoreVM方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function resetStoreVM (store, state, hot) &#123;</span><br><span class="line">  const oldVm = store._vm </span><br><span class="line"></span><br><span class="line">  store.getters = &#123;&#125;</span><br><span class="line">  const wrappedGetters = store._wrappedGetters</span><br><span class="line">  const computed = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  /* 通过Object.defineProperty方法为每一个getter方法设置它的get，比如获取this.$store.getters.age的时候获取的是store._vm.age，这赋值到Vue对象的computed属性上的，利用了computed本身就有的响应式，从而实现了响应式 */</span><br><span class="line">  forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">    computed[key] = () =&gt; fn(store)</span><br><span class="line">    Object.defineProperty(store.getters, key, &#123;</span><br><span class="line">      get: () =&gt; store._vm[key],</span><br><span class="line">      enumerable: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  const silent = Vue.config.silent</span><br><span class="line">  </span><br><span class="line">  /* 这里新建一个vue实例，运用Vue内部的响应式实现注册state以及computed（把state赋值到vue实例的data上，把getter赋值到vue实例的computed上）*/</span><br><span class="line">  store._vm = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      $$state: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Vue.config.silent = silent</span><br><span class="line"></span><br><span class="line">  //严格模式是否启用</span><br><span class="line">  if (store.strict) &#123;</span><br><span class="line">    enableStrictMode(store)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (oldVm) &#123;</span><br><span class="line">    if (hot) &#123;</span><br><span class="line">      store._withCommit(() =&gt; &#123;</span><br><span class="line">        oldVm._data.$$state = null</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    Vue.nextTick(() =&gt; oldVm.$destroy())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-commit方法"><a href="#5-commit方法" class="headerlink" title="5.commit方法"></a>5.commit方法</h4><p>Mutation的commit方法用于同步修改state<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">commit (_type, _payload, _options) &#123;</span><br><span class="line">   const &#123;</span><br><span class="line">     type,</span><br><span class="line">     payload,</span><br><span class="line">     options</span><br><span class="line">   &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line"></span><br><span class="line">   const mutation = &#123; type, payload &#125;</span><br><span class="line">   </span><br><span class="line">   //找到Mutations中对应的type的mutation</span><br><span class="line">   const entry = this._mutations[type]</span><br><span class="line">   if (!entry) &#123;</span><br><span class="line">     if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">       console.error(`[vuex] unknown mutation type: $&#123;type&#125;`)</span><br><span class="line">     &#125;</span><br><span class="line">     return</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //遍历执行刚才拿到的mutations</span><br><span class="line">   /* ps：这个_withCommit方法会先保存当前的_committing值，然后把它修改为true，再去执行回调，最后把_committing复原。这也是下文提到的严格模式的控制实现 */</span><br><span class="line">   this._withCommit(() =&gt; &#123;</span><br><span class="line">     entry.forEach(function commitIterator (handler) &#123;</span><br><span class="line">       handler(payload)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   //通知所有的订阅者</span><br><span class="line">   this._subscribers.forEach(sub =&gt; sub(mutation, this.state))</span><br><span class="line"></span><br><span class="line">   if (</span><br><span class="line">     process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">     options &amp;&amp; options.silent</span><br><span class="line">   ) &#123;</span><br><span class="line">     console.warn(</span><br><span class="line">       `[vuex] mutation type: $&#123;type&#125;. Silent option has been removed. ` +</span><br><span class="line">       &apos;Use the filter functionality in the vue-devtools&apos;</span><br><span class="line">     )</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>commit方法会根据传进来的type找到对应的mutation去执行，执行完之后，又会通知所有订阅者有新的state。</p><p>这个subscribe一般在devtool那里用到，如果是渲染更新state的话直接利用vue自身的响应式就好，不用这个subscribe。</p><p>subscribe可以协助devtoolPlugin实现时间旅行。因为dev模式下所有的state change都会被记录下来，时间旅行 功能其实就是将当前的state替换为记录中某个时刻的state状态，利用 store.replaceState(targetState) 方法将执行this._vm.state = state 实现。</p><h4 id="6-dispatch方法"><a href="#6-dispatch方法" class="headerlink" title="6.dispatch方法"></a>6.dispatch方法</h4><p>处理action的dispatch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch (_type, _payload) &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    type,</span><br><span class="line">    payload</span><br><span class="line">  &#125; = unifyObjectStyle(_type, _payload)</span><br><span class="line"></span><br><span class="line">  const entry = this._actions[type]</span><br><span class="line">  if (!entry) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      console.error(`[vuex] unknown action type: $&#123;type&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return entry.length &gt; 1</span><br><span class="line">    ? Promise.all(entry.map(handler =&gt; handler(payload)))</span><br><span class="line">    : entry[0](https://cdn.example.com/payload?m=webp&q=80)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过type拿到所有的actions，如果actions大于1，那就把它们包装在Promise.all里面去并行执行，等于1就直接执行。那么，为什么这里可以把actions放在Promise.all里面呢？Promise.all里不是只能放Promise对象吗？</p><p>对，每个action都是一个Promise，这是通过registerAction来注册实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function registerAction (store, type, handler, local) &#123;</span><br><span class="line">  const entry = store._actions[type] || (store._actions[type] = [])</span><br><span class="line">  entry.push(function wrappedActionHandler (payload, cb) &#123;</span><br><span class="line">    let res = handler.call(store, &#123;</span><br><span class="line">      dispatch: local.dispatch,</span><br><span class="line">      commit: local.commit,</span><br><span class="line">      getters: local.getters,</span><br><span class="line">      state: local.state,</span><br><span class="line">      rootGetters: store.getters,</span><br><span class="line">      rootState: store.state</span><br><span class="line">    &#125;, payload, cb)</span><br><span class="line">    </span><br><span class="line">    //它就会把每一个action转化为Promise对象</span><br><span class="line">    if (!isPromise(res)) &#123;</span><br><span class="line">      res = Promise.resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    if (store._devtoolHook) &#123;</span><br><span class="line">      return res.catch(err =&gt; &#123;</span><br><span class="line">        store._devtoolHook.emit(&apos;vuex:error&apos;, err)</span><br><span class="line">        throw err</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7-严格模式的实现"><a href="#7-严格模式的实现" class="headerlink" title="7.严格模式的实现"></a>7.严格模式的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//启用严格模式</span><br><span class="line">function enableStrictMode (store) &#123;</span><br><span class="line">  store._vm.$watch(function () &#123; return this._data.$$state &#125;, () =&gt; &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123; deep: true, sync: true &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文也说到，store中有个_committing属性，是用来标志是否正在通过mutation来修改state，如果是的话，它的值为true，否则为false。启用严格模式后，严格模式中会通过vue的$watch方法来检测state的变化，如果有变化，那就判断_committing属性，_committing为false的话就抛出异常。</p><h4 id="8-语法糖：mapState-mapMutations-mapActions-mapGetters"><a href="#8-语法糖：mapState-mapMutations-mapActions-mapGetters" class="headerlink" title="8.语法糖：mapState,mapMutations,mapActions,mapGetters"></a>8.语法糖：mapState,mapMutations,mapActions,mapGetters</h4><p>mapState,mapMutations,mapActions,mapGetters它们都是一些提供给开发者操作store的一些语法糖函数。<br>它们几个在实现上也比较类似，主要流程是先将state,mutations等等这些转化成[{key, val},{key, val},{key, val}…]的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function normalizeMap (map) &#123;</span><br><span class="line">  return Array.isArray(map)</span><br><span class="line">    ? map.map(key =&gt; (&#123; key, val: key &#125;))</span><br><span class="line">    : Object.keys(map).map(key =&gt; (&#123; key, val: map[key] &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后遍历这个数据结构，把每一项都包装成一个函数。<br>mapState和mapGetters是把它们的值作为该函数的返回值返回出去，这样在vue示例中的computed就能拿到它们的值了。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    ...mapState([</span><br><span class="line">        &apos;name&apos;</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br><span class="line">//就会转化成</span><br><span class="line">computed:&#123;</span><br><span class="line">    name () &#123;</span><br><span class="line">      return this.$store.state.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而mapMutations和mapActions分别是返回调用它们的commit和dispatch方法，这样在vue示例中的methods也就存在它们的方法了。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    ...mapMutation([</span><br><span class="line">        &apos;addName&apos;</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br><span class="line">//就会转化成</span><br><span class="line">methods:&#123;</span><br><span class="line">    addName(...args)&#123;</span><br><span class="line">        return this.$store.commit.apply(this.$store,[&apos;addName&apos;].concat(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="9-Vuex的错误处理方式"><a href="#9-Vuex的错误处理方式" class="headerlink" title="9.Vuex的错误处理方式"></a>9.Vuex的错误处理方式</h4><p>Vuex的错误处理是通过自定义函数assert实现，内容很简单，值得一学<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//假设现在要判断当前环境支不支持Promise</span><br><span class="line">assert(typeof Promise!==&apos;undefined&apos;,&apos;当前环境不支持Promise&apos;);</span><br><span class="line"></span><br><span class="line">function assert(condition,msg)&#123;</span><br><span class="line">    if(!condition) throw new Error(`[vuex] $&#123;msg&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h2&gt;&lt;p&gt;先来看看官网对Vuex的描述：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="前端数据流" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
      <category term="Vuex" scheme="http://yoursite.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端数据流管理方案（二）——MobX篇</title>
    <link href="http://yoursite.com/2018/05/03/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94MobX%E7%AF%87/"/>
    <id>http://yoursite.com/2018/05/03/浅谈前端数据流管理方案（二）——MobX篇/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-10-24T07:02:26.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MobX"><a href="#MobX" class="headerlink" title="MobX"></a>MobX</h2><p>Mobx专注于解决数据级别的响应，它不关系数据的来源方式，只要一个对象中的属性、一个基本类型变量发生了变化，对这些数据的订阅就会自动执行。使用Mobx管理状态时，当我们更新观察对象的状态后，由观察对象的改变带来的界面重渲染、数据序列化等一系列副作用，Mobx会自动帮我们完成。</p><hr><h3 id="Mobx的主要概念"><a href="#Mobx的主要概念" class="headerlink" title="Mobx的主要概念"></a>Mobx的主要概念</h3><ol><li><p>Actions: 改变state的操作。</p></li><li><p>ObservableState:应用的可被观察的数据状态。</p></li><li><p>Computed: 从state中通过纯函数的操作衍生出的值，state变化它也会跟着变化。</p></li><li><p>Reactions：需要对state变化动态作出反应的东西，它包含不同的概念，基于被观察数据的更新导致某个计算值，或者是发送网络请求以及更新视图等，都属于响应的范畴，这也是响应式编程在 JavaScript 中的一个应用。</p></li><li><p>Autorun。依赖收集，监听触发，autorun 背后由 reaction 实现。由于 autorun 与 view 的 render 函数很像，我们在 render 函数初始化执行时，使其包裹在 autorun 环境中，第 2 次 render 开始遍剥离外层的 autorun，保证只绑定一遍数据。这样 view 层在原本 props 更新机制的基础上，增加了 autorun 的功能，实现修改任何数据自动更新对应 view 的效果。（ps:使用autoRun实现Mobx-react非常简单，核心思想是将组件外面包上autoRun，这样代码中用到的所有属性都会像上面Demo一样，与当前组件绑定，一旦任何值发生了修改，就直接forceUpdate，而且精确命中，效率最高。）</p></li></ol><hr><h3 id="Mobx流程"><a href="#Mobx流程" class="headerlink" title="Mobx流程"></a>Mobx流程</h3><p>一图胜千言~<br><img src="https://wx3.sinaimg.cn/mw690/768c39d5gy1fqvrrvmevqj21330dfq56.jpg" alt="Mobx流程示意图"><br>可以把 observable 理解为信号源，每当信号变化时，函数流会自动执行，并输出结果，最终会使视图刷新。这就是数据驱动视图。每当我们的可观察对象变化时，都会自动触发数据源的 dispatch，而且各视图也是自动订阅各数据源的，这就是依赖追踪。</p><hr><h3 id="Mobx的优缺点"><a href="#Mobx的优缺点" class="headerlink" title="Mobx的优缺点"></a>Mobx的优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>使用起来十分顺手，降低开发难度。十分“智能”，当我们更新观察对象的状态后，由观察对象的改变带来的界面重渲染、数据序列化等一系列副作用，Mobx会自动帮我们完成。</li><li>面向对象的使用方法，较为符合我们平时开发的逻辑。</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><p>无副作用隔离，非严格模式下可以对observable直接修改，这样容易造成 store 被随意修改。在项目规模比较大的时候，像 Vuex 和 Redux 一样对修改数据的入口进行限制可以提高安全性。因此如果不规范Mobx使用的话将会导致数据流变化混乱问题。</p></li><li><p>在收集依赖时，Mobx会把autorun执行一遍来触发里面observable的getter从而收集依赖。但是万一你写出了以下的代码，Mobx是收集不到你想要收集的依赖的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let val = 1;</span><br><span class="line">let ob = observable(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">//在这里我们没有访问 ob.a ，而只是访问了 ob，autorun 没有收集到 ob.a 的依赖，所以当改变ob.a的时候也不会触发下面这个函数。</span><br><span class="line">let test1 = autorun(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;log ob.a&apos;, ob);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//在这里有一个返回值为false的判断语句使得判断语句里面的内容没有执行，从而也收集不到依赖</span><br><span class="line">let test2 = autorun(() =&gt; &#123;</span><br><span class="line">    if (val === 2) &#123;</span><br><span class="line">        console.log(&apos;判断 x&apos;, ob.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>observable跟普通的plainObject傻傻分不清楚，observable跟plainObject外貌上一摸一样，有时可能会误会了observable的本质</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const x = observable([1, 2, 3])</span><br><span class="line">x.map(x =&gt; x + 1) // 我们可以像普通的数组一样操作 observable array</span><br><span class="line"></span><br><span class="line">//不会被执行，因为 Array.isArray(observable([1, 2, 3])) === false</span><br><span class="line">if (Array.isArray(x)) &#123;</span><br><span class="line">  x.push(4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="Mobx与Redux的区别"><a href="#Mobx与Redux的区别" class="headerlink" title="Mobx与Redux的区别"></a>Mobx与Redux的区别</h3><ol><li>从数据管理模式的差别上看，Mobx是基于双向绑定的响应式的实现，而redux是基于flux的单向数据流的实现。</li><li>从开发上来看是和面向对象和函数式编程的区别。但是前端开发需要经常与副作用打交道，所以前端开发很难与完美的函数式编程相结合。</li><li>redux的state是只读的，产生新的state的过程是pure的；Mobx的state可读可写，并且action并不是必须的，可以直接赋值改变，这也看出了Mobx改变数据的impure。</li><li>在可预测性、可维护性上看，redux得益于它的清晰的单向数据流和纯函数的实现，在这方面优于Mobx。</li><li>redux是单一数据源；而Mobx是多个store。</li><li>redux中的store是普通的js对象结构，而Mobx中的会对其进行observable化，从而实现响应式。</li><li>从代码量上看，Mobx能少写很多代码，而redux要通过action,reducer等等的编写才能实现整个流程。</li></ol><hr><h3 id="Mobx与Rxjs"><a href="#Mobx与Rxjs" class="headerlink" title="Mobx与Rxjs"></a>Mobx与Rxjs</h3><p>它们两者都是响应式的，但又有所不同。<br>Mobx的observable是从store到view的数据变化的autorun响应。<br>Rxjs的observable是从数据源到store的数据源派发流的过程。</p><p>Mobx和Rxjs可以是一种互补的关系，Rxjs响应数据的来源，Mobx响应数据的变化。<br>例如:如果想在更新state之前对用户的输入操作节流，大致工作流是：</p><p>DOM events -&gt; RxJS -&gt; Update state -&gt; MobX -&gt; Update UI<br>//Rxjs仅用来隔离副作用与数据处理，Mobx用来响应数据的变化，拥有修改 store 的能力，并且精准更新使用的 View。</p><hr><h3 id="Mobx基本原理"><a href="#Mobx基本原理" class="headerlink" title="Mobx基本原理"></a>Mobx基本原理</h3><p>那么Mobx是怎么做到这个响应式双向绑定的呢？</p><p>我们通过定义可观察对象，依赖收集，触发更新这个顺序来说说它的基本原理~</p><h4 id="1-定义可观察对象"><a href="#1-定义可观察对象" class="headerlink" title="1.定义可观察对象"></a>1.定义可观察对象</h4><p>我们平时是这样来定义一个可观察对象的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class newsStore&#123;</span><br><span class="line">    @observable hotNews=[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在这里mobx用了修饰器的形式来定义，实质上，它是这样的：</span><br><span class="line">function newsStore() &#123;</span><br><span class="line">    extendObservable(this, &#123;</span><br><span class="line">        hotNews: []</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到这里用到了<code>extendObservable</code>这个方法来让目标对象可观察化，在这个方法中：</p><ol><li>给<code>target</code>(当前的类，例子中的<code>newsStore</code>)设置一个<code>$mobx</code>属性作为它的代理对象，<code>$mobx</code>有一个属性<code>values</code>属性，就是用来存储可观察属性的。因此对其的可观察化不会对该对象本身产生影响，对其的所有操作都将通过其 <code>$mobx</code> 属性代理。</li><li>然后将每个设置了<code>@observable</code>的属性值转化为一个可观察的对象，并存储在 <code>$mobx.values[propName]</code> 中，例如上面的例子，就是把<code>hotNews</code>放在了<code>target.$mobx.values[hotNews]</code>中。</li><li>遍历可观察属性，给每个<code>observable</code>重写<code>get</code>和<code>set</code>来将外界对目标对象的读写操作代理到其代理对象。get和set分别会调用<code>reportObserved</code>和<code>reportChanged</code>进行相应操作。<br><img src="https://wx4.sinaimg.cn/mw690/768c39d5gy1fqvwcn2y8wj215q0dpmyk.jpg" alt="$mobx"><br>图片来源：阿里云中台前端/全栈团队专栏，侵删</li></ol><h4 id="2-依赖收集"><a href="#2-依赖收集" class="headerlink" title="2.依赖收集"></a>2.依赖收集</h4><p>依赖收集主要是在<code>autorun</code>中进行的，它会把参数包装成一个观察者，先执行一次，当执行过程中遇到可观察属性，就会触发到该可观察属性的getter，这个getter就会调用它的<code>reportObserved</code>方法,这个方法就会拿到全局状态下当前的<code>Derivation</code>（也就是当前这个autorun的Reaction），然后把这个<code>observableValue</code>放到当前<code>Derivation</code>的<code>newObserving</code>数组中，从而使得该<code>Reaction</code>中就绑定着它所观察的所有的<code>observableValue</code>。<br>然后，遍历每个<code>observableValue</code>，通过<code>addObserver</code>的方法将依赖该<code>observableValue</code>的<code>reaction</code>添加到它的<code>observers</code>属性中。<br>这样一来，在<code>Reaction</code>中储存着它依赖的<code>observableValue</code>，在每个<code>observableValue</code>中的<code>observers</code>属性中也储存着依赖它的<code>Reaction</code>。</p><h4 id="3-触发更新"><a href="#3-触发更新" class="headerlink" title="3.触发更新"></a>3.触发更新</h4><p>当<code>observableValue</code>发生改变的时候，就会出发到它的<code>setter</code>。在这个<code>setter</code>中会遍历该<code>observable</code>的<code>observers</code>数组，把它们都标志为过期状态。当这个<code>reaction</code>处于过期状态的时候，就会把这个<code>reaction</code>放进<code>pendingReactions</code>（一个全局的数组）中，然后依次调用它们的<code>runReaction</code>方法（这里用到了事务的方式来进行批处理）。<br>然后在<code>runReaction</code>的流程中，就会运行这些<code>reaction</code>，从而触发了所有被观察的 <code>Observable</code> 的 <code>reportObserved</code> 方法，并更新了当前<code>Derivation</code>的<code>newObserving</code>数组，也即重新收集了依赖，更新了依赖。</p><hr><h3 id="Nobx——迷你版的Mobx"><a href="#Nobx——迷你版的Mobx" class="headerlink" title="Nobx——迷你版的Mobx"></a>Nobx——迷你版的Mobx</h3><p>最后贴一下本人通过学习Mobx原理来实现的迷你版Mobx(●’◡’●)</p><p><a href="https://github.com/cmh1996/nobx" target="_blank" rel="noopener">https://github.com/cmh1996/nobx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MobX&quot;&gt;&lt;a href=&quot;#MobX&quot; class=&quot;headerlink&quot; title=&quot;MobX&quot;&gt;&lt;/a&gt;MobX&lt;/h2&gt;&lt;p&gt;Mobx专注于解决数据级别的响应，它不关系数据的来源方式，只要一个对象中的属性、一个基本类型变量发生了变化，对这些数据的订阅
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="前端数据流" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
      <category term="MobX" scheme="http://yoursite.com/tags/MobX/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端数据流管理方案（一）——Flux篇</title>
    <link href="http://yoursite.com/2018/04/22/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Flux%E7%AF%87/"/>
    <id>http://yoursite.com/2018/04/22/浅谈前端数据流管理方案（一）——Flux篇/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-05-10T12:36:01.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端主流的数据流管理现阶段已衍生出三种管理模式，分别是：</p><ul><li>单向数据流派Flux，代表库有Redux、Vuex。</li><li>响应式的双向绑定流派，代表库有MobX。</li><li>响应式的observable流派，代表库有RxJs。</li></ul><p>整个系列一共有五篇文章，主要介绍了上述三个流派在前端数据流管理上的模式阐述、库实现，并对它们三者进行了比较。本系列旨在加深对前端数据流的管理的认识，希望对你我都有所帮助(●’◡’●)。</p><h2 id="Flux模式"><a href="#Flux模式" class="headerlink" title="Flux模式"></a>Flux模式</h2><p>Flux是什么？Flux不是某一个具体库的名称，它是一种前端数据流的管理模式，核心是单向数据流，近年来诞生的很多js库就是这种思想的实现，例如Redux,Vuex等等。它用于构建客户端 Web 应用，规范数据在 Web 应用中的流动方式。</p><h3 id="Flux各部分职能："><a href="#Flux各部分职能：" class="headerlink" title="Flux各部分职能："></a>Flux各部分职能：</h3><ul><li>Action：这一块有个生成器叫Action Creator，它负责把type（自定义的用于标志特定action常量）和payload（负载的信息）封装成一个action，创建好之后就会把它传递给Dispatcher。</li><li>Dispatcher：它是一个负责派发action的派发器，它保存着包含所有的store的一个列表，接收到action之后再传给所有store，也就是说store并不是订阅某些action，而是聆听每一个action，从中过滤筛选出它关心的来做出反应。</li><li>Store：保存着整个应用的状态。它从dispatcher中接收到action后，使用一个switch语句判断action的类型，决定是否对这个action作出响应，如果store关心这个action，就会根据action找出需要变化的部分，更新state。只要state做出了变化，就会触发change事件，通知视图状态变化。</li><li>View：将state渲染给用户，并接受用户的输入,操作。view不能直接修改应用状态，只能触发action。View也分为Control-View和各个子View（类似于react中的智能组件和木偶组件），对于非Control-View的子View来说，所有数据都来源于Control-View传来的props。</li></ul><hr><h3 id="Flux流程："><a href="#Flux流程：" class="headerlink" title="Flux流程："></a>Flux流程：</h3><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png" alt="Flux流程示意图"><br>一、初始化</p><ol><li>创建store，store告诉dispatcher只要有action产生就告诉它。</li><li>Control-View从store获取到初始的state，并传递给各个子view去渲染。</li><li>Control-View让store在state变化更新的时候告诉它。</li></ol><p>二、触发数据流</p><ol><li>Control-View向Action-Creator触发一个action。</li><li>Action Creator做好action后将其发送给dispatcher。</li><li>dispatcher按顺序将action传给所有store，store自行对actionn进行判断，看是否对它作出响应。</li><li>store根据接受的action，对state进行更新，更新完毕后就通知订阅了该store的Control-View。</li><li>Control-View收到通知后，就会向store请求更新了的state。</li><li>Control-View获得了新的state之后，让子view渲染新的state。</li></ol><hr><h3 id="Flux优缺点："><a href="#Flux优缺点：" class="headerlink" title="Flux优缺点："></a>Flux优缺点：</h3><p>优点：</p><ol><li>视图组件变薄，只包含触发action和渲染数据这两个职责。</li><li>view对于数据层的只读使得数据是可预测的。</li><li>要想知道一个store可能的状态变化，只要看它注册了哪些actions回调即可。</li><li>每次有状态变化都会从dispatcher流过，这让所有状态变化都留下了一笔记录，有利于debug还有时间旅行。</li><li>dispatcher派发action是同步行为，这防止同一份数据有多个地方同时在写，使得数据变乱。</li></ol><p>缺点：</p><ol><li>冗余代码太多，出现很多类似的样板代码。每个应用中都要手动创建dispatcher实例，还有就是一个应用包含多个store来管理数据。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前端主流的数据流管理现阶段已衍生出三种管理模式，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单向数据流派Flux，代表库有Redux、Vuex。&lt;/
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Flux" scheme="http://yoursite.com/tags/Flux/"/>
    
      <category term="前端数据流" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>CSS世界学习笔记</title>
    <link href="http://yoursite.com/2018/04/02/css%E4%B8%96%E7%95%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/02/css世界学习笔记/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-09-25T02:53:19.783Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-盒子双重性"><a href="#1-盒子双重性" class="headerlink" title="1.盒子双重性"></a>1.盒子双重性</h3><p>按照 display 的属性值不同，值为 block 的元素的盒子实际由外在的“块级盒子” 和内在的“块级容器盒子”组成，值为 inline-block 的元素则由外在的“内联盒子”和内 在的“块级容器盒子”组成，值为 inline 的元素则内外均是“内联盒子”。实际上，如果遵循这种理解，display:block 应该脑补成 display:block-block，display:table 应该脑补成 display:block-table，我们平时的写法实际上是一种简写。<br>下面问题来了：元素都有内外两个盒子， 我们平常设置的 width/height 属性是作用在哪个盒子上的？这个问题也是很简单的，因为在解释内外盒子的时候就已经提到过了：是内在盒子，也就 是“容器盒子”。</p><h3 id="2-默认宽度width-auto的表现特性（即不设置宽度的表现）"><a href="#2-默认宽度width-auto的表现特性（即不设置宽度的表现）" class="headerlink" title="2.默认宽度width:auto的表现特性（即不设置宽度的表现）"></a>2.默认宽度width:auto的表现特性（即不设置宽度的表现）</h3><p><strong>（1）</strong>充分利用可用空间。比方说块级block元素的宽度默认是 100%于父级容器的。</p><p><strong>（2）</strong>收缩与包裹。典型代表就是浮动、绝对定位、inline-block 元素或 table 元素，意为“收缩到合适”，有那么点儿意思，但不够形象，我一直把这种现 象称为“包裹性”。元素尺寸由内部元素决定，但永远小于“包含块”容器的 尺寸。因此，对于一个元素，如果其 display 属性值是 inline-block，那么即使其里面内容 再多，只要是正常文本，宽度也不会超过容器。<br>包裹性例子：<a href="http://demo.cssworld.cn/3/2-5.php" target="_blank" rel="noopener">http://demo.cssworld.cn/3/2-5.php</a></p><p><strong>（3）</strong>收缩到最小。这个最容易出现在 table-layout 为 auto 的表格中。</p><p><strong>（4）</strong>超出容器限制。除非有明确的 width 相关设置，否则上面 3 种情况尺寸都不会主动 超过父级容器宽度的，但是存在一些特殊情况。例如，内容很长的连续的英文和数字，或者内联 元素被设置了 white-space:nowrap。</p><h3 id="3-min-width和max-width"><a href="#3-min-width和max-width" class="headerlink" title="3.min-width和max-width"></a>3.min-width和max-width</h3><p>min-width初始值为auto，max-width初始值为none。<br>max-width：<br><img src="/2018/04/02/css世界学习笔记/0.png" alt="css世界学习笔记"><br>上图答案是 256px。style、!important 通通靠边站！因为 max-width 会覆盖 width。<br>ps：如果元素height是auto不确定，那么可以巧用max-width实现“展开收起”效果：<br><img src="/2018/04/02/css世界学习笔记/1.png" alt="css世界学习笔记"><br>min-width：<br><img src="/2018/04/02/css世界学习笔记/2.png" alt="css世界学习笔记"><br>上图中min-width 活下来，max-width 被忽略， 于是，.container 元素表现为至少 1400 像素宽。</p><h3 id="4-幽灵空白节点"><a href="#4-幽灵空白节点" class="headerlink" title="4.幽灵空白节点"></a>4.幽灵空白节点</h3><p>“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在 HTML5 文档声明 中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这 个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样， 但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。<br><img src="/2018/04/02/css世界学习笔记/3.png" alt="css世界学习笔记"></p><h3 id="5-input-type-’button’-和button的区别"><a href="#5-input-type-’button’-和button的区别" class="headerlink" title="5.input[type=’button’]和button的区别"></a>5.input[type=’button’]和button的区别</h3><p>区别在什么地方？区别在于两种按钮默认的 white-space 值不一样，前者是 pre，后者是 normal，所表示出来的现象差异就是：当按钮文字足够多的时候，input按钮不会自动换行，button则会。</p><h3 id="6-margin-left和margin-right设为auto"><a href="#6-margin-left和margin-right设为auto" class="headerlink" title="6.margin-left和margin-right设为auto"></a>6.margin-left和margin-right设为auto</h3><p><img src="/2018/04/02/css世界学习笔记/4.png" alt="css世界学习笔记"><br>如果想让某个块状元素右对齐，脑子里不要就一个 float:right，很多时候，marginleft:auto 才是最佳的实践，浮动毕竟是个“小魔鬼”。我甚至可以这么说：margin 属性的 auto 计算就是为块级元素左中右对齐而设计的，和内联元素使用 text-align 控制左中右对 齐正好遥相呼应！ 居中对齐左右同时 auto 计算即可，CSS 如下：<br><img src="/2018/04/02/css世界学习笔记/5.png" alt="css世界学习笔记"></p><h3 id="7-尺寸单位ex了解一下"><a href="#7-尺寸单位ex了解一下" class="headerlink" title="7.尺寸单位ex了解一下"></a>7.尺寸单位ex了解一下</h3><p>ex 是 CSS 中的一个相对单位，指的是小写字母 x 的高度，没错，就是指 x-height。ex 是 CSS 中的一个相对单位，指的是小写字母 x 的高度，没错，就是指 x-height。<br>我们都知道，内联元素默认是基线对齐的，而基线就是 x 的底部，而 1ex 就是一个 x 的高 度。设想一下，假如图标高度就是 1ex，同时背景图片居中，岂不是图标和文字天然垂直居中， 而且完全不受字体和字号的影响？因为 ex 就是一个相对于字体和字号的单位。<br>现在，要让该图标和文字中间位置对齐，你会如 何实现？设定好尺寸，然后使用 vertical-align:middle？这 样虽然也有效果，但是，实际上啰嗦了，借助 ex 单位，我们直接 利用默认的 baseline 基线对齐就可以实现这个效果。<br><img src="/2018/04/02/css世界学习笔记/6.png" alt="css世界学习笔记"><br><img src="/2018/04/02/css世界学习笔记/7.png" alt="css世界学习笔记"></p><h3 id="8-多行文字垂直居中"><a href="#8-多行文字垂直居中" class="headerlink" title="8.多行文字垂直居中"></a>8.多行文字垂直居中</h3><p><img src="/2018/04/02/css世界学习笔记/8.png" alt="css世界学习笔记"><br><img src="/2018/04/02/css世界学习笔记/9.png" alt="css世界学习笔记"></p><h3 id="9-line-height的属性值"><a href="#9-line-height的属性值" class="headerlink" title="9.line-height的属性值"></a>9.line-height的属性值</h3><p><strong>1.数值</strong>，如 line-height:1.5，其最终的计算值是和当前 font-size 相乘后的值。 例如，假设我们此时的 font-size 大小为 14px，则 line-height 计算值是 1.5<em>14px=21px。<br><strong>2.百分比值</strong>，如 line-height:150%，其最终的计算值是和当前 font-size 相乘后 的值。例如，假设我们此时的 font-size 大小为 14px，则 line-height 计算值是 150%</em>14px=21px。<br><strong>3.长度值</strong>，也就是带单位的值，如 line-height:21px 或者 line-height:1.5em 等，此处 em 是一个相对于 font-size 的相对单位，因此，line-height:1.5em 最终的计算值也是和当前font-size相乘后的值。例如，假设我们此时的font-size 大小为 14px，则 line-height 计算值是 1.5*14px=21px。<br>乍一看，似乎 line-height:1.5、line-height:150%和 line-height:1.5em 这 3 种 用法是一模一样的，最终的行高大小都是和font-size计算值，但是，实际上，line-height:1.5 和另外两个有一点儿不同，那就是继承细节有所差别。如果使用数值作为 line-height 的属性值， 那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。<br><img src="/2018/04/02/css世界学习笔记/10.png" alt="css世界学习笔记"><br>如果我们做的是一个重图文内容展示的网页或者网站，如博客、论坛、 公众号之类的，那一定要使用数值作为单位，考虑到文章阅读的舒适度，line-height 值可 以设置在 1.6～1.8。</p><h3 id="10-word-break-break-all和word-wrap-break-word的区别"><a href="#10-word-break-break-all和word-wrap-break-word的区别" class="headerlink" title="10.word-break:break-all和word-wrap:break-word的区别"></a>10.word-break:break-all和word-wrap:break-word的区别</h3><p>word-break:break-all 的作用是所有的都换行，毫不留情，一点儿空 隙都不放过，而 word-wrap:break-word 则带有怜悯之心，如果这一行文字有可以换 行的点，如空格或 CJK（中文/日文/韩文）之类的，就不打英文单词或字符的主意了，在 这些换行点换行，至于对不对齐、好不好看则不关心，因此，很容易出现一片一片空白区域的情况。<br><img src="/2018/04/02/css世界学习笔记/11.png" alt="css世界学习笔记"></p><h3 id="11-隐藏元素的-background-image-到底加不加载呢？"><a href="#11-隐藏元素的-background-image-到底加不加载呢？" class="headerlink" title="11.隐藏元素的 background-image 到底加不加载呢？"></a>11.隐藏元素的 background-image 到底加不加载呢？</h3><p>想必这是一个很多人都感兴趣的问题。 根据我的测试，一个元素如果 display 计算值为 none，在 IE 浏览器下（IE8～IE11，更 高版本不确定）依然会发送图片请求，Firefox 浏览器不会，至于 Chrome 和 Safari 浏览器则似 乎更加智能一点：如果隐藏元素同时又设置了 background-image，则图片依然会去加载； 如果是父元素的 display 计算值为 none，则背景图不会请求，此时浏览器或许放心地认为这 个背景图暂时是不会使用的。</p><h3 id="12-outline"><a href="#12-outline" class="headerlink" title="12.outline"></a>12.outline</h3><p>万万不可在全局设置 outline:0 none！这样的错误会造成部分场景 下的部分用户产生使用障碍！ 国内很多大站也会犯类似的错误，注意千万不要学习，千万不要模仿！<br>outline 是不占据任何空间的属性。<br>ps:用outline自动填满屏幕剩余空间的应用技巧。<br><img src="/2018/04/02/css世界学习笔记/12.png" alt="css世界学习笔记"></p><p><img src="/2018/04/02/css世界学习笔记/13.png" alt="css世界学习笔记"></p><h3 id="13-direction-rtl十分有用"><a href="#13-direction-rtl十分有用" class="headerlink" title="13.direction:rtl十分有用"></a>13.direction:rtl十分有用</h3><p>ltr 是初始值，表示 left-to-right，就是从左往右的意思。目前东亚以及欧美文字书写就 是从左往右的；rtl 表示 right-to-left，就是从右往左的意思。配合text-align来用在某些场景很有用！另外，配合unicode-bidi 属性也了解一下。</p><h3 id="14-writing-mode实现纵向文字"><a href="#14-writing-mode实现纵向文字" class="headerlink" title="14.writing-mode实现纵向文字"></a>14.writing-mode实现纵向文字</h3><p>配合text-indent可以实现以下效果：<br><img src="/2018/04/02/css世界学习笔记/14.png" alt="css世界学习笔记"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-盒子双重性&quot;&gt;&lt;a href=&quot;#1-盒子双重性&quot; class=&quot;headerlink&quot; title=&quot;1.盒子双重性&quot;&gt;&lt;/a&gt;1.盒子双重性&lt;/h3&gt;&lt;p&gt;按照 display 的属性值不同，值为 block 的元素的盒子实际由外在的“块级盒子” 和内在的
      
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>web缓存</title>
    <link href="http://yoursite.com/2017/09/12/web%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2017/09/12/web缓存/</id>
    <published>2017-09-11T16:00:00.000Z</published>
    <updated>2018-05-10T12:36:31.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。"><a href="#Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。" class="headerlink" title="Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存 。"></a>Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存 。</h2><p>浏览器HTTP缓存可以分为强缓存和协商缓存。强缓存和协商缓存最大也是最根本的区别是：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache），协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。简略流程图如下：</p><p><img src="/2017/09/12/web缓存/1.png" alt="web缓存流程图1"></p><p><img src="/2017/09/12/web缓存/2.png" alt="web缓存流程图2"></p><p>浏览器HTTP缓存由HTTP报文的首部字段决定</p><h2 id="控制强缓存的字段按优先级介绍："><a href="#控制强缓存的字段按优先级介绍：" class="headerlink" title="控制强缓存的字段按优先级介绍："></a>控制强缓存的字段按优先级介绍：</h2><h3 id="1-Pragma"><a href="#1-Pragma" class="headerlink" title="1.Pragma"></a>1.Pragma</h3><p>Pragma是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。虽然它是一个通用首部，但是它在响应报文中时的行为没有规范，依赖于浏览器的实现。RFC中该字段只有no-cache一个可选值，会通知浏览器不直接使用缓存，要求向服务器发请求校验新鲜度。因为它优先级最高，当存在时一定不会命中强缓存。</p><h3 id="2-Expires"><a href="#2-Expires" class="headerlink" title="2.Expires"></a>2.Expires</h3><p>Expires是一个响应首部字段，它指定了一个日期/时间，在这个时间/日期之前，HTTP缓存被认为是有效的。无效的日期比如0，表示这个资源已经过期了。如果同时设置了Cache-Control响应首部字段的max-age，则Expires会被忽略。它也是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。</p><h3 id="3-Cache-Control"><a href="#3-Cache-Control" class="headerlink" title="3.Cache-Control"></a>3.Cache-Control</h3><p>Cache-Control是一个通用首部字段，也是HTTP/1.1控制浏览器缓存的主流字段。和浏览器缓存相关的是如下几个响应指令：</p><p>指令 参数 说明</p><p>private 无 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）</p><p>public 可省略 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存</p><p>no-cache 可省略 缓存前必需确认其有效性</p><p>no-store 无 不缓存请求或响应的任何内容</p><p>max-age=[s] 必需 响应的最大值</p><p>max-age（单位为s）设置缓存的存在时间，相对于发送请求的时间。只有响应报文首部设置Cache-Control为非0的max-age或者设置了大于请求日期的Expires（下文会讲）才有可能命中强缓存。当满足这个条件，同时响应报文首部中Cache-Control不存在no-cache、no-store且请求报文首部不存在Pragma字段，才会真正命中强缓存。max-age=0相当于no-cache。</p><p>no-cache 表示请求必须先与服务器确认缓存的有效性，如果有效才能使用缓存（协商缓存），无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存。Chrome硬性重新加载（Command+shift+R）会在请求的首部加上Pragma：no-cache和Cache-Control：no-cache。会缓存，但是使用这份缓存之前先到服务器上确认这份缓存是不是最新的，是最新的才使用。</p><p>no-store 表示禁止浏览器以及所有中间缓存存储任何版本的返回响应，一定不会出现强缓存和协商缓存，适合个人隐私数据或者经济类数据。绝对不缓存。</p><p>public 表明响应可以被浏览器、CDN等等缓存。对于public，则允许所有服务器缓存该资源。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），Cache-Control 设为 public 是合理的。</p><p>private 响应只作为私有的缓存，不能被CDN等缓存。如果要求HTTP认证，响应会自动设置为private。如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。</p><h2 id="控制协商缓存的字段："><a href="#控制协商缓存的字段：" class="headerlink" title="控制协商缓存的字段："></a>控制协商缓存的字段：</h2><h3 id="1-Last-Modified-If-Modified-Since"><a href="#1-Last-Modified-If-Modified-Since" class="headerlink" title="1.Last-Modified/If-Modified-Since"></a>1.Last-Modified/If-Modified-Since</h3><p>If-Modified-Since是一个请求首部字段，并且只能用在GET或者HEAD请求中。Last-Modified是一个响应首部字段，包含服务器认定的资源作出修改的日期及时间。当带着If-Modified-Since头访问服务器请求资源时，服务器会检查Last-Modified，如果Last-Modified的时间早于或等于If-Modified-Since则会返回一个不带主体的304响应，否则将重新返回资源。</p><h3 id="2-ETag-If-None-Match"><a href="#2-ETag-If-None-Match" class="headerlink" title="2.ETag/If-None-Match"></a>2.ETag/If-None-Match</h3><p>ETag是一个响应首部字段，它是根据实体内容生成的一段hash字符串，标识资源的状态，由服务端产生。If-None-Match是一个条件式的请求首部。如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的ETag，则当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的200响应，否则服务器会返回不带实体的304响应。ETag优先级比Last-Modified高，同时存在时会以ETag为准。</p><h3 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h3><p>在有效期内更新资源可以用资源加时间戳命名的方式，如下图的<img>。<br>按F5相当于no-cache，按ctrl+f5相当于强制刷新，拉取新资源。</p><h3 id="缓存策略："><a href="#缓存策略：" class="headerlink" title="缓存策略："></a>缓存策略：</h3><h4 id="为静态资源设置长缓存时间"><a href="#为静态资源设置长缓存时间" class="headerlink" title="为静态资源设置长缓存时间"></a>为静态资源设置长缓存时间</h4><p>有些资源是很长时间不会改变的，比如网站的 logo 图片、jQuery 库、字体等，因此可以为它们设定「永不过期」的缓存时间，例如设定为 10 年。</p><h4 id="确保文件修改生效"><a href="#确保文件修改生效" class="headerlink" title="确保文件修改生效"></a>确保文件修改生效</h4><p>有些时候我们会修改一些资源，比如更新了 jQuery 版本，或网站的 CSS 样式。如果这些资源已经被缓存，那么除非用户手工刷新页面，否则要等缓存自然过期之后用户才会获得新版本。如何在这种情况下强制浏览器重新下载呢？最有效的一个办法就是在这类资源的文件名中包含版本信息，并在更改之后对应地修改文件名。浏览器发现文件更换后，自然无法使用缓存，而会重新下载。</p><h4 id="对于-HTML-文档谨慎设定过期时间"><a href="#对于-HTML-文档谨慎设定过期时间" class="headerlink" title="对于 HTML 文档谨慎设定过期时间"></a>对于 HTML 文档谨慎设定过期时间</h4><p>大部分情况下，对于其他图片、CSS、JavaScript 等资源的请求都来自一个单一的 HTML 文档。对于这类页面通常应该设定比较短的过期时间，或者干脆不设定。因为如果这类页面被缓存，那么页面中包含的资源的文件名等等信息都会一并被缓存，导致对它的更新难以确保立即对用户生效。</p><p>html文件用no-cache的方式设置，css,js文件用max-age设置.可以对静态资源进行版本控制（比如给静态资源的文件名加上hash值），其次对网页设置合适时长的缓存时间（长短取决于实际场景）。这样就兼顾了版本升级和性能</p><h4 id="引用静态资源时，不要使用-Query-String"><a href="#引用静态资源时，不要使用-Query-String" class="headerlink" title="引用静态资源时，不要使用 Query String"></a>引用静态资源时，不要使用 Query String</h4><p>Query String 就是例如?key=val的字符串，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;/static/js/func.js?v=a87ff8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>这会阻止一部分较老的浏览器（包括 IE6 ）对该资源进行缓存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。&quot;&gt;&lt;a href=&quot;#Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。&quot; class=&quot;headerlink&quot; title=&quot;Web缓存可以分为这几种
      
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="web缓存" scheme="http://yoursite.com/tags/web%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Three.js开发指南笔记</title>
    <link href="http://yoursite.com/2017/08/12/Three.js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/12/Three.js开发指南笔记/</id>
    <published>2017-08-11T16:00:00.000Z</published>
    <updated>2018-09-25T02:53:47.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-渲染器初始化"><a href="#1-渲染器初始化" class="headerlink" title="1.渲染器初始化"></a>1.渲染器初始化</h2><p>渲染器将和Canvas元素进行绑定，如果之前在HTML中手动定义了id为mainCanvas的Canvas元素，那么Renderer可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var renderer = new THREE.WebGLRenderer(&#123;</span><br><span class="line">    canvas: document.getElementById(&apos;mainCanvas&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而如果想要Three.js生成Canvas元素，在HTML中就不需要定义Canvas元素，在JavaScript代码中可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var renderer = new THREE.WebGLRenderer();</span><br><span class="line">renderer.setSize(400, 300);</span><br><span class="line">document.getElementsByTagName(&apos;body&apos;)[0].appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure><p>背景色（清除色）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.setClearColor(0x000000);</span><br></pre></td></tr></table></figure></p><h2 id="2-场景相关API"><a href="#2-场景相关API" class="headerlink" title="2.场景相关API"></a>2.场景相关API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scene.add();    //添加东西</span><br><span class="line">scene.remove();    //移除东西</span><br><span class="line">scene.children();    //获取场景中所有子对象</span><br><span class="line">scene.getChildByName();    //利用name属性，获取场景中某个特定物体</span><br><span class="line">scene.traverse();   //参数接受一个函数，场景中每个子对象都会执行的，相当于forEach</span><br><span class="line"></span><br><span class="line">scene.fog = new THREE.Fog(0xffffff,0.015,100);  //雾化(两个参数时1是雾的颜色，2是雾的浓度；三个参数时1是雾的颜色，2是near值，3是far值)</span><br><span class="line"></span><br><span class="line">scene.overrideMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;);   //设置场景中所有物体的材质</span><br></pre></td></tr></table></figure><h2 id="3-正交投影vs透视投影"><a href="#3-正交投影vs透视投影" class="headerlink" title="3.正交投影vs透视投影"></a>3.正交投影vs透视投影</h2><p>使用透视投影照相机获得的结果是类似人眼在真实世界中看到的有“近大远小”的效果；而使用正交投影照相机获得的结果就像我们在数学几何学课上老师教我们画的效果，对于在三维空间内平行的线，投影到二维空间中也一定是平行的。</p><p>一般说来，对于制图、建模软件通常使用正交投影，这样不会因为投影而改变物体比例；而对于其他大多数应用，通常使用透视投影，因为这更接近人眼的观察效果。</p><h2 id="4-正交投影照相机"><a href="#4-正交投影照相机" class="headerlink" title="4.正交投影照相机"></a>4.正交投影照相机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.OrthographicCamera(left, right, top, bottom, near, far)</span><br></pre></td></tr></table></figure><p>这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，这六个面围成一个长方体，我们称其为视景体（Frustum）。只有在视景体内部（下图中的灰色部分）的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉。</p><p>为了保持照相机的横竖比例，需要保证(right - left)与(top - bottom)的比例与Canvas宽度与高度的比例一致。</p><p>near与far都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般near的值设置得较小，far的值设置得较大，具体值视场景中物体的位置等决定。</p><p><img src="http://www.ituring.com.cn/download/01YiZI4zr57Q.small" alt="camera"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//分别设置照相机的x,y,z位置</span><br><span class="line">camera.position.set(0,0,5);</span><br></pre></td></tr></table></figure><p>另外，因为照相机默认是看向z的负方向，所以要想照相机往其他方向看，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这样照相机就会看着(0,0,0)这个点（无论照相机在哪个位置）</span><br><span class="line">camera.lookAt(new THREE.Vector3(0,0,0));</span><br></pre></td></tr></table></figure><h2 id="5-透视投影照相机"><a href="#5-透视投影照相机" class="headerlink" title="5.透视投影照相机"></a>5.透视投影照相机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.PerspectiveCamera(fov, aspect, near, far);</span><br><span class="line">var camera = new THREE.PerspectiveCamera(45, 400 / 300, 1, 10);</span><br></pre></td></tr></table></figure><p><img src="http://www.ituring.com.cn/download/01YYrMaASOzm.small" alt="camera"></p><p>透视图中，灰色的部分是视景体，是可能被渲染的物体所在的区域。fov是视景体竖直方向上的张角（是角度制而非弧度制），如侧视图所示。</p><p>aspect等于width / height，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。</p><p>near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near。</p><h2 id="6-立方体"><a href="#6-立方体" class="headerlink" title="6.立方体"></a>6.立方体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)</span><br></pre></td></tr></table></figure><p>width是x方向上的长度；height是y方向上的长度；depth是z方向上的长度；后三个参数分别是在三个方向上的分段数，如widthSegments为3的话，代表x方向上水平分为三份。一般情况下不需要分段的话，可以不设置后三个参数，后三个参数的缺省值为1。其他几何形状中的分段也是类似的，下面不做说明。</p><h2 id="7-平面"><a href="#7-平面" class="headerlink" title="7.平面"></a>7.平面</h2><p>这里的平面（PlaneGeometry）其实是一个长方形，而不是数学意义上无限大小的平面。其构造函数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.PlaneGeometry(width, height, widthSegments, heightSegments)</span><br></pre></td></tr></table></figure></p><p>其中，width是x方向上的长度；height是y方向上的长度；后两个参数同样表示分段。</p><h2 id="8-球体"><a href="#8-球体" class="headerlink" title="8.球体"></a>8.球体</h2><p>其中，radius是半径；segmentsWidth表示经度上的切片数；segmentsHeight表示纬度上的切片数；phiStart表示经度开始的弧度；phiLength表示经度跨过的弧度；thetaStart表示纬度开始的弧度；thetaLength表示纬度跨过的弧度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure><h2 id="9-圆形"><a href="#9-圆形" class="headerlink" title="9.圆形"></a>9.圆形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure><h2 id="10-圆柱体"><a href="#10-圆柱体" class="headerlink" title="10.圆柱体"></a>10.圆柱体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)</span><br></pre></td></tr></table></figure><p>其中，radiusTop与radiusBottom分别是顶面和底面的半径，由此可知，当这两个参数设置为不同的值时，实际上创建的是一个圆台；height是圆柱体的高度；radiusSegments与heightSegments可类比球体中的分段；openEnded是一个布尔值，表示是否没有顶面和底面，缺省值为false，表示有顶面和底面。</p><h2 id="11-正n面体"><a href="#11-正n面体" class="headerlink" title="11.正n面体"></a>11.正n面体</h2><p>正四面体（TetrahedronGeometry）、正八面体（OctahedronGeometry）、正二十面体（IcosahedronGeometry）的构造函数较为类似，分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">THREE.TetrahedronGeometry(radius, detail)</span><br><span class="line">THREE.OctahedronGeometry(radius, detail)</span><br><span class="line">THREE.IcosahedronGeometry(radius, detail)</span><br></pre></td></tr></table></figure><p>其中，radius是半径；detail是细节层次（Level of Detail）的层数，对于大面片数模型，可以控制在视角靠近物体时，显示面片数多的精细模型，而在离物体较远时，显示面片数较少的粗略模型。这里我们不对detail多作展开，一般可以对这个值缺省。</p><h2 id="12-圆环面"><a href="#12-圆环面" class="headerlink" title="12.圆环面"></a>12.圆环面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc)</span><br></pre></td></tr></table></figure><p>其中，radius是圆环半径；tube是管道半径；radialSegments与tubularSegments分别是两个分段数，详见上图；arc是圆环面的弧度，缺省值为Math.PI * 2。</p><p><img src="http://www.ituring.com.cn/download/01YZGqQBQI0k" alt="pt"></p><h2 id="13-圆环结"><a href="#13-圆环结" class="headerlink" title="13.圆环结"></a>13.圆环结</h2><p>如果说圆环面是甜甜圈，那么圆环结（TorusKnotGeometry）就是打了结的甜甜圈，其构造参数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments, p, q, heightScale)</span><br></pre></td></tr></table></figure></p><p>前四个参数在圆环面中已经有所介绍，p和q是控制其样式的参数，一般可以缺省，如果需要详细了解，请学习圆环结的相关知识；heightScale是在z轴方向上的缩放。</p><h2 id="14-文字形状"><a href="#14-文字形状" class="headerlink" title="14.文字形状"></a>14.文字形状</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.TextGeometry(text, parameters);</span><br></pre></td></tr></table></figure><p>其中，text是文字字符串，parameters是以下参数组成的对象：</p><p>size：字号大小，一般为大写字母的高度</p><p>height：文字的厚度</p><p>curveSegments：弧线分段数，使得文字的曲线更加光滑</p><p>font：字体，默认是’helvetiker’，需对应引用的字体文件</p><p>weight：值为’normal’或’bold’，表示是否加粗</p><p>style：值为’normal’或’italics’，表示是否斜体</p><p>bevelEnabled：布尔值，是否使用倒角，意为在边缘处斜切</p><p>bevelThickness：倒角厚度</p><p>bevelSize：倒角宽度</p><p>ps:加载字体示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.FontLoader();</span><br><span class="line">loader.load(&apos;../lib/helvetiker_regular.typeface.json&apos;, function(font) &#123;</span><br><span class="line">    var mesh = new THREE.Mesh(new THREE.TextGeometry(&apos;Hello&apos;, &#123;</span><br><span class="line">        font: font,</span><br><span class="line">        size: 1,</span><br><span class="line">        height: 1</span><br><span class="line">    &#125;), material);</span><br><span class="line">    scene.add(mesh);</span><br><span class="line"></span><br><span class="line">    // render</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="15-自定义形状"><a href="#15-自定义形状" class="headerlink" title="15.自定义形状"></a>15.自定义形状</h2><p>由于自定义形状需要手动指定每个顶点位置，以及顶点连接情况，如果该形状非常复杂，程序员的计算量就会比较大。在这种情况下，建议在3ds Max之类的建模软件中创建模型，然后使用Three.js导入到场景中，这样会更高效方便。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 初始化几何形状</span><br><span class="line">var geometry = new THREE.Geometry();</span><br><span class="line"></span><br><span class="line">// 设置顶点位置</span><br><span class="line">// 顶部4顶点</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-1, 2, -1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(1, 2, -1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(1, 2, 1));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-1, 2, 1));</span><br><span class="line">// 底部4顶点</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-2, 0, -2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(2, 0, -2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(2, 0, 2));</span><br><span class="line">geometry.vertices.push(new THREE.Vector3(-2, 0, 2));</span><br><span class="line"></span><br><span class="line">// 设置顶点连接情况</span><br><span class="line">// 顶面</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 1, 3));</span><br><span class="line">geometry.faces.push(new THREE.Face3(1, 2, 3));</span><br><span class="line">// 底面</span><br><span class="line">geometry.faces.push(new THREE.Face3(4, 5, 6));</span><br><span class="line">geometry.faces.push(new THREE.Face3(5, 6, 7));</span><br><span class="line">// 四个侧面</span><br><span class="line">geometry.faces.push(new THREE.Face3(1, 5, 6));</span><br><span class="line">geometry.faces.push(new THREE.Face3(6, 2, 1));</span><br><span class="line">geometry.faces.push(new THREE.Face3(2, 6, 7));</span><br><span class="line">geometry.faces.push(new THREE.Face3(7, 3, 2));</span><br><span class="line">geometry.faces.push(new THREE.Face3(3, 7, 0));</span><br><span class="line">geometry.faces.push(new THREE.Face3(7, 4, 0));</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 4, 5));</span><br><span class="line">geometry.faces.push(new THREE.Face3(0, 5, 1));</span><br></pre></td></tr></table></figure></p><p>需要注意的是，new THREE.Vector3(-1, 2, -1)创建一个矢量，作为顶点位置追加到geometry.vertices数组中。</p><p>而由new THREE.Face3(0, 1, 3)创建一个三个顶点组成的面片，追加到geometry.faces数组中。三个参数分别是四个顶点在geometry.vertices中的序号。</p><h2 id="16-简单材质"><a href="#16-简单材质" class="headerlink" title="16.简单材质"></a>16.简单材质</h2><h3 id="1-基础材质"><a href="#1-基础材质" class="headerlink" title="1.基础材质"></a>1.基础材质</h3><p>对于基本材质，即使改变场景中的光源，使用该材质的物体也始终为颜色处处相同的效果。当然，这不是很具有真实感。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    color: 0xffff00,</span><br><span class="line">    opacity: 0.75</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可以设置以下属性：</p><p>visible：是否可见，默认为true</p><p>side：渲染面片正面或是反面，默认为正面THREE.FrontSide，可设置为反面THREE.BackSide，或双面THREE.DoubleSide</p><p>wireframe：是否渲染线而非面，默认为false</p><p>color：十六进制RGB颜色，如红色表示为0xff0000</p><p>map：使用纹理贴图</p><h3 id="2-深度材质"><a href="#2-深度材质" class="headerlink" title="2.深度材质"></a>2.深度材质</h3><p>其外观不由光照或某个材质属性决定，而是由物体到相机的距离决定。</p><p>可以将这种材质与其他材质相结合，很容易创建出逐渐消失的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var depthMaterial = new THREE.MeshDepthMaterial();</span><br><span class="line">depthMaterial.wireframe = true;  //是否显示线框</span><br><span class="line">depthMaterial.wireframeLineWidth = 10;  //线框线的宽度</span><br></pre></td></tr></table></figure><h3 id="3-联合材质"><a href="#3-联合材质" class="headerlink" title="3.联合材质"></a>3.联合材质</h3><p>把材质结合起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cube = new THREE.SceneUtils.createMultiMaterialObject(geometry,[basicMaterial,depthMaterial]);</span><br></pre></td></tr></table></figure><h3 id="4-每个面材质"><a href="#4-每个面材质" class="headerlink" title="4.每个面材质"></a>4.每个面材质</h3><p>相当于一个材质容器，为几何体每一个面制定不同的材质</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var matArray = [</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0x009e60&#125;),</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0x0051ba&#125;),</span><br><span class="line">    new THREE.MeshBasicMaterial(&#123;color:0xffd500&#125;),</span><br><span class="line">];</span><br><span class="line">var faceMaterial = new THREE.MeshFaceMaterial(matArray);</span><br></pre></td></tr></table></figure><p>ps:要创建一种透明的材质，仅仅设置opacity:0是不够的，还要将transparent设为0。为一个几何体赋予多种材质会复制几何体，从而创建出多个网格。</p><h2 id="17-Lambert材质"><a href="#17-Lambert材质" class="headerlink" title="17.Lambert材质"></a>17.Lambert材质</h2><p>Lambert材质（MeshLambertMaterial）是符合Lambert光照模型的材质。Lambert光照模型的主要特点是只考虑漫反射而不考虑镜面反射的效果，因而对于金属、镜子等需要镜面反射效果的物体就不适应，对于其他大部分物体的漫反射效果都是适用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xffff00</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>color是用来表现材质对散射光的反射能力，也是最常用来设置材质颜色的属性。除此之外，还可以用ambient和emissive控制材质的颜色。</p><p>ambient表示对环境光的反射能力，只有当设置了AmbientLight后，该值才是有效的，材质对环境光的反射能力与环境光强相乘后得到材质实际表现的颜色。</p><p>emissive是材质的自发光颜色，可以用来表现光源的颜色。</p><h2 id="18-Phong材质"><a href="#18-Phong材质" class="headerlink" title="18.Phong材质"></a>18.Phong材质</h2><p>Phong材质（MeshPhongMaterial）是符合Phong光照模型的材质。和Lambert不同的是，Phong模型考虑了镜面反射的效果，因此对于金属、镜面的表现尤为适合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">material = new THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color: 0xff0000,</span><br><span class="line">    specular: 0xffff00,</span><br><span class="line">    shininess: 100</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同样地，可以指定emissive和ambient值，这里不再说明。</p><p>可以通过shininess属性控制光照模型中的n值，当shininess值越大时，高光的光斑越小，默认值为30。</p><h2 id="19-法向材质"><a href="#19-法向材质" class="headerlink" title="19.法向材质"></a>19.法向材质</h2><p>法向材质可以将材质的颜色设置为其法向量的方向，有时候对于调试很有帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshNormalMaterial()</span><br></pre></td></tr></table></figure><p>材质的颜色与照相机与该物体的角度相关，我们只改变照相机位置，就可以观察两个角度的颜色变化。</p><h2 id="20-材质的纹理贴图"><a href="#20-材质的纹理贴图" class="headerlink" title="20.材质的纹理贴图"></a>20.材质的纹理贴图</h2><p>导入图像作为纹理贴图，并添加到相应的材质中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//单张图像应用于长方体</span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;);</span><br><span class="line"></span><br><span class="line">var material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    map: texture</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//可以用回调函数的方式来命令渲染：</span><br><span class="line"></span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;, &#123;&#125;, function() &#123;</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br><span class="line">var material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    map: texture</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>六个面应用不同的图像示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var materials = [];</span><br><span class="line">for (var i = 0; i &lt; 6; ++i) &#123;</span><br><span class="line">    materials.push(new THREE.MeshBasicMaterial(&#123;</span><br><span class="line">        map: THREE.ImageUtils.loadTexture(&apos;../img/&apos; + i + &apos;.png&apos;,</span><br><span class="line">                &#123;&#125;, function() &#123;</span><br><span class="line">                    renderer.render(scene, camera);</span><br><span class="line">                &#125;),</span><br><span class="line">        overdraw: true</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cube = new THREE.Mesh(new THREE.CubeGeometry(5, 5, 5),</span><br><span class="line">        new THREE.MeshFaceMaterial(materials));</span><br><span class="line">scene.add(cube);</span><br></pre></td></tr></table></figure></p><p>棋盘格（复制渲染）：</p><p>原图片：<br><img src="http://www.ituring.com.cn/download/01YdRC86nAUx" alt="pt"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//导入材质</span><br><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/chess.png&apos;, &#123;&#125;, function() &#123;</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可是，棋盘格是8横8纵64个小方格组成的，那应该怎么办呢？</span><br><span class="line"></span><br><span class="line">//首先，我们需要指定重复方式为两个方向（wrapS和wrapT）都重复：</span><br><span class="line">texture.wrapS = texture.wrapT = THREE.RepeatWrapping;</span><br><span class="line"></span><br><span class="line">//然后，设置两个方向上都重复4次，由于我们的图像本来是有2行2列，所以重复4次即为8行8列：</span><br><span class="line">texture.repeat.set(4, 4);</span><br></pre></td></tr></table></figure><p>最后就得到了棋盘格：<br><img src="http://www.ituring.com.cn/download/01YdRCMAK2Xq" alt="pt"></p><h2 id="21-网格"><a href="#21-网格" class="headerlink" title="21.网格"></a>21.网格</h2><p>而网格的创建非常简单，只要把几何形状与材质传入其构造函数。最常用的物体是网格（Mesh），它代表包含点、线、面的几何体，其构造函数是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mesh = new THREE.Mesh(geometry, material);</span><br></pre></td></tr></table></figure></p><p>在网格被创建后，也能对材质进行修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xff0000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>位置、缩放、旋转:</p><p>位置、缩放、旋转是物体三个常用属性。由于THREE.Mesh基础自THREE.Object3D，因此包含scale、rotation、position三个属性。它们都是THREE.Vector3实例，因此修改其值的方法是相同的，这里以位置为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.position.z = 1;</span><br><span class="line">或</span><br><span class="line">mesh.position.set(1.5, -0.5, 0);</span><br></pre></td></tr></table></figure><h2 id="22-动画"><a href="#22-动画" class="headerlink" title="22.动画"></a>22.动画</h2><p>setInterval方法与requestAnimationFrame方法的区别较为微妙。一方面，最明显的差别表现在setInterval可以手动设定FPS，而requestAnimationFrame则会自动设定FPS；但另一方面，即使是setInterval也不能保证按照给定的FPS执行，在浏览器处理繁忙时，很可能低于设定值。当浏览器达不到设定的调用周期时，requestAnimationFrame采用跳过某些帧的方式来表现动画，虽然会有卡滞的效果但是整体速度不会拖慢，而setInterval会因此使整个程序放慢运行，但是每一帧都会绘制出来；</p><p>总而言之，requestAnimationFrame适用于对于时间较为敏感的环境（但是动画逻辑更加复杂），而setInterval则可在保证程序的运算不至于导致延迟的情况下提供更加简洁的逻辑（无需自行处理时间）。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">    mesh.rotation.y = (mesh.rotation.y + 0.01) % (Math.PI * 2);</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">    id = requestAnimationFrame(draw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ps:可以使用stat.js记录FPS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stats.setMode(0);//监测FPS</span><br><span class="line">stats.setMode(1);//监测渲染时间</span><br></pre></td></tr></table></figure><p>详情请见：(使用stat.js记录FPS)[<a href="http://www.ituring.com.cn/book/miniarticle/53353]" target="_blank" rel="noopener">http://www.ituring.com.cn/book/miniarticle/53353]</a></p><h2 id="23-外部导入"><a href="#23-外部导入" class="headerlink" title="23.外部导入"></a>23.外部导入</h2><p>Three.js有一系列导入外部文件的辅助函数，是在three.js之外的，使用前需要额外下载，在(loaders)[<a href="https://github.com/mrdoob/three.js/tree/master/examples/js/loaders]可以找到。" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders]可以找到。</a></p><p>.obj是最常用的模型格式，导入.obj文件需要OBJLoader.js；</p><p>导入带.mtl材质的.obj文件需要MTLLoader.js以及OBJMTLLoader.js。另有PLYLoader.js、STLLoader.js等分别对应不同格式的加载器，可以根据模型格式自行选择。</p><p>导入过程：<a href="http://www.ituring.com.cn/book/miniarticle/53865" target="_blank" rel="noopener">无材质的模型</a><br>         <a href="http://www.ituring.com.cn/book/miniarticle/53881" target="_blank" rel="noopener">有材质的模型</a></p><h2 id="24-环境光"><a href="#24-环境光" class="headerlink" title="24.环境光"></a>24.环境光</h2><p>环境光是指场景整体的光照效果，是由于场景内若干光源的多次反射形成的亮度一致的效果，通常用来为整个场景指定一个基础亮度。因此，环境光没有明确的光源位置，在各处形成的亮度也是一致的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var light = new THREE.AmbientLight(0xffffff);</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure></p><p>环境光并不在乎物体材质的color属性，而是在乎ambient属性。ambient属性的默认值是0xffffff。</p><p>ambient为0x00ff00的长方体被渲染成了黑色。这是因为不透明物体的颜色其实是其反射光的颜色，而ambient属性表示的是物体反射环境光的能力。对于0x00ff00的物体，红色通道是0，而环境光是完全的红光，因此该长方体不能反射任何光线，最终的渲染颜色就是黑色；而对于0xffffff的白色长方体，红色通道是0xff，因而能反射所有红光，渲染的颜色就是红色。</p><p>前面我们看到，当环境光不是白色或灰色的时候，渲染的效果往往会很奇怪。因此，环境光通常使用白色或者灰色，作为整体光照的基础。</p><h2 id="25-点光源"><a href="#25-点光源" class="headerlink" title="25.点光源"></a>25.点光源</h2><p>点光源是不计光源大小，可以看作一个点发出的光源。点光源照到不同物体表面的亮度是线性递减的，因此，离点光源距离越远的物体会显得越暗。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">THREE.PointLight(hex, intensity, distance);</span><br><span class="line"></span><br><span class="line">//应用示例：</span><br><span class="line"></span><br><span class="line">var light = new THREE.PointLight(0xffffff, 2, 100);</span><br><span class="line">light.color = &quot;#ccffcc&quot;;    //设置光源颜色</span><br><span class="line">light.intensity = 1;    //光的强度</span><br><span class="line">light.position.set(0, 1.5, 2);  //设置光源位置</span><br><span class="line">light.distance = 100;   //光源照射距离（默认为0，也就是说光线亮度不会随着距离增加而递减）</span><br><span class="line">light.visible = true;   //光源是否开启</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure><p>其中，hex是光源十六进制的颜色值；intensity是亮度，缺省值为1，表示100%亮度；distance是光源最远照射到的距离，缺省值为0。</p><h2 id="26-平行光"><a href="#26-平行光" class="headerlink" title="26.平行光"></a>26.平行光</h2><p>我们都知道，太阳光常常被看作平行光，这是因为相对地球上物体的尺度而言，太阳离我们的距离足够远。对于任意平行的平面，平行光照射的亮度都是相同的，而与平面所在位置无关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">THREE.DirectionalLight(hex, intensity);</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">var light = new THREE.DirectionalLight();</span><br><span class="line">light.position.set(2, 5, 3);</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure><p>注意，这里设置光源位置并不意味着所有光从(2, 5, 3)点射出（如果是的话，就成了点光源），而是意味着，平行光将以矢量(-2, -5, -3)的方向照射到所有平面。因此，平面亮度与平面的位置无关，而只与平面的法向量相关。只要平面是平行的，那么得到的光照也一定是相同的。</p><h2 id="27-聚光灯"><a href="#27-聚光灯" class="headerlink" title="27.聚光灯"></a>27.聚光灯</h2><p>可以看出，聚光灯是一种特殊的点光源，它能够朝着一个方向投射光线。聚光灯投射出的是类似圆锥形的光线，这与我们现实中看到的聚光灯是一致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.SpotLight(hex, intensity, distance, angle, exponent)</span><br></pre></td></tr></table></figure><p>相比点光源，多了angle和exponent两个参数。angle是聚光灯的张角，缺省值是Math.PI / 3，最大值是Math.PI / 2；exponent是光强在偏离target的衰减指数（target需要在之后定义，缺省值为(0, 0, 0)），缺省值是10。</p><p>在调用构造函数之后，除了设置光源本身的位置，一般还需要设置target：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">light.position.set(x1, y1, z1);</span><br><span class="line">light.target.position.set(x2, y2, z2);</span><br></pre></td></tr></table></figure><p>除了设置light.target.position的方法外，如果想让聚光灯跟着某一物体移动（就像真的聚光灯！），可以target指定为该物体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),</span><br><span class="line">                    new THREE.MeshLambertMaterial(&#123;color: 0x00ff00&#125;));</span><br><span class="line"></span><br><span class="line">var light = new THREE.SpotLight(0xffff00, 1, 100, Math.PI / 6, 25);</span><br><span class="line">light.target = cube;</span><br></pre></td></tr></table></figure><h2 id="28-半球光"><a href="#28-半球光" class="headerlink" title="28.半球光"></a>28.半球光</h2><p>创建出更加贴近自然的户外光照效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var hemiLight = new THREE.HemisphereLight(0x0000ff,0x00ff00,0.6);   //参数分别是天空发出的颜色、地面发出的颜色、光线照射强度</span><br><span class="line"></span><br><span class="line">hemiLight.position.set(0,500,0);</span><br><span class="line">scene.add(hemiLight);</span><br></pre></td></tr></table></figure><h2 id="29-平面光（略）"><a href="#29-平面光（略）" class="headerlink" title="29.平面光（略）"></a>29.平面光（略）</h2><p>定义一个发光的矩形</p><h2 id="30-镜头眩光"><a href="#30-镜头眩光" class="headerlink" title="30.镜头眩光"></a>30.镜头眩光</h2><p>当你直接朝着太阳拍照时就会出现镜头眩光</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var lensFlare = new THREE.LensFlare(texture,350,0.5,THREE.AdditiveBlending,flareColor);</span><br><span class="line">//参数分别是眩光的材质，眩光尺寸(-1就表示用材质本身的尺寸)，光源(0)到相机(1)的距离，融合模式，颜色</span><br><span class="line"></span><br><span class="line">lensFlare.add(texture,60,0.6,THREE.AdditiveBlending);</span><br><span class="line">//增加眩光</span><br></pre></td></tr></table></figure><h2 id="31-阴影"><a href="#31-阴影" class="headerlink" title="31.阴影"></a>31.阴影</h2><p>在Three.js中，能形成阴影的光源只有THREE.DirectionalLight与THREE.SpotLight；而相对地，能表现阴影效果的材质只有THREE.LambertMaterial与THREE.PhongMaterial。因而在设置光源和材质的时候，一定要注意这一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//首先，我们需要在初始化时，告诉渲染器渲染阴影：</span><br><span class="line">renderer.shadowMapEnabled = true;</span><br><span class="line"></span><br><span class="line">//然后，对于光源以及所有要产生阴影的物体调用：</span><br><span class="line">xxx.castShadow = true;</span><br><span class="line"></span><br><span class="line">//对于接收阴影的物体调用：</span><br><span class="line">xxx.receiveShadow = true;</span><br></pre></td></tr></table></figure><p>对于聚光灯，需要设置shadowCameraNear、shadowCameraFar、shadowCameraFov三个值，类比我们在第二章学到的透视投影照相机，只有介于shadowCameraNear与shadowCameraFar之间的物体将产生阴影，shadowCameraFov表示张角。</p><p>对于平行光，需要设置shadowCameraNear、shadowCameraFar、shadowCameraLeft、shadowCameraRight、shadowCameraTop以及shadowCameraBottom六个值，相当于正交投影照相机的六个面。同样，只有在这六个面围成的长方体内的物体才会产生阴影效果。</p><p>为了看到阴影照相机的位置，通常可以在调试时开启light.shadowCameraVisible = true。</p><p>至此，阴影效果已经能正常显示了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">light.shadowCameraNear = 2;</span><br><span class="line">light.shadowCameraFar = 10;</span><br><span class="line">light.shadowCameraFov = 30;</span><br><span class="line">light.shadowCameraVisible = true;</span><br><span class="line"></span><br><span class="line">light.shadowMapWidth = 1024;</span><br><span class="line">light.shadowMapHeight = 1024;</span><br><span class="line">light.shadowDarkness = 0.3;</span><br></pre></td></tr></table></figure><h2 id="32-通过拉伸创建几何体"><a href="#32-通过拉伸创建几何体" class="headerlink" title="32.通过拉伸创建几何体"></a>32.通过拉伸创建几何体</h2><p>把二维图形拉伸成三维图形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//沿着Z轴拉伸</span><br><span class="line">var options = &#123;</span><br><span class="line">    amount:10,//图形可以拉多高</span><br><span class="line">    bevelThickness:2,//斜角厚度</span><br><span class="line">    bevelSize:1,//斜角尺寸</span><br><span class="line">    bevelSegments:3,//斜角分段数</span><br><span class="line">    bevelEnabled:true,//是否用斜角</span><br><span class="line">    curveSegments:12,//曲线分段数</span><br><span class="line">    steps:1//拉伸体段数</span><br><span class="line">&#125;;</span><br><span class="line">shape = createMesh(new THREE.ExtrudeGeometry(drawShape(),options));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//SVG图像2d变3d</span><br><span class="line">function drawShape()&#123;</span><br><span class="line">    var svgStr = $(&apos;#svg1&apos;).attr(&apos;d&apos;);</span><br><span class="line">    var shape = transformSVGPathExposed(svgStr);    //transformSVGPathExposed这个函数是d3-ThreeD库提供的</span><br><span class="line">    return shape;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var options = &#123;</span><br><span class="line">    amount:10,//图形可以拉多高</span><br><span class="line">    bevelThickness:2,//斜角厚度</span><br><span class="line">    bevelSize:1,//斜角尺寸</span><br><span class="line">    bevelSegments:3,//斜角分段数</span><br><span class="line">    bevelEnabled:true,//是否用斜角</span><br><span class="line">    curveSegments:12,//曲线分段数</span><br><span class="line">    steps:1//拉伸体段数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">shape = createMesh(new THREE.ExtrudeGeometry(drawShape(),options));</span><br></pre></td></tr></table></figure><h2 id="33-粒子"><a href="#33-粒子" class="headerlink" title="33.粒子"></a>33.粒子</h2><h2 id="34-相机控件（详情参见THREE-JS开发指南p181）"><a href="#34-相机控件（详情参见THREE-JS开发指南p181）" class="headerlink" title="34.相机控件（详情参见THREE.JS开发指南p181）"></a>34.相机控件（详情参见THREE.JS开发指南p181）</h2><h2 id="35-为物品添加多种材质"><a href="#35-为物品添加多种材质" class="headerlink" title="35.为物品添加多种材质"></a>35.为物品添加多种材质</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mesh = THREE.SceneUtils.createMultiMaterialObject(geometry,materials);</span><br><span class="line">//参数1是几何体，参数2是一个包含多个材质对象的数组</span><br></pre></td></tr></table></figure><h2 id="36-着色器（略）"><a href="#36-着色器（略）" class="headerlink" title="36.着色器（略）"></a>36.着色器（略）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-渲染器初始化&quot;&gt;&lt;a href=&quot;#1-渲染器初始化&quot; class=&quot;headerlink&quot; title=&quot;1.渲染器初始化&quot;&gt;&lt;/a&gt;1.渲染器初始化&lt;/h2&gt;&lt;p&gt;渲染器将和Canvas元素进行绑定，如果之前在HTML中手动定义了id为mainCanvas
      
    
    </summary>
    
      <category term="three.js" scheme="http://yoursite.com/categories/three-js/"/>
    
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>web性能优化</title>
    <link href="http://yoursite.com/2017/08/05/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/08/05/web性能优化/</id>
    <published>2017-08-04T16:00:00.000Z</published>
    <updated>2018-10-23T12:59:24.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web性能优化"><a href="#web性能优化" class="headerlink" title="web性能优化"></a>web性能优化</h3><h3 id="一、资源加载"><a href="#一、资源加载" class="headerlink" title="一、资源加载"></a>一、资源加载</h3><ol><li><p>CDN（存放静态资源的CDN域名和主域名要不一样，因为这便于CDN业务独立，能够独立配置缓存，抛开无用cookie，减小带宽占用。CDN域名与主站域名不同，DNS解析CDN域名还需要花费额外的时间，增加网络延迟。不过可以用DNS Prefetch。）</p></li><li><p>减少http请求</p></li><li><p>图像优化（不要在HTML里缩放图像，雪碧图，字体图标，使用WebP）</p></li><li><p>将 CSS 样式放在页面的上方，将脚本移动到底部（包括内联的）</p></li><li><p>可以给 JavaScript 加上 async 标记，表示 JavaScript 的执行不会读取 DOM ，JavaScript 可以不被 CSS 阻塞，可以在空闲时间立刻执行。（正常来说在浏览器没有下载并解析完成使用 link 引入的 CSS 文件之前，JavaScript 是不会执行的）（defer 跟 async 非常相似，不会阻塞页面加载，但会等到 HTML 完成解析后再执行，并且会按出现的次序执行。）</p></li><li><p>预加载，预渲染：<br><a href="http://web.jobbole.com/84256/" target="_blank" rel="noopener">资源预加载</a>，<a href="https://mp.weixin.qq.com/s?__biz=MzUxMTcwOTM4Mg==&amp;mid=2247484163&amp;idx=1&amp;sn=16b9c907971683dd61cee251adcde79b&amp;chksm=f96edaaace1953bcaf65a1adcf30b6d3dd66cf7b648ae59c4bf807d3f8bf460d5cd638e54ca1&amp;token=946370022&amp;lang=zh_CN#rd" target="_blank" rel="noopener">有一种优化，叫Preload</a></p></li><li><p>懒加载</p></li><li><p>合理使用缓存，localstorage,sessionstorage</p></li><li><p>启用Http2</p></li><li><p>service workers做离线缓存</p></li></ol><hr><h3 id="二、文件体积"><a href="#二、文件体积" class="headerlink" title="二、文件体积"></a>二、文件体积</h3><ol><li><p>Gzip（不要对图片文件进行Gzip压缩！适得其反）</p></li><li><p>webpack打包优化<br><img src="/2017/08/05/web性能优化/1.jpg" alt="web性能优化"><br><img src="/2017/08/05/web性能优化/2.jpg" alt="web性能优化"></p></li></ol><hr><h3 id="三、浏览器渲染运行"><a href="#三、浏览器渲染运行" class="headerlink" title="三、浏览器渲染运行"></a>三、浏览器渲染运行</h3><ol><li><p>WebAssembly（体积小，解析时间短，更接近于机器码执行快，类型是确定的因此不需要JIT作重优化，垃圾回收是手动的）</p></li><li><p>防抖和节流</p></li><li><p>减少 DOM 操作的次数，避免不必要的重排和重绘</p></li><li><p>动画合理使用translate3d,opacity来启用单独图层渲染，硬件加速</p></li><li><p>使用 requestAnimationFrame 来更新页面</p></li><li><p>各种组件，例如轮播图。请等页面加载完毕20ms后再渲染，提升用户体验。</p></li><li><p>通过切换class或者使用元素的style.csstext属性去批量操作元素样式。</p></li><li><p>图片在渲染前指定大小：因为img元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。</p></li></ol><hr><h3 id="四、代码编写优化"><a href="#四、代码编写优化" class="headerlink" title="四、代码编写优化"></a>四、代码编写优化</h3><ol><li><p>CSS不要过多使用*，因为他的选择器匹配原则是从右到左</p></li><li><p>避免过多的css表达式，例如width=3*4px</p></li><li><p>避免js重复脚本。尽量少建立变量，耗费内存空间</p></li><li><p>eslint统一风格，优化代码结构</p></li></ol><hr><h3 id="五、服务器端"><a href="#五、服务器端" class="headerlink" title="五、服务器端"></a>五、服务器端</h3><ol><li><p>负载均衡，nginx搭建反向代理</p></li><li><p>Node.js处理IO密集型请求</p></li></ol><hr><h3 id="六、前端框架优化："><a href="#六、前端框架优化：" class="headerlink" title="六、前端框架优化："></a>六、前端框架优化：</h3><ol><li><p>按需加载，异步组件，组件懒加载</p></li><li><p>骨架屏，做必要的加载错误提示和必要的loading框</p></li><li><p>同构，服务端渲染</p></li><li><p>使用 prerender-spa-plugin 预渲染首屏（先指定 dist 目录和要渲染的路径。插件在 dist 目录中开启一个静态服务器，并且使用无头浏览器（puppeteer）访问对应的路径，执行 JS，抓取对应路径的 html。把抓到的内容写入 html，这样即使没有做服务器端渲染，也能达到跟服务器端渲染几乎相同的作用（不考虑动态数据的话））</p></li><li><p>使用动态 polyfill</p></li><li><p>线上引入生产环境的 Vue 文件、React文件</p></li><li><p>提取组件的 CSS 到单独到文件。当使用单文件组件时，组件内的 CSS 会以style标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，将所有组件的 CSS提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存</p></li><li><p>扁平化 Store 数据结构，data不宜嵌套过深</p></li><li><p>react用pure-component做componentShouldUpdate的优化</p></li><li><p>Vue可以利用Object.freeze()提升性能。Vue 在遇到像 Object.freeze() 这样被设置为不可配置之后的对象属性时，不会为对象加上 setter getter 等数据劫持的方法</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;web性能优化&quot;&gt;&lt;a href=&quot;#web性能优化&quot; class=&quot;headerlink&quot; title=&quot;web性能优化&quot;&gt;&lt;/a&gt;web性能优化&lt;/h3&gt;&lt;h3 id=&quot;一、资源加载&quot;&gt;&lt;a href=&quot;#一、资源加载&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码学习——笔记</title>
    <link href="http://yoursite.com/2017/08/02/jQuery%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/02/jQuery源码学习笔记/</id>
    <published>2017-08-01T16:00:00.000Z</published>
    <updated>2018-10-25T11:44:31.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-立即调用表达式"><a href="#1-立即调用表达式" class="headerlink" title="1.立即调用表达式"></a>1.立即调用表达式</h3><p>任何库与框架设计的第一个要点就是解决命名空间与变量污染的问题。jQuery就是利用了JavaScript函数作用域的特性，采用立即调用表达式包裹了自身的方法来解决这个问题。</p><p><strong>写法1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function(window,factory)&#123;</span><br><span class="line">    factory(window);</span><br><span class="line">&#125;(this,function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        //jQuery调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>写法1主要是为了判断jQuery在不同平台的下的加载逻辑，主流的库一般都有对 AMD 和 CommonJS 的支持代码。</p><p><strong>写法2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var factory = function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var jQuery = factory();</span><br></pre></td></tr></table></figure><p><strong>写法3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function(window,undefined)&#123;</span><br><span class="line">    var jQuery = function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    window.jQuery = window.$ = jQuery;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure><p>传递参数undefined的原因是：<br>Javascript 中的undefined并不是作为关键字，因此可以允许用户对其赋值，为了避免有人在外面给undefined赋了值，所以我们就把它设置为参数。设置undefined参数后，函数内部它默认就是undefined，不会产生歧义。</p><hr><h3 id="2-处理兼容性"><a href="#2-处理兼容性" class="headerlink" title="2.处理兼容性"></a>2.处理兼容性</h3><p>ie9以前的浏览器对xmlNode.method的存在检测有问题，如window.a == undefined达不到检测效果，而用typeof window.a == ‘undefined’能达到效果。</p><hr><h3 id="3-jq的面向对象的写法"><a href="#3-jq的面向对象的写法" class="headerlink" title="3.jq的面向对象的写法"></a>3.jq的面向对象的写法</h3><p>在jquery源码里面，面向对象的写法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function jQuery()&#123;</span><br><span class="line">    //这样写就能实现调用jQuery的时候，直接调用初始化方法，生成实例，这就省去了jq.init()这一步。</span><br><span class="line">    return new jQuery.prototype.init();</span><br><span class="line">&#125;</span><br><span class="line">jQuery.prototype.init = function()&#123;&#125;;</span><br><span class="line">jQuery.prototype.css = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//把init方法的原型指向jQuery的原型，使得它们共享一份原型，所以也就使得init可以用到jQuery原型上的方法了</span><br><span class="line">jQuery.prototype.init.prototype = jQuery.prototype;</span><br><span class="line"></span><br><span class="line">//就可以这样调用了</span><br><span class="line">jQuery().css();</span><br></pre></td></tr></table></figure></p><hr><h3 id="4-prototype两种写法的差异"><a href="#4-prototype两种写法的差异" class="headerlink" title="4.prototype两种写法的差异"></a>4.prototype两种写法的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这是往原型上去添加或修改属性、方法</span><br><span class="line">A.prototype.age = 18;</span><br><span class="line">A.prototype.name = &apos;lala&apos;;</span><br><span class="line"></span><br><span class="line">//这是重写原型，会覆盖掉默认生成的A.prototype.constructor，所以要把constructor写上</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    constructor:A,</span><br><span class="line">    age:18,</span><br><span class="line">    name:&apos;lala&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-init方法的参数处理"><a href="#5-init方法的参数处理" class="headerlink" title="5.init方法的参数处理"></a>5.init方法的参数处理</h3><p>我们在jQuery中用$()用得很多，它实际上调用的是jQuery的init方法，它可以接受以下这么几种参数，接受不同的参数，它的处理方式也是不一样的：</p><p>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;&quot;),$(null),$(undefined),$(false)</span><br></pre></td></tr></table></figure></p><p>这种情况就直接return this，不做其他处理。</p><p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;&lt;li&gt;1&lt;/li&gt;&quot;),$(&quot;&lt;div&gt;&quot;),$(&quot;#div1&quot;),$(&quot;div&quot;),$(&quot;#div1 div.box&quot;)</span><br></pre></td></tr></table></figure></p><p>遇到这种参数是字符串的，就会经过一系列判断、处理，最终生成这么一个对象格式：this = {0:’li’,1:’li’,length:2}。</p><p>(1)参数是字符串且匹配&lt;&gt;括号，说明是创建元素，那就调用parseHTML方法把它转化为元素节点数组，再调用merge方法转成上面所说到的this对象。</p><p>(2)参数是一个id选择器的，那就调用原生js的getElementById来获取它，然后也是再转化为this对象。</p><p>(3)参数是复杂多重选择器的，那就调用find方法（实现逻辑参见sizzle）来获取到元素节点。</p><p>3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(this),$(document)</span><br></pre></td></tr></table></figure></p><p>这种就会判断参数是不是一个node，是的话也是生成一个this对象。</p><p>4.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>如果参数是一个函数，就会在ready方法的回调中执行这个函数</p><p>5.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$([]),$(&#123;&#125;)</span><br></pre></td></tr></table></figure></p><hr><h3 id="6-pushStack方法"><a href="#6-pushStack方法" class="headerlink" title="6.pushStack方法"></a>6.pushStack方法</h3><p>jq对象的入栈（在slice,eq,map等方法中都是调用到这个方法）<br>它是一个栈结构，会先处理后入栈的对象，调用end()方法就会回溯到前一个对象</p><hr><h3 id="7-extend和-fn-extend"><a href="#7-extend和-fn-extend" class="headerlink" title="7.$.extend和$.fn.extend"></a>7.$.extend和$.fn.extend</h3><p>jq里面的继承是拷贝继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//扩展工具方法</span><br><span class="line">$.extend(&#123;</span><br><span class="line">    a:function()&#123;&#125;,</span><br><span class="line">    b:function()&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//调用：</span><br><span class="line">$.a();</span><br><span class="line">$.b();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//扩展jq实例方法</span><br><span class="line">$.fn.extend(&#123;</span><br><span class="line">    a:function()&#123;&#125;,</span><br><span class="line">    b:function()&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//调用：</span><br><span class="line">$().a();</span><br><span class="line">$().b();</span><br><span class="line"></span><br><span class="line">//对一个对象进行扩展</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">$.extend(a,&#123;age:18&#125;,&#123;name:&apos;lala&apos;&#125;)</span><br><span class="line"></span><br><span class="line">//深浅拷贝</span><br><span class="line">$.extend(a,b);//浅拷贝</span><br><span class="line">$.extend(true,a,b);//深拷贝</span><br></pre></td></tr></table></figure><hr><h3 id="8-extend方法详解"><a href="#8-extend方法详解" class="headerlink" title="8.extend方法详解"></a>8.extend方法详解</h3><p><strong>(1)生成唯一字符串(内部)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.expando</span><br></pre></td></tr></table></figure></p><p><strong>(2)解决冲突</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.noConflict()</span><br><span class="line">//写到上一个插件前面</span><br><span class="line">var aaa=$.noConflict();</span><br><span class="line">aaa(function()&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>(3)ready回调</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;&#125;) </span><br><span class="line">相当于</span><br><span class="line">$(document).ready(function()&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>DOM加载完就执行，它通过判断document.readyState或者给document加一个DOMContentLoaded事件监听来触发调用。<br>（ps：可以通过holdReady来控制同步异步，它的实现方式是以计数的方式判断是否能执行下去）</p><p><strong>(4)isWindow方法用来判断是不是window对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isWindow:function(obj)&#123;</span><br><span class="line">    return obj!=null &amp;&amp; obj===obj.window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(5)isNumeric方法用来判断是不是数值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNumeric:function(obj)&#123;</span><br><span class="line">    return !isNaN(parseFloat(obj)) &amp;&amp; isFinite(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(6)isPlainObject判断是不是对象自变量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isPlainObject:function(obj)&#123;</span><br><span class="line">    if(jQuery.type(obj)!==&quot;object&quot; || obj.nodeType || jQuery.isWindow(obj))&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        if(obj.constructor &amp;&amp; !core_hasOwn.call(obj.constructor.prototype,&quot;isPrototypeOf&quot;))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(7)parseHTML方法把标签字符串转换为html元素节点数组</strong></p><p>判断逻辑：</p><p>1.先用正则判断是不是单标签，是单标签就直接createElement</p><p>2.多标签就调用buildFragment</p><p><strong>(8)globalEval方法在全局执行传递进去的字符串参数</strong></p><p>判断逻辑：</p><p>如果是严格模式，那就新建一个script标签，标签里的内容是参数的内容，然后插入到文档中。</p><p>如果不是那就直接eval（因为严格模式下eval有自身的作用域，不是全局的作用域）</p><p><strong>(9)camelCase转驼峰写法（ps：ms前缀与众不同）</strong></p><p>ps:replace方法第二个参数可以是一个函数，这个函数有4个参数可以传入：第一个参数：正则所匹配到的字符；第二个参数：捕获括号所捕获到的字符；<br>第三个参数：正则匹配到的每段字符的第一个字符的索引；第四个参数：用于匹配的字符串主体；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">camelCase:function(str)&#123;</span><br><span class="line">    return str.replace(/^-ms-/,&quot;ms-&quot;).replace(/-([\da-z])/gi,(all,letter)=&gt;&#123;</span><br><span class="line">        return letter.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(10)nodeName方法判断节点的nodename</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeName:function(elem,name)&#123;</span><br><span class="line">    return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase()===name.toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(11)merge方法合并两个数组或形如{0:’a’,1:’b’,length:2}</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">merge:function(first,second)&#123;</span><br><span class="line">    var l = second.length,</span><br><span class="line">        i = first.length,</span><br><span class="line">        j = 0;</span><br><span class="line">    if(typeof l===&quot;number&quot;)&#123;</span><br><span class="line">        for(;j&lt;l;j++)&#123;</span><br><span class="line">            first[i++] = second[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        while(second[j]!==undefined)&#123;</span><br><span class="line">            first[i++] = second[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    first.length = i;</span><br><span class="line">    return first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(12)$(‘#div1’).width()</strong></p><p>它能够获取到即使display为none的元素的宽度，原生的offsetWidth是获取不到的</p><p>它的做法是先把display:none存起来，然后给元素加上display:block;visibility:hidden;position:absolute再获取它的offsetWidth，获取到之后再把刚才存起来的display:none还原，实现“偷梁换柱”（其实这种操作是依靠swap函数来实现的）</p><hr><h3 id="9-Callbacks-回调执行了解一下"><a href="#9-Callbacks-回调执行了解一下" class="headerlink" title="9.$.Callbacks()回调执行了解一下"></a>9.$.Callbacks()回调执行了解一下</h3><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var cb = $.Callbacks(options);</span><br><span class="line">options可以是：&apos;once&apos;,&apos;memory&apos;,&apos;unique&apos;,&apos;stopOnFalse&apos;</span><br><span class="line"></span><br><span class="line">//往回调数组中添加函数</span><br><span class="line">function a()&#123;&#125;</span><br><span class="line">function b()&#123;&#125;</span><br><span class="line">cb.add(a);</span><br><span class="line">cb.add(b);</span><br><span class="line"></span><br><span class="line">//依次调用</span><br><span class="line">cb.fire();</span><br></pre></td></tr></table></figure></p><p>首先有一个list数组来保存callbacks</p><p><strong>(0)options配置参数：</strong></p><p>once代表只能fire一次；</p><p>memory代表即使你的add在fire后面添加，但是也还能生效，他的实现原理是在add方法里面加上fire；</p><p>unique代表对list去重;</p><p>stopOnFlase代表如果回调函数里有return false的话，那就停止后面的执行。</p><p><strong>(1)add方法：</strong><br>往list里面push回调函数</p><p><strong>(2)remove方法：</strong><br>对list进行splice操作来移除某个回调函数</p><p><strong>(3)fire方法：</strong><br>遍历list，依次执行</p><hr><h3 id="10-Deferred-处理异步流程"><a href="#10-Deferred-处理异步流程" class="headerlink" title="10.$.Deferred()处理异步流程"></a>10.$.Deferred()处理异步流程</h3><p>实际上也是调用$.Callbacks()来处理。</p><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var dfd = $.Deferred();</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    alert(1);</span><br><span class="line">    dfd.resolve();  //这是成功触发，另外还有失败触发标志reject</span><br><span class="line">&#125;,1000);</span><br><span class="line">dfd.done(function()&#123;</span><br><span class="line">    alert(2);</span><br><span class="line">&#125;)</span><br><span class="line">dfd.fail(function()&#123;</span><br><span class="line">    alert(3);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>done,fail方法对应callbacks的add方法，resolve,reject方法对应callbacks的fire方法。</p><p>resolve,done实际上对应的是$.Callbacks(‘once memory’)，有once是为了使状态不可逆，只触发一次；</p><p>reject,fail实际上对应的是$.Callbacks(‘once memory’)，有once是为了使状态不可逆，只触发一次；</p><p>notify,progress实际上对应的是$.Callbacks(‘memory’)。</p><p>内部还有一个自定义的promise对象来新增一些协助函数方法，它跟deferred不一样的地方就是它没有那三种状态，防止调用这个方法的时候把状态给改了。</p><p><strong>$.when()方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//相当于promise.all</span><br><span class="line">$.when(a(),b()).done(function()&#123;</span><br><span class="line">    alert(&apos;success&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>它会把参数放进一个数组里面并执行，内部有一个计数器，数值等于数组长度，每有一个参数完成计数器就减一，当计数器为0时那就执行内部新建的$.Deferred()</p><hr><h3 id="11-通过support进行功能检测"><a href="#11-通过support进行功能检测" class="headerlink" title="11.通过support进行功能检测"></a>11.通过support进行功能检测</h3><p>作为兼容性功能的判断实现，主要有样式兼容、h5兼容、js兼容等等。可以通过创建一些元素来检测不同浏览器下这些元素的表现行为、属性方法有什么异同，检测完之后就可以把元素给删掉。</p><p>而针对不同环境下作出不同的反应是通过hooks实现的，support只是一个兼容判断。</p><hr><h3 id="12-attr、prop和data"><a href="#12-attr、prop和data" class="headerlink" title="12.attr、prop和data"></a>12.attr、prop和data</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#div1&apos;).attr(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line">相当于</span><br><span class="line">document.getElementById(&apos;div1&apos;).setAttribute(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line"></span><br><span class="line">$(&apos;#div1&apos;).prop(&apos;name&apos;,&apos;lala&apos;);</span><br><span class="line">相当于</span><br><span class="line">document.getElementById(&apos;div1&apos;).name=&apos;lala&apos;;</span><br><span class="line"></span><br><span class="line">//当然不会这么简单直接设置，它们还会检测参数合法性，解决浏览器兼容问题等等</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这样不会内存泄漏</span><br><span class="line">$(&apos;#div1&apos;).data(&apos;name&apos;,obj);</span><br><span class="line">//这样有可能会内存泄漏</span><br><span class="line">$(&apos;#div1&apos;).attr(&apos;name&apos;,obj);</span><br><span class="line"></span><br><span class="line">//ps：DOM元素和对象之间相互引用，大部分浏览器就会出现内存泄漏</span><br><span class="line">var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">div1.name = obj;</span><br><span class="line">obj.age = div1;</span><br></pre></td></tr></table></figure><p>data方法是怎么做到消除内存泄漏的呢？</p><p>其实它是先新建一个cache对象来存放一种对应联系，建立元素绑定的属性和你自定义要绑定进去的属性之间的联系，就是说这是一种间接绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//cache就是类似于以下这样的结构</span><br><span class="line">this.cache=&#123;</span><br><span class="line">    1:&#123;name:&apos;lala&apos;&#125;,</span><br><span class="line">    2:&#123;name:&apos;lala&apos;,age:19&#125;</span><br><span class="line">&#125;</span><br><span class="line">//它会给每个data分配一个映射到实际属性的key：1、2、3...，同一个元素分配到的都是同一个key</span><br><span class="line">//元素上挂载的实际上是类似于这样的东西：</span><br><span class="line"></span><br><span class="line">&lt;div jquery784382547239469837=&quot;1&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//当this不是元素或者document节点时，这个cache会通过Object.defineProperty设置一个key为0，getter为&#123;&#125;的属性，这是处理非元素节点时用的</span><br></pre></td></tr></table></figure><hr><h3 id="13-jQuery的queue"><a href="#13-jQuery的queue" class="headerlink" title="13.jQuery的queue"></a>13.jQuery的queue</h3><p>跟数据结构里的队列是一样的，只不过它存放的是函数，出队列的时候就会调用这个函数,要前一个函数出了队列才会执行下一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//多个动画animate就用到了queue</span><br><span class="line">$(this).animate(&#123;width:300&#125;,2000);</span><br><span class="line">$(this).animate(&#123;height:100&#125;,2000);</span><br><span class="line">$(this).animate(&#123;left:500&#125;,2000);</span><br></pre></td></tr></table></figure><hr><h3 id="14-对class的操作"><a href="#14-对class的操作" class="headerlink" title="14.对class的操作"></a>14.对class的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#div1&apos;).addClass(&apos;box1 box2&apos;);</span><br><span class="line">$(&apos;#div1&apos;).removeClass(&apos;box1 box2&apos;);</span><br><span class="line">$(&apos;#div1&apos;).toggleClass(&apos;box1 box2&apos;);</span><br></pre></td></tr></table></figure><p>addClass实际上是对传进来的字符串进行检验、分割，然后再用indexOf判断元素原来的class里面有没有新增的class，没有才添加进去，有就不管。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-立即调用表达式&quot;&gt;&lt;a href=&quot;#1-立即调用表达式&quot; class=&quot;headerlink&quot; title=&quot;1.立即调用表达式&quot;&gt;&lt;/a&gt;1.立即调用表达式&lt;/h3&gt;&lt;p&gt;任何库与框架设计的第一个要点就是解决命名空间与变量污染的问题。jQuery就是利用了
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>fl效果器</title>
    <link href="http://yoursite.com/2017/07/12/fl%E6%95%88%E6%9E%9C%E5%99%A8/"/>
    <id>http://yoursite.com/2017/07/12/fl效果器/</id>
    <published>2017-07-11T16:00:00.000Z</published>
    <updated>2018-05-10T12:37:05.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录下fl效果器的效果"><a href="#记录下fl效果器的效果" class="headerlink" title="记录下fl效果器的效果"></a>记录下fl效果器的效果</h3><p>EQUO 音色粗细</p><p>Fabfilter simplon 电音</p><p>fruity chorus 和声</p><p>fruity convolver 空旷回声</p><p>fruity delay 2 重复音</p><p>fruity delay bank 重复音不同</p><p>fruity fast dist 电噪音</p><p>fruity flanger 多种回音</p><p>fruity flangus 电子跳音</p><p>fruity limiter 强弱</p><p>fruity love philter 未来电音</p><p>fruity multiband compressor 钝、干</p><p>fruity parametric EQ 铁质音</p><p>fruity parametric EQ2 多样铁质音</p><p>fruity phaser 多样</p><p>fruity reeverb2 场合音</p><p>fruity squeeze 噪铁</p><p>fruity stereo enhancer 立体音</p><p>fruity stereo shaper 左右声道多样</p><p>fruity vocoder 低小音</p><p>fruity waveshaper 噪</p><p>gross beat 多样重</p><p>hardcore 空灵噪</p><p>maximus 干电音</p><p>soundgoodizer 电</p><p>vocodex 弹东西的声音，赞</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;记录下fl效果器的效果&quot;&gt;&lt;a href=&quot;#记录下fl效果器的效果&quot; class=&quot;headerlink&quot; title=&quot;记录下fl效果器的效果&quot;&gt;&lt;/a&gt;记录下fl效果器的效果&lt;/h3&gt;&lt;p&gt;EQUO 音色粗细&lt;/p&gt;
&lt;p&gt;Fabfilter simplon
      
    
    </summary>
    
      <category term="电音" scheme="http://yoursite.com/categories/%E7%94%B5%E9%9F%B3/"/>
    
    
      <category term="fl" scheme="http://yoursite.com/tags/fl/"/>
    
  </entry>
  
  <entry>
    <title>CSS揭秘学习笔记</title>
    <link href="http://yoursite.com/2017/06/17/css%E6%8F%AD%E7%A7%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/17/css揭秘学习笔记/</id>
    <published>2017-06-16T16:00:00.000Z</published>
    <updated>2018-09-25T02:53:25.554Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、关于自适应媒体查询</strong></p><p>下面还有一些建议，可能会帮你避免不必要的媒体查询。</p><p>1.尝试使用与视口相关的单位（vw、vh、vmin和vmax），它们的值解析为视口宽度或高度的百分比。</p><p>2.当你需要在较大分辨率下得到固定宽度时，使用max-width而不是width，因为它可以适应较小的分辨率，而无需使用媒体查询。</p><p>3.不要忘记为替换元素（比如img、object、video、iframe等）设置一个max-width，值为100%。</p><p>4.假如背景图片需要完整地铺满一个容器，不管容器的尺寸如何变化，background-size:cover这个属性都可以做到。但是，我们也要时刻牢记——带宽并不是无限的，因此在移动网页中通过CSS把一张大图缩小显示往往是不太明智的。</p><p>5.当图片（或其他元素）以行列式进行布局时，让视口的宽度来决定列的数量。弹性盒布局（即Flexbox）或者display:inline-block加上常规的文本折行行为，都可以实现这一点。</p><p>6.在 使 用 多 列 文 本 时，指定column-width（列 宽）而 不 是 指 定column-count（列数），这样它就可以在较小的屏幕上自动显示为单列布局。</p><hr><p><strong>二、半透明边框</strong></p><p>默认状态下，背景会延伸到边框的区域下层。</p><p>我们可以通过background-clip属性来调整上述默认行为所带来的不便。这个属性的初始值是border-box，意味着背景会被元素的border  box（边框的外沿框）裁切掉。如果不希望背景侵入边框所在的范围，我们要做的就是把它的值设为padding-box，这样浏览器就会用内边距的外沿来把背景裁切掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid hsla(0,0%,100%,.5);</span><br><span class="line">background:white;</span><br><span class="line">background-clip:padding-box;</span><br></pre></td></tr></table></figure></p><hr><p><strong>三、利用投影实现多重边框</strong></p><p>唯一需要注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依次类推。因此，你需要按此规律调整扩张半径。比如说，在前面的代码中，我们想在外圈再加一道5px的外框，那就需要指定扩张半径的值为15px（10px+5px）。如果你愿意，甚至还可以在这些“边框”的底下再加一层常规的投影：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background:yellowgreen;</span><br><span class="line">box-shadow:0 0 0 10px #655,</span><br><span class="line">0 0 0 15px deeppink,</span><br><span class="line">0 2px 5px 15px rgba(0,0,0,.6);</span><br></pre></td></tr></table></figure><p>投影的行为跟边框不完全一致，因为它不会影响布局，而且也不会受到box-sizing属性的影响。不过，你还是可以通过内边距或外边距（这取决于投影是内嵌和还是外扩的）来额外模拟出边框所需要占据的空间。</p><p>上述方法所创建出的假“边框”出现在元素的外圈。它们并不会响应鼠标事件，比如悬停或点击。如果这一点非常重要，你可以给box-shadow属性加上inset关键字，来使投影绘制在元素的内圈。请注意，此时你需要增加额外的内边距来腾出足够的空隙。</p><hr><p><strong>四、background-position</strong></p><p>举例来说，如果想让背景图片跟右边缘保持20px的偏移量，同时跟底边保持10px的偏移量，同时兼容不支持这一特性的浏览器时，可以这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background:url(code-pirate.svg) no-repeat bottom right #58a;</span><br><span class="line">background-position:right 20px bottom 10px;</span><br></pre></td></tr></table></figure><hr><p><strong>五、利用background-origin改变背景区域</strong></p><p>在网页开发生涯中，你很可能多次写过类似background-position: top  left;这样的代码。你是否曾经有过疑惑：这个top  left到底是哪个左上角？你可能知道，每个元素身上都存在三个矩形框：border box（边框的外沿框）、paddingbox（内边距的外沿框）和content box（内容区的外沿框）。那background-position这个属性指定的到底是哪个矩形框的左上角？</p><p>默认情况下，background-position是以paddingbox为准的，这样边框才不会遮住背景图片。因此，topleft默认指的是padding  box的左上角。不过，我们得到了一个新的属性background-origin，可以用它来改变这种行为。在默认情况下，它的值是（闭着眼睛也猜得到）padding-box。如果把它的值改成content-box（参见下面的代码），我们在background-position属性中使用的边角关键字将会以内容区的边缘作为基准（也就是说，此时背景图片距离边角的偏移量就跟内边距保持一致了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">padding:10px;</span><br><span class="line">background:url(&quot;code-pirate.svg&quot;) no-repeat #58a</span><br><span class="line">bottom right; /* 或100% 100% */</span><br><span class="line">background-origin:content-box;</span><br></pre></td></tr></table></figure><p>这样就可以实现跟第四点一样的效果。</p><hr><p><strong>六、calc()</strong></p><p>请不要忘记在calc()函数内部的-和+运算符的两侧各加一个空白符，否则会产生解析错误！这个规则如此怪异，是为了向前兼容：未来，在calc()内部可能会允许使用关键字，而这些关键字可能会包含连字符。</p><p>让我们回顾一下本节开头的挑战：把背景图片定位到距离底边10px且距离右边20px的位置。如果我们仍然以左上角偏移的思路来考虑，其实就是希望它有一个100%  -20px的水平偏移量，以及100%  -  10px的垂直偏移量。谢天谢地，calc()函数允许我们执行此类运算，它可以完美地在background-position属性中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background:url(&quot;code-pirate.svg&quot;) no-repeat;</span><br><span class="line">background-position:calc(100% - 20px)calc(100% - 10px);</span><br></pre></td></tr></table></figure><hr><p><strong>七、利用linear-gradient实现多色条纹背景</strong></p><p>如果我们把第二个色标的位置值设置为0，那它的位置就总是会被浏览器调整为前一个色标的位置值。</p><p>水平条纹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background:linear-gradient(#fb3 33.3%,#58a 0,#58a 66.6%,yellowgreen 0);</span><br><span class="line">background-size:100% 45px;</span><br></pre></td></tr></table></figure><p>垂直条纹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background:linear-gradient(to right, /* 或90deg */</span><br><span class="line">#fb3 50%,#58a 0);</span><br><span class="line">background-size:30px 100%;</span><br></pre></td></tr></table></figure><p>斜向条纹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background:linear-gradient(45deg,</span><br><span class="line">#fb3 25%,#58a 0,#58a 50%,</span><br><span class="line">#fb3 0,#fb3 75%,#58a 0);</span><br><span class="line">background-size:30px 30px;</span><br></pre></td></tr></table></figure><hr><p><strong>八、border-radius</strong></p><p>说到border-radius，有一个鲜为人知的真相：它可以单独指定水平和垂直半径，只要用一个斜杠（/）分隔这两个值即可。这个特性允许我们在拐角处创建椭圆圆角（参见图3-3）。因此，如果我们有一个尺寸为200px×150px的元素，就可以把它圆角的两个半径值分别指定为元素宽高的一半，从而得到一个精确的椭圆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-radius:100px /75px;</span><br></pre></td></tr></table></figure><hr><p><strong>九、平行四边形</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;button&quot;&gt;按钮1&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.button &#123;</span><br><span class="line">position:relative;</span><br><span class="line">display:inline-block;</span><br><span class="line">/* 其他的文字颜色、内边距等样式……*/</span><br><span class="line">&#125;</span><br><span class="line">.button::before &#123;</span><br><span class="line">content: &apos;&apos;; /* 用伪元素来生成一个矩形*/</span><br><span class="line">position:absolute;</span><br><span class="line">top:0; right:0; bottom:0; left:0;</span><br><span class="line">z-index: -1;</span><br><span class="line">background:#58a;</span><br><span class="line">transform:skew(45deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>十、菱形相册</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.picture &#123;</span><br><span class="line">width:400px;</span><br><span class="line">transform:rotate(45deg);</span><br><span class="line">overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.picture &gt;img &#123;</span><br><span class="line">max-width:100%;</span><br><span class="line">transform: rotate(-45deg)scale(1.42);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，可以用clip-path的方法来实现，它还可以参与动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img &#123;</span><br><span class="line">clip-path:polygon(50% 0,100% 50%,</span><br><span class="line">50% 100%,0 50%);</span><br><span class="line">transition:1s clip-path;</span><br><span class="line">&#125;</span><br><span class="line">img:hover &#123;</span><br><span class="line">clip-path:polygon(0 0,100% 0,</span><br><span class="line">100% 100%,0 100%);</span><br></pre></td></tr></table></figure><hr><p><strong>十一、切角实现</strong></p><p>四个角都是切角：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">background:#58a;</span><br><span class="line">background:</span><br><span class="line">linear-gradient(135deg,transparent 15px,#58a 0)</span><br><span class="line">top left,</span><br><span class="line">linear-gradient(-135deg,transparent 15px,#58a 0)</span><br><span class="line">top right,</span><br><span class="line">linear-gradient(-45deg,transparent 15px,#58a 0)</span><br><span class="line">bottom right,</span><br><span class="line">linear-gradient(45deg,transparent 15px,#58a 0)</span><br><span class="line">bottom left;</span><br><span class="line">background-size:50% 50%;</span><br><span class="line">background-repeat:no-repeat;</span><br></pre></td></tr></table></figure><hr><p><strong>十二、单行打字动画</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@keyframes typing &#123;</span><br><span class="line">    from &#123; width: 0 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes caret &#123;</span><br><span class="line">    50% &#123; border-right-color: transparent; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">    font: bold 200% Consolas, Monaco, monospace;</span><br><span class="line">    /*width: 8.25em;*/</span><br><span class="line">    width: 15ch;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    border-right: .05em solid;</span><br><span class="line">    animation: typing 8s steps(15),</span><br><span class="line">               caret 1s steps(1) infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、关于自适应媒体查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面还有一些建议，可能会帮你避免不必要的媒体查询。&lt;/p&gt;
&lt;p&gt;1.尝试使用与视口相关的单位（vw、vh、vmin和vmax），它们的值解析为视口宽度或高度的百分比。&lt;/p&gt;
&lt;p&gt;2.当你需要在较大
      
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/06/15/hello-world/"/>
    <id>http://yoursite.com/2017/06/15/hello-world/</id>
    <published>2017-06-14T16:00:00.000Z</published>
    <updated>2018-03-18T11:27:05.387Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="其它" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
