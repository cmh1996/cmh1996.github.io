{"title":"前端数据流管理模式（二）——Redux篇","date":"2018-04-29T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1524652630664&di=23d9d07af5ac73567091c176ab06cda5&imgtype=0&src=http%3A%2F%2Fbpic.ooopic.com%2F16%2F72%2F90%2F16729077-e888256f82a58a5d8d62ddb535fd0f5d.jpg","excerpt":"","slug":"前端数据流管理模式（二）——Redux篇","comments":true,"dropcap":false,"tags":["js","前端数据流"],"categories":["js"],"updated":"2018-04-27T12:56:11.351Z","content":"<h2 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h2><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理，属于Flux模式的具体实现之一，核心理念是在初始状态上依次叠加后续的变更，所得的就是当前的状态。</p>\n<hr>\n<h3 id=\"Redux各部分职能\"><a href=\"#Redux各部分职能\" class=\"headerlink\" title=\"Redux各部分职能\"></a>Redux各部分职能</h3><p>先来了解一下Redux的主要组成部分：</p>\n<ul>\n<li><p>Action：触发改变store中的state的唯一方法，它通过store.dispatch来将action传到store中。</p>\n</li>\n<li><p>Reducer：action只是描述事件的简单对象，而reducer会说明怎么更新state。reducer是一个纯函数：（(prevState,action)=&gt;newState）。因此你不能在reducer中执行这些操作：修改传入的参数；执行有副作用的操作；调用非纯函数（如Date.now(),Math.random()等等）。</p>\n</li>\n<li><p>Store：存放整个应用的state，并将action和reducer联系起来。store可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。Redux应用只有一个单一的store。当需要拆分数据处理逻辑时，你应该使用 reducer 组合而不是创建多个 store。它提供了以下四个方法：</p>\n<ol>\n<li>dispatch:用于action的分发。在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。</li>\n<li>subscribe：监听state的变化。这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。 let unsubscribe = store.subscribe(() =&gt; {console.log(‘state发生了变化’)})</li>\n<li>getState：获取store中的state。当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。</li>\n<li>replaceReducer:替换reducer，改变state修改的逻辑。</li>\n</ol>\n</li>\n<li><p>View：触发action以改变state，以及接收state数据以渲染界面。以react视图层为例，react通过react-redux把store绑定到视图上。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"Redux流程\"><a href=\"#Redux流程\" class=\"headerlink\" title=\"Redux流程\"></a>Redux流程</h3><p>那么这几个部分是怎么串联起来，相互配合，实现单向数据流的呢？</p>\n<p><img src=\"https://pic4.zhimg.com/v2-657d3433e0e6b2b8a029aa7bc331a841_r.jpg\" alt=\"Redux流程示意图\"></p>\n<p><strong>一、初始化</strong></p>\n<ol>\n<li>创建好store。根reducer通过combineReducers()合并了reducers，然后作为参数传入createStore()中，生成唯一的store。</li>\n<li>建立store与组件间的通信。通过Provider组件建立联系，Provider实质上是创建了一个用于更新视图的网络，智能组件通过connect()连入网络，以获取state更新。</li>\n<li>在组件中准备好action的回调函数。 为了让木偶组件更容易处理动作，智能组件可以使用bindActionCreators()来设置action回调函数。 这样，他们可以将回调函数传递给木偶组件。</li>\n</ol>\n<p><strong>二、触发数据流</strong></p>\n<ol>\n<li>视图发出一个action，actionCreator将它格式化并返回它。</li>\n<li>这个action要么被自动dispatch（使用了bindActionCreators()），要么由view手动dispatch。</li>\n<li>store接收到这个action后，将当前的状态树和action传给了根reducer。</li>\n<li>根reducer将整个状态树分割成一个个小块，然后将某个小块分发给知道该怎么处理这部分内容的子reducer。</li>\n<li>子reducer将传入的一小块状态树进行拷贝，然后在这个副本上进行修改，最终将修改后的副本返回给根reducer。</li>\n<li>根reducer将子reducer返回过来的部分再次组合成一棵新的状态树，然后把它交给store，store就会把当前的状态置为这棵最新的状态树。</li>\n<li>store告诉view状态更新了，view让store把更新的状态传过去，之后view触发rerender进行重新渲染。</li>\n</ol>\n<hr>\n<h3 id=\"Redux三大原则\"><a href=\"#Redux三大原则\" class=\"headerlink\" title=\"Redux三大原则\"></a>Redux三大原则</h3><p>Redux有三大基本原则：</p>\n<ul>\n<li>单一数据源：整个应用的状态state都是存储在一棵树上，并且这棵状态树只存在于唯一一个store中。</li>\n<li>state是只读的：对state的修改的唯一做法是触发action，不能直接修改state。</li>\n<li>用纯函数执行修改：reducer根据旧状态和传进来的action来生成一个新的state，不直接修改state。<br>（ps：纯函数是什么？<br>纯函数就是有相同输入值时只会产生相同的输出的函数，而且纯函数中不包含任何产生副作用的语句。）</li>\n</ul>\n<hr>\n<h3 id=\"Redux处理异步的中间件\"><a href=\"#Redux处理异步的中间件\" class=\"headerlink\" title=\"Redux处理异步的中间件\"></a>Redux处理异步的中间件</h3><p>Redux针对异步数据流的情况，也设计出中间件这个概念来隔离异步所带来的副作用。它的主要目的就是控制异步dispatch，分离副作用。</p>\n<p>接下来说说最具代表性的两个异步中间件：redux-thunk 和 redux-saga。</p>\n<h4 id=\"redux-thunk\"><a href=\"#redux-thunk\" class=\"headerlink\" title=\"redux-thunk\"></a>redux-thunk</h4><p>它是一个dispatch的改造者，先来看看它是怎么用的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function getUserName(dispatch, getState, id) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        const user = await axios.get(`xxxx`);</span><br><span class=\"line\">        dispatch(&#123;</span><br><span class=\"line\">            type: &apos;GETUSERNAME_SUCCESS&apos;,</span><br><span class=\"line\">            data: name</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; catch(err) &#123;</span><br><span class=\"line\">        dispatch(&#123;</span><br><span class=\"line\">            type: &apos;GETUSERNAME_FAILED&apos;,</span><br><span class=\"line\">            error: err</span><br><span class=\"line\">        &#125;);        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">store.dispatch(getUserName);</span><br></pre></td></tr></table></figure></p>\n<p>redux-thunk把dispatch改造成可以接受一个函数作为参数。这个函数往往就是我们定义的一个异步处理函数。如上例，我们在里面发起了一个异步的网络请求，当有数据返回的时候，就会执行成功或失败所对应的dispatch（这个dispatch就是我们平常用的dispatch），同步提交action。</p>\n<p>接下来看看它的源码。<br>redux-thunk的源码只有短短的11行，对，你没看错，就是11行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createThunkMiddleware(extraArgument) &#123;</span><br><span class=\"line\">  return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;</span><br><span class=\"line\">    if (typeof action === &apos;function&apos;) &#123;</span><br><span class=\"line\">      return action(dispatch, getState, extraArgument);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return next(action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const thunk = createThunkMiddleware();</span><br><span class=\"line\">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class=\"line\">export default thunk;</span><br></pre></td></tr></table></figure></p>\n<p>这个中间件做的工作主要是判断传进来的参数是不是一个函数，是的话就执行传进来的函数（正常来说dispatch里面传的是一个plainObject，也就是一个action，但是redux-thunk使得dispatch里能传一个函数，这个函数就是包含异步处理逻辑的函数），不是的话交给下一个中间件处理。</p>\n<h4 id=\"redux-saga\"><a href=\"#redux-saga\" class=\"headerlink\" title=\"redux-saga\"></a>redux-saga</h4><p>可以把redux-saga理解为启动了一个“监听线程”，这个线程处理的输入是action，输出也是action，中间的逻辑就可以自己自由处理了。是在action和reducer之外的一层逻辑，使用saga会保持action的简单。</p>\n<p>比起redux-thunk有这么几个优点：</p>\n<ol>\n<li>生命周期有所不同，redux-saga 可以理解成一直运行于后台的“LLT”（长时事务），而 redux-thunk 是一个 action，因而 redux-saga 能做的事情更多。</li>\n<li>比起thunk，saga提供了更多的流程控制能力。redux-saga 有诸多常用并且声明式易测的 Effects，比如它可以无阻塞地调用一个 generator（fork）、中断一个generator（cancel）。这些特性在业务逻辑复杂的场景下非常适用。</li>\n<li>redux-saga 最具魅力的地方，是它保持了 action 的原义，保持 action 的简洁，把所有有副作用的地方独立开来。这种特性让 redux-saga 在业务逻辑简单的场景下，也能保持代码清晰简洁，也就是说 redux-saga 的适用性较为普遍。</li>\n</ol>\n<hr>\n<h3 id=\"连接React和Redux的桥梁：React-Redux\"><a href=\"#连接React和Redux的桥梁：React-Redux\" class=\"headerlink\" title=\"连接React和Redux的桥梁：React-Redux\"></a>连接React和Redux的桥梁：React-Redux</h3><p><img src=\"https://raw.githubusercontent.com/bailicangdu/react-pxq/master/screenshot/all_redux.png\" alt=\"redux配合react流程示意图\"></p>\n<h4 id=\"react-redux主要提供了这么两个方法：\"><a href=\"#react-redux主要提供了这么两个方法：\" class=\"headerlink\" title=\"react-redux主要提供了这么两个方法：\"></a>react-redux主要提供了这么两个方法：</h4><ol>\n<li><p>provider。相当于一个高阶组件，包在整个组件树的最外层，让所有子孙组件都能使用connect来绑定store。它利用了 React 的 context 这一特性，只要在最外层的组件实现一个 getChildContext这个方法（React内置的），返回一个对象，内部的组件都可以通过 this.context 拿到这个对象。</p>\n</li>\n<li><p>connect。若一个组件想响应状态的变化，就把自己作为参数传给connect。<br>我们先看一下 connect 一般情况下是怎么使用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default connect(mapStateToProps, mapDispatchToProps)(MyComponent)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>首先，export 出去的是一个增强过的 react 组件，也就是说 connect(mapStateToProps, mapDispatchToProps) 第一步首先返回了一个高阶组件。connect()()有两次执行，那么 connect 第二步具体做了什么呢？被这样包裹了一层之后，相应的组件变成了 Container / Smart Component，可以通过 this.props 来获取 store 里的 state，以及 dispatch 这个方法。这样一来，store.state 的更新也就触发了 this.props 的更新，继而触发了容器组件的 re-render。所以，connect 第二步就是把 mapStateToProps 和 mapDispatchToProps 里的返回的属性，以及本身的 props 一起，作为 props 传递给了被包裹的组件。<br>那么，connect 是怎么做到监听 store 变化的呢？答案是用到了Redux的subscribe这个API。综上，connect的内部应该是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function connect(mapStateToProps, mapDispatchToProps) &#123;</span><br><span class=\"line\">  return function createHOC(WrappedComponent) &#123;</span><br><span class=\"line\">    class Connect extends React.Component &#123;</span><br><span class=\"line\">      constructor(props, context) &#123;</span><br><span class=\"line\">        this.store = context.store // &lt;Provider /&gt; 提供</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      componentDidMount() &#123;</span><br><span class=\"line\">        this.unsubscribe = this.store.subscribe(this.handleChange.bind(this))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      componentWillUnmount() &#123;</span><br><span class=\"line\">        this.unsubscribe()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      handleChange() &#123;</span><br><span class=\"line\">        this.forceUpdate()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">          &lt;WrappedComponent </span><br><span class=\"line\">            &#123;...this.props&#125;</span><br><span class=\"line\">            &#123;...mapStateToProps(this.store.getState(), this.props)&#125;</span><br><span class=\"line\">            &#123;...mapDispatchToProps(this.store.dispatch, this.props)&#125;</span><br><span class=\"line\">          /&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Connect.displayName = `Connect($&#123;WrappedComponent.name </span><br><span class=\"line\">                              || WrappedComponent.displayName&#125;)`</span><br><span class=\"line\">    return Connect</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"考虑使用Immutable优化纯函数的操作\"><a href=\"#考虑使用Immutable优化纯函数的操作\" class=\"headerlink\" title=\"考虑使用Immutable优化纯函数的操作\"></a>考虑使用Immutable优化纯函数的操作</h3><p>Redux的宗旨就是单一数据流，可追溯，这两点恰恰是immutable.js的优势。<br>Immutable Data就是一旦创建，就不能再被更改的数据。对Immutable对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是持久化数据结构，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免深拷贝把所有节点都复制一遍带来的性能损耗，Immutable 使用了结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p>\n<p>示例图：<br><img src=\"http://img.alicdn.com/tps/i2/TB1zzi_KXXXXXctXFXXbrb8OVXX-613-575.gif\" alt=\"Immutable结构共享\"></p>\n<p>比如说，我们可以在reducer中这样用immutable：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const proData = (state = defaultState, action) =&gt; &#123;</span><br><span class=\"line\">  let imuDataList;</span><br><span class=\"line\">  let imuItem;</span><br><span class=\"line\">  switch(action.type)&#123;</span><br><span class=\"line\">    case pro.GETPRODUCTION: </span><br><span class=\"line\">      return &#123;...state, ...action&#125;</span><br><span class=\"line\">    case pro.TOGGLESELECT:</span><br><span class=\"line\">      //避免引用类型数据，使用immutable进行数据转换 </span><br><span class=\"line\">      imuDataList = Immutable.List(state.dataList);</span><br><span class=\"line\">      imuItem = Immutable.Map(state.dataList[action.index]);</span><br><span class=\"line\">      imuItem = imuItem.set(&apos;selectStatus&apos;, !imuItem.get(&apos;selectStatus&apos;));</span><br><span class=\"line\">      imuDataList = imuDataList.set(action.index, imuItem);</span><br><span class=\"line\">      // redux必须返回一个新的state</span><br><span class=\"line\">      return &#123;...state, ...&#123;dataList: imuDataList.toJS()&#125;&#125;;</span><br><span class=\"line\">    case pro.EDITPRODUCTION:</span><br><span class=\"line\">      //避免引用类型数据，使用immutable进行数据转换 </span><br><span class=\"line\">      imuDataList = Immutable.List(state.dataList);</span><br><span class=\"line\">      imuItem = Immutable.Map(state.dataList[action.index]);</span><br><span class=\"line\">      imuItem = imuItem.set(&apos;selectNum&apos;, action.selectNum);</span><br><span class=\"line\">      imuDataList = imuDataList.set(action.index, imuItem);</span><br><span class=\"line\">      // redux必须返回一个新的state</span><br><span class=\"line\">      return &#123;...state, ...&#123;dataList: imuDataList.toJS()&#125;&#125;;</span><br><span class=\"line\">    // 清空数据</span><br><span class=\"line\">    case pro.CLEARSELECTED:</span><br><span class=\"line\">      imuDataList = Immutable.fromJS(state.dataList);</span><br><span class=\"line\">      for (let i = 0; i &lt; state.dataList.length; i++) &#123;</span><br><span class=\"line\">        imuDataList = imuDataList.update(i, item =&gt; &#123;</span><br><span class=\"line\">          item = item.set(&apos;selectStatus&apos;, false);</span><br><span class=\"line\">          item = item.set(&apos;selectNum&apos;, 0);</span><br><span class=\"line\">          return item</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return &#123;...state, ...&#123;dataList: imuDataList.toJS()&#125;&#125;;</span><br><span class=\"line\">    default: </span><br><span class=\"line\">      return state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Immutable带来的优点\"><a href=\"#Immutable带来的优点\" class=\"headerlink\" title=\"Immutable带来的优点\"></a>Immutable带来的优点</h4><ol>\n<li>Immutable 降低了 Mutable 带来的复杂度。可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function touchAndLog(touchFn) &#123;</span><br><span class=\"line\">  let data = &#123; key: &apos;value&apos; &#125;;</span><br><span class=\"line\">  touchFn(data);</span><br><span class=\"line\">  console.log(data.key); // 猜猜会打印什么？</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在不查看 <code>touchFn</code> 的代码的情况下，因为不确定它对 <code>data</code> 做了什么，你是不可能知道会打印什么。但如果 <code>data</code> 是 Immutable 的呢，你可以很肯定的知道打印的是 <code>value</code>。</p>\n<ol>\n<li>节省内存。Immutable.js 使用了结构共享，会尽量复用内存。没有被引用的对象会被垃圾回收。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Map&#125; from &apos;immutable&apos;;</span><br><span class=\"line\">let a = Map(&#123;</span><br><span class=\"line\">  select: &apos;users&apos;,</span><br><span class=\"line\">  filter: Map(&#123; name: &apos;Cam&apos; &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let b = a.set(&apos;select&apos;, &apos;people&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">a === b; // false</span><br><span class=\"line\"></span><br><span class=\"line\">a.get(&apos;filter&apos;) === b.get(&apos;filter&apos;); // true</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上面 a 和 b 共享了没有变化的 <code>filter</code> 节点。</p>\n<ol>\n<li>可回溯，时间旅行这些功能做起来小菜一碟。因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。</li>\n</ol>\n<hr>\n<h3 id=\"Redux和Flux的区别\"><a href=\"#Redux和Flux的区别\" class=\"headerlink\" title=\"Redux和Flux的区别\"></a>Redux和Flux的区别</h3><ol>\n<li>Redux只有一个store，且在reducer中执行更新逻辑；Flux有多个store且在store中执行更新逻辑。</li>\n<li>Redux没有dispatcher，它是通过reducer来处理数据（reducer是一个纯函数，(prevState,action)=&gt;newState）。在Redux中可能有多个reducer，单个reducer负责维护应用整体state树中的某一部分，多个reducer通过combineReducers合成一个根reducer来维护整个state。</li>\n<li>Redux概念太超前了，一步到位强制把副作用隔离掉了，但自己又没有深入解决带来的代码冗余问题。</li>\n</ol>\n<hr>\n<h3 id=\"Redux优缺点\"><a href=\"#Redux优缺点\" class=\"headerlink\" title=\"Redux优缺点\"></a>Redux优缺点</h3><p>优点：</p>\n<ol>\n<li>纯函数的开发模式，无副作用。</li>\n<li>单向数据流流动自然清晰，任何的dispatch都会通知到reducer来处理，增强更新粒度可控性。</li>\n<li>利用中间件的模式来解决异步带来的副作用问题。</li>\n<li>可时间回溯。为了解决阻碍回溯的“对象引用”机制，将 immutable应用到了前端。这下所有状态都不会被修改，基于此的redux-dev-tools提高了开发体验。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>代码书写啰嗦，造成代码冗余。</li>\n<li>函数式编程对于习惯于面向对象思维的开发人员比较难接受。</li>\n</ol>\n","prev":{"title":"前端数据流管理模式（三）——Vuex篇（附源码解析）","slug":"前端数据流管理模式（三）——Vuex篇（附源码解析）"},"next":{"title":"前端数据流管理模式（一）——Flux篇","slug":"前端数据流管理模式（一）——Flux篇"}}