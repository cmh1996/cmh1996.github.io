{"title":"前端数据流管理模式（二）——Redux篇","date":"2018-04-29T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1524652630664&di=23d9d07af5ac73567091c176ab06cda5&imgtype=0&src=http%3A%2F%2Fbpic.ooopic.com%2F16%2F72%2F90%2F16729077-e888256f82a58a5d8d62ddb535fd0f5d.jpg","excerpt":"","slug":"前端数据流管理模式（二）——Redux篇","comments":true,"dropcap":false,"tags":["js","前端数据流"],"categories":["js"],"updated":"2018-04-27T08:10:19.762Z","content":"<h2 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h2><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理，属于Flux模式的具体实现之一，核心理念是在初始状态上依次叠加后续的变更，所得的就是当前的状态。</p>\n<hr>\n<h3 id=\"Redux各部分职能\"><a href=\"#Redux各部分职能\" class=\"headerlink\" title=\"Redux各部分职能\"></a>Redux各部分职能</h3><ul>\n<li><p>Action：触发改变store中的state的唯一方法，它通过store.dispatch来将action传到store中。</p>\n</li>\n<li><p>Reducer：action只是描述事件的简单对象，而reducer会说明怎么更新state。reducer是一个纯函数：（(prevState,action)=&gt;newState）。因此你不能在reducer中执行这些操作：修改传入的参数；执行有副作用的操作；调用非纯函数（如Date.now(),Math.random()等等）。</p>\n</li>\n<li><p>Store：存放整个应用的state，并将action和reducer联系起来。store可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。Redux应用只有一个单一的store。当需要拆分数据处理逻辑时，你应该使用 reducer 组合而不是创建多个 store。它提供了以下四个方法：</p>\n<ol>\n<li>dispatch:用于action的分发。在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。</li>\n<li>subscribe：监听state的变化。这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。 let unsubscribe = store.subscribe(() =&gt; {console.log(‘state发生了变化’)})</li>\n<li>getState：获取store中的state。当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。</li>\n<li>replaceReducer:替换reducer，改变state修改的逻辑。</li>\n</ol>\n</li>\n<li><p>View：触发action以改变state，以及接收state数据以渲染界面。以react视图层为例，react通过react-redux把store绑定到视图上。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"Redux流程\"><a href=\"#Redux流程\" class=\"headerlink\" title=\"Redux流程\"></a>Redux流程</h3><p><img src=\"https://pic4.zhimg.com/v2-657d3433e0e6b2b8a029aa7bc331a841_r.jpg\" alt=\"Redux流程示意图\"></p>\n<p><strong>一、初始化</strong></p>\n<ol>\n<li>创建好store。根reducer通过combineReducers()合并了reducers，然后作为参数传入createStore()中，生成唯一的store。</li>\n<li>建立store与组件间的通信。通过Provider组件建立联系，Provider实质上是创建了一个用于更新视图的网络，智能组件通过connect()连入网络，以获取state更新。</li>\n<li>在组件中准备好action的回调函数。 为了让木偶组件更容易处理动作，智能组件可以使用bindActionCreators()来设置action回调函数。 这样，他们可以将回调函数传递给木偶组件。</li>\n</ol>\n<p><strong>二、触发数据流</strong></p>\n<ol>\n<li>视图发出一个action，actionCreator将它格式化并返回它。</li>\n<li>这个action要么被自动dispatch（使用了bindActionCreators()），要么由view手动dispatch。</li>\n<li>store接收到这个action后，将当前的状态树和action传给了根reducer。</li>\n<li>根reducer将整个状态树分割成一个个小块，然后将某个小块分发给知道该怎么处理这部分内容的子reducer。</li>\n<li>子reducer将传入的一小块状态树进行拷贝，然后在这个副本上进行修改，最终将修改后的副本返回给根reducer。</li>\n<li>根reducer将子reducer返回过来的部分再次组合成一棵新的状态树，然后把它交给store，store就会把当前的状态置为这棵最新的状态树。</li>\n<li>store告诉view状态更新了，view让store把更新的状态传过去，之后view触发rerender进行重新渲染。</li>\n</ol>\n<hr>\n<h3 id=\"Redux三大原则\"><a href=\"#Redux三大原则\" class=\"headerlink\" title=\"Redux三大原则\"></a>Redux三大原则</h3><ul>\n<li>单一数据源：整个应用的状态state都是存储在一棵树上，并且这棵状态树只存在于唯一一个store中。</li>\n<li>state是只读的：对state的修改的唯一做法是触发action，不能直接修改state。</li>\n<li>用纯函数执行修改：reducer根据旧状态和传进来的action来生成一个新的state，不直接修改state。<br>（ps：纯函数是什么？<br>纯函数就是有相同输入值时只会产生相同的输出的函数，而且纯函数中不包含任何产生副作用的语句。）</li>\n</ul>\n<hr>\n<h3 id=\"Redux的中间件\"><a href=\"#Redux的中间件\" class=\"headerlink\" title=\"Redux的中间件\"></a>Redux的中间件</h3><p><strong>填坑中</strong><br>控制异步dispatch，分离副作用</p>\n<p>社区出现了很多方案对 redux 异步做支持，从 redux-thunk 到 redux-saga，redux 带来的异步隔离思想也逐渐深入人心。</p>\n<hr>\n<h3 id=\"Immutable不变数据\"><a href=\"#Immutable不变数据\" class=\"headerlink\" title=\"Immutable不变数据\"></a>Immutable不变数据</h3><p><strong>填坑中</strong><br><a href=\"https://www.zhihu.com/question/28016223/answer/50292748\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/28016223/answer/50292748</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/20295971\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/20295971</a></p>\n<hr>\n<h3 id=\"连接React和Redux的桥梁：React-Redux\"><a href=\"#连接React和Redux的桥梁：React-Redux\" class=\"headerlink\" title=\"连接React和Redux的桥梁：React-Redux\"></a>连接React和Redux的桥梁：React-Redux</h3><p><img src=\"https://raw.githubusercontent.com/bailicangdu/react-pxq/master/screenshot/all_redux.png\" alt=\"redux配合react流程示意图\"></p>\n<h4 id=\"react-redux主要提供了这么两个方法：\"><a href=\"#react-redux主要提供了这么两个方法：\" class=\"headerlink\" title=\"react-redux主要提供了这么两个方法：\"></a>react-redux主要提供了这么两个方法：</h4><ol>\n<li><p>provider。相当于一个高阶组件，包在整个组件树的最外层，让所有子孙组件都能使用connect来绑定store。它利用了 React 的 context 这一特性，只要在最外层的组件实现一个 getChildContext这个方法（React内置的），返回一个对象，内部的组件都可以通过 this.context 拿到这个对象。</p>\n</li>\n<li><p>connect。若一个组件想响应状态的变化，就把自己作为参数传给connect。<br>我们先看一下 connect 一般情况下是怎么使用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default connect(mapStateToProps, mapDispatchToProps)(MyComponent)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>首先，export 出去的是一个增强过的 react 组件，也就是说 connect(mapStateToProps, mapDispatchToProps) 第一步首先返回了一个高阶组件。connect()()有两次执行，那么 connect 第二步具体做了什么呢？被这样包裹了一层之后，相应的组件变成了 Container / Smart Component，可以通过 this.props 来获取 store 里的 state，以及 dispatch 这个方法。这样一来，store.state 的更新也就触发了 this.props 的更新，继而触发了容器组件的 re-render。所以，connect 第二步就是把 mapStateToProps 和 mapDispatchToProps 里的返回的属性，以及本身的 props 一起，作为 props 传递给了被包裹的组件。<br>那么，connect 是怎么做到监听 store 变化的呢？答案是用到了Redux的subscribe这个API。综上，connect的内部应该是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function connect(mapStateToProps, mapDispatchToProps) &#123;</span><br><span class=\"line\">  return function createHOC(WrappedComponent) &#123;</span><br><span class=\"line\">    class Connect extends React.Component &#123;</span><br><span class=\"line\">      constructor(props, context) &#123;</span><br><span class=\"line\">        this.store = context.store // &lt;Provider /&gt; 提供</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      componentDidMount() &#123;</span><br><span class=\"line\">        this.unsubscribe = this.store.subscribe(this.handleChange.bind(this))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      componentWillUnmount() &#123;</span><br><span class=\"line\">        this.unsubscribe()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      handleChange() &#123;</span><br><span class=\"line\">        this.forceUpdate()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">          &lt;WrappedComponent </span><br><span class=\"line\">            &#123;...this.props&#125;</span><br><span class=\"line\">            &#123;...mapStateToProps(this.store.getState(), this.props)&#125;</span><br><span class=\"line\">            &#123;...mapDispatchToProps(this.store.dispatch, this.props)&#125;</span><br><span class=\"line\">          /&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Connect.displayName = `Connect($&#123;WrappedComponent.name </span><br><span class=\"line\">                              || WrappedComponent.displayName&#125;)`</span><br><span class=\"line\">    return Connect</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"Redux和Flux的区别\"><a href=\"#Redux和Flux的区别\" class=\"headerlink\" title=\"Redux和Flux的区别\"></a>Redux和Flux的区别</h3><ol>\n<li>Redux只有一个store，且在reducer中执行更新逻辑；Flux有多个store且在store中执行更新逻辑。</li>\n<li>Redux没有dispatcher，它是通过reducer来处理数据（reducer是一个纯函数，(prevState,action)=&gt;newState）。在Redux中可能有多个reducer，单个reducer负责维护应用整体state树中的某一部分，多个reducer通过combineReducers合成一个根reducer来维护整个state。</li>\n<li>Redux概念太超前了，一步到位强制把副作用隔离掉了，但自己又没有深入解决带来的代码冗余问题。</li>\n</ol>\n<hr>\n<h3 id=\"Redux优缺点\"><a href=\"#Redux优缺点\" class=\"headerlink\" title=\"Redux优缺点\"></a>Redux优缺点</h3><p>优点：</p>\n<ol>\n<li>纯函数的开发模式，无副作用。</li>\n<li>单向数据流流动自然清晰，任何的dispatch都会通知到reducer来处理，增强更新粒度可控性。</li>\n<li>利用中间件的模式来解决异步带来的副作用问题。</li>\n<li>可时间回溯。为了解决阻碍回溯的“对象引用”机制，将 immutable应用到了前端。这下所有状态都不会被修改，基于此的redux-dev-tools提高了开发体验。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>代码书写啰嗦，造成代码冗余。</li>\n<li>函数式编程对于习惯于面向对象思维的开发人员比较难接受。</li>\n</ol>\n","prev":{"title":"前端数据流管理模式（三）——Vuex篇（附源码解析）","slug":"前端数据流管理模式（三）——Vuex篇（附源码解析）"},"next":{"title":"前端数据流管理模式（一）——Flux篇","slug":"前端数据流管理模式（一）——Flux篇"}}