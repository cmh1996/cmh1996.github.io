{"title":"深入浅出Rxjs学习笔记","date":"2018-10-21T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1540231499310&di=e139e47cb3a3da3b6a50880d16f850e0&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20180617%2Fcb3200b5269f4998b8966f9295fa0b21.jpeg","excerpt":"","slug":"深入浅出Rxjs学习笔记","comments":true,"dropcap":false,"tags":["阅读笔记","Rxjs"],"categories":["js"],"updated":"2018-10-22T16:19:12.863Z","content":"<h2 id=\"深入浅出Rxjs\"><a href=\"#深入浅出Rxjs\" class=\"headerlink\" title=\"深入浅出Rxjs\"></a>深入浅出Rxjs</h2><p>RxJS，简单来说，它将一切数据，包括HTTP请求，DOM事件或者普通数据等包装成流的形式，然后用强大丰富的操作符对流进行处理，使你能以同步编程的方式处理异步数据，并组合不同的操作符来轻松优雅的实现你所需要的功能。</p>\n<h2 id=\"零、举个栗子\"><a href=\"#零、举个栗子\" class=\"headerlink\" title=\"零、举个栗子\"></a>零、举个栗子</h2><p>先从几个例子来认识一下Rxjs的书写方式</p>\n<h3 id=\"1-测点击时间，然后上报给服务器\"><a href=\"#1-测点击时间，然后上报给服务器\" class=\"headerlink\" title=\"1.测点击时间，然后上报给服务器\"></a>1.测点击时间，然后上报给服务器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const mouseDown$ = Rx.Observable.fromEvent(this.btn.current, &quot;mousedown&quot;);</span><br><span class=\"line\">const mouseUp$ = Rx.Observable.fromEvent(this.btn.current, &quot;mouseup&quot;);</span><br><span class=\"line\">const holdTime$ = mouseUp$</span><br><span class=\"line\">                    .timestamp()</span><br><span class=\"line\">                    .withLatestFrom(mouseDown$.timestamp(), (muEvent, mdEvent) =&gt; &#123;</span><br><span class=\"line\">                        return muEvent.timestamp - mdEvent.timestamp;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">holdTime$.subscribe((ms) =&gt; &#123;</span><br><span class=\"line\">    console.log(ms);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">holdTime$.flatMap((ms) =&gt; &#123;</span><br><span class=\"line\">    return Rx.Observable.ajax(&quot;as&quot; + ms);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.subscribe((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"2-普通observable推送给observer\"><a href=\"#2-普通observable推送给observer\" class=\"headerlink\" title=\"2.普通observable推送给observer\"></a>2.普通observable推送给observer</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ob$ = Rx.Observable.create((observer: any) =&gt; &#123;</span><br><span class=\"line\">    let num: number = 0;</span><br><span class=\"line\">    const timer = setInterval(() =&gt; &#123;</span><br><span class=\"line\">        if (num &gt; 3) &#123;</span><br><span class=\"line\">            clearInterval(timer);</span><br><span class=\"line\">            observer.error(&quot;wrong&quot;);</span><br><span class=\"line\">            observer.complete();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        observer.next(++num);</span><br><span class=\"line\">    &#125;, 1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">const subscription = ob$</span><br><span class=\"line\">    .filter((val: number) =&gt; &#123;</span><br><span class=\"line\">        return val &gt; 2;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .map((val: number) =&gt; &#123;</span><br><span class=\"line\">        return val * 2;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .subscribe(</span><br><span class=\"line\">        (val: number) =&gt; &#123;</span><br><span class=\"line\">            console.log(val);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        (err: string) =&gt; &#123;</span><br><span class=\"line\">            console.log(err);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        () =&gt; &#123;</span><br><span class=\"line\">            console.log(&quot;end&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    subscription.unsubscribe();</span><br><span class=\"line\">&#125;, 6000);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3-React-Rxjs版计数器\"><a href=\"#3-React-Rxjs版计数器\" class=\"headerlink\" title=\"3.React+Rxjs版计数器\"></a>3.React+Rxjs版计数器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default class Index extends Component&lt;IProps, IState&gt; &#123;</span><br><span class=\"line\">    public sub$: any;</span><br><span class=\"line\">    constructor(props: IProps) &#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            count: 0</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        this.sub$ = new Subject();</span><br><span class=\"line\">        this.sub$</span><br><span class=\"line\">            .scan((cur: number, sum: number) =&gt; &#123;</span><br><span class=\"line\">                return cur + sum;</span><br><span class=\"line\">            &#125;, 0)</span><br><span class=\"line\">            .subscribe((val: number) =&gt; &#123;</span><br><span class=\"line\">                this.setState(&#123;</span><br><span class=\"line\">                    count: val</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public countFn(num: number) &#123;</span><br><span class=\"line\">        this.sub$.next(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;div className=&quot;Index&quot;&gt;</span><br><span class=\"line\">                &lt;span&gt;&#123;this.state.count&#125;&lt;/span&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;this.countFn.bind(this, -1)&#125;&gt;-&lt;/button&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;this.countFn.bind(this, 1)&#125;&gt;+&lt;/button&gt;</span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"一、observable介绍\"><a href=\"#一、observable介绍\" class=\"headerlink\" title=\"一、observable介绍\"></a>一、observable介绍</h2><h3 id=\"4-of\"><a href=\"#4-of\" class=\"headerlink\" title=\"4.of\"></a>4.of</h3><p>同步依次输出的数据源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1 2 3 end</span><br><span class=\"line\">const ob$ = Rx.Observable.of(1, 2, 3);</span><br><span class=\"line\">const sub = ob$.subscribe(</span><br><span class=\"line\">        (val: any) =&gt; console.log(val),</span><br><span class=\"line\">        (err: any) =&gt; console.log(err),</span><br><span class=\"line\">        () =&gt; console.log(&quot;end&quot;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"5-range\"><a href=\"#5-range\" class=\"headerlink\" title=\"5.range\"></a>5.range</h3><p>同步依次输出给定范围值的数据源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1 2 3 4 5 end</span><br><span class=\"line\">const ob$ = Rx.Observable.range(1, 5);</span><br><span class=\"line\">const sub = ob$.subscribe(</span><br><span class=\"line\">        (val: any) =&gt; console.log(val),</span><br><span class=\"line\">        (err: any) =&gt; console.log(err),</span><br><span class=\"line\">        () =&gt; console.log(&quot;end&quot;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"6-generate\"><a href=\"#6-generate\" class=\"headerlink\" title=\"6.generate\"></a>6.generate</h3><p>类似于for循环的数据源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1 3 5 7 end</span><br><span class=\"line\">const ob$ = Rx.Observable.generate(</span><br><span class=\"line\">        1,</span><br><span class=\"line\">        (x) =&gt; x &lt; 8,</span><br><span class=\"line\">        (x) =&gt; x + 2,</span><br><span class=\"line\">        (x) =&gt; x + &quot;&quot;</span><br><span class=\"line\">);</span><br><span class=\"line\">const sub = ob$.subscribe(</span><br><span class=\"line\">        (val: any) =&gt; console.log(val),</span><br><span class=\"line\">        (err: any) =&gt; console.log(err),</span><br><span class=\"line\">        () =&gt; console.log(&quot;end&quot;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"7-repeat\"><a href=\"#7-repeat\" class=\"headerlink\" title=\"7.repeat\"></a>7.repeat</h3><p>重复数据源</p>\n<p>它要明确收到上一个数据源的complete指令(但不会执行)后才会unsubscribe当前的数据源，而开始下一个数据源，所有重复动作完成前是不会执行complete的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//start 1 2 unsubscribe start 1 2 end unsubscribe</span><br><span class=\"line\">const ob$ = Rx.Observable.create((observer: any) =&gt; &#123;</span><br><span class=\"line\">        console.log(&quot;start&quot;);</span><br><span class=\"line\">        setTimeout(() =&gt; observer.next(1), 1000);</span><br><span class=\"line\">        setTimeout(() =&gt; observer.next(2), 2000);</span><br><span class=\"line\">        setTimeout(() =&gt; observer.complete(), 3000);</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">        unsubscribe: () =&gt; &#123;</span><br><span class=\"line\">                console.log(&quot;unsubscribe&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">const re$ = ob$.repeat(2);</span><br><span class=\"line\">const sub = re$.subscribe(</span><br><span class=\"line\">        (val: any) =&gt; console.log(val),</span><br><span class=\"line\">        (err: any) =&gt; console.log(err),</span><br><span class=\"line\">        () =&gt; console.log(&quot;end&quot;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"8-empty\"><a href=\"#8-empty\" class=\"headerlink\" title=\"8.empty\"></a>8.empty</h3><p>空数据源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//end</span><br><span class=\"line\">const ob$ = Rx.Observable.empty();</span><br><span class=\"line\">const sub = ob$.subscribe(</span><br><span class=\"line\">        (val: any) =&gt; console.log(val),</span><br><span class=\"line\">        (err: any) =&gt; console.log(err),</span><br><span class=\"line\">        () =&gt; console.log(&quot;end&quot;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"9-throw\"><a href=\"#9-throw\" class=\"headerlink\" title=\"9.throw\"></a>9.throw</h3><p>直接报错数据源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Error:wrong</span><br><span class=\"line\">const ob$ = Rx.Observable.throw(new Error(&quot;wrong&quot;));</span><br><span class=\"line\">const sub = ob$.subscribe(</span><br><span class=\"line\">        (val: any) =&gt; console.log(val),</span><br><span class=\"line\">        (err: any) =&gt; console.log(err),</span><br><span class=\"line\">        () =&gt; console.log(&quot;end&quot;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"10-never\"><a href=\"#10-never\" class=\"headerlink\" title=\"10.never\"></a>10.never</h3><p>什么都没有数据源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ob$ = Rx.Observable.never();</span><br><span class=\"line\">const sub = ob$.subscribe(</span><br><span class=\"line\">        (val: any) =&gt; console.log(val),</span><br><span class=\"line\">        (err: any) =&gt; console.log(err),</span><br><span class=\"line\">        () =&gt; console.log(&quot;end&quot;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"11-提示\"><a href=\"#11-提示\" class=\"headerlink\" title=\"11.提示\"></a>11.提示</h3><p>never、empty和throw单独使⽤没有意义，但是，在组合Observable对象时，如果需要这些特殊的Observable对象，这三个操作符可以直接使⽤，例如，根据条件是否产⽣出错的数据流如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source$.concat(shouldEndWell ? Observable.empty() : Observable.throw(new Error()));</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"12-interval\"><a href=\"#12-interval\" class=\"headerlink\" title=\"12.interval\"></a>12.interval</h3><p>每隔一段时间推送一次（类似于setinterval）（默认从0开始逐1递增）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//每隔1秒输出一次0 2 4 6 8。。。</span><br><span class=\"line\">const ob$ = Rx.Observable.interval(1000);</span><br><span class=\"line\">ob$</span><br><span class=\"line\">.map((val) =&gt; val * 2)</span><br><span class=\"line\">.subscribe(</span><br><span class=\"line\">        console.log,</span><br><span class=\"line\">        undefined,</span><br><span class=\"line\">        undefined</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"13-timer\"><a href=\"#13-timer\" class=\"headerlink\" title=\"13.timer\"></a>13.timer</h3><p>隔一段时间才推送</p>\n<p>（类似于settimeout，不过它第二个参数是interval，也就是说可以实现interval的功能）（默认从0开始逐1递增）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//等2秒后输出1，然后1秒后输出2，再隔1秒后输出3....</span><br><span class=\"line\">const ob$ = Rx.Observable.timer(2000, 1000);</span><br><span class=\"line\">ob$</span><br><span class=\"line\">.map((val) =&gt; val + 1)</span><br><span class=\"line\">.subscribe(</span><br><span class=\"line\">        console.log,</span><br><span class=\"line\">        undefined,</span><br><span class=\"line\">        undefined</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"14-from\"><a href=\"#14-from\" class=\"headerlink\" title=\"14.from\"></a>14.from</h3><p>包容性极强，可以把参数（字符串、数组、类数组、generator、promise等等）转化为数据源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//a s</span><br><span class=\"line\">const ob$ = Rx.Observable.from(&quot;as&quot;);</span><br><span class=\"line\">const sub = ob$.subscribe(</span><br><span class=\"line\">        console.log,</span><br><span class=\"line\">        undefined,</span><br><span class=\"line\">        undefined</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"14-fromPromise\"><a href=\"#14-fromPromise\" class=\"headerlink\" title=\"14.fromPromise\"></a>14.fromPromise</h3><p>把promise转化为数据源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1</span><br><span class=\"line\">const ob$ = Rx.Observable.fromPromise(</span><br><span class=\"line\">        new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        resolve(1);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\">const sub = ob$.subscribe(</span><br><span class=\"line\">        console.log,</span><br><span class=\"line\">        console.log,</span><br><span class=\"line\">        undefined</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"15-fromEvent\"><a href=\"#15-fromEvent\" class=\"headerlink\" title=\"15.fromEvent\"></a>15.fromEvent</h3><p>事件源转化为数据源（DOM事件和eventEmitter都行）（fromEventPattern略）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ob$ = Rx.Observable.fromEvent(this.btn.current, &quot;click&quot;);</span><br><span class=\"line\">const sub = ob$</span><br><span class=\"line\">.map((e: any) =&gt; e.target.innerText)</span><br><span class=\"line\">.subscribe(</span><br><span class=\"line\">        console.log</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"16-ajax\"><a href=\"#16-ajax\" class=\"headerlink\" title=\"16.ajax\"></a>16.ajax</h3><p>rxjs的ajax</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ob$ = Rx.Observable.fromEvent(this.btn.current, &quot;click&quot;);</span><br><span class=\"line\">ob$.subscribe(</span><br><span class=\"line\">        () =&gt; &#123;</span><br><span class=\"line\">        Rx.Observable.ajax(&quot;https://api.github.com/repos/ReactiveX/rxjs&quot;)</span><br><span class=\"line\">        .subscribe((res) =&gt; &#123;</span><br><span class=\"line\">            console.log(&quot;rxjs有&quot; + res.response.stargazers_count + &quot;颗星&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"17-repeatWhen\"><a href=\"#17-repeatWhen\" class=\"headerlink\" title=\"17.repeatWhen\"></a>17.repeatWhen</h3><p>控制何时执行重复获取数据源这个动作，次数为无限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//123一秒后123一秒后123.。。</span><br><span class=\"line\">const src$ = Rx.Observable.of(1, 2, 3);</span><br><span class=\"line\">src$.repeatWhen((notification$) =&gt; &#123;</span><br><span class=\"line\">        //notification$是一个subject</span><br><span class=\"line\">        return notification$.delay(1000);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<p>这样的效果跟楼上一样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src$.repeatWhen(() =&gt; &#123;</span><br><span class=\"line\">        return Rx.Observable.interval(1000);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"18-defer\"><a href=\"#18-defer\" class=\"headerlink\" title=\"18.defer\"></a>18.defer</h3><p>延迟执行（订阅时才会执行代理的数据源）</p>\n<p>⽐如，我们希望通过AJAX来获取服务器端的数据，可是并不想在程序启动阶段就把AJAX请求发送出去，<br>就可以利⽤defer产⽣⼀个Observable对象，当这个Observable对象被subscribe的时候才发送AJAX请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obsFactory = () =&gt; Rx.Observable.ajax(&quot;https://api.github.com/repos/ReactiveX/rxjs&quot;);</span><br><span class=\"line\">const ob$ = Rx.Observable.defer(obsFactory);</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        ob$.subscribe(console.log);</span><br><span class=\"line\">&#125;, 2000);</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"二、合并数据流\"><a href=\"#二、合并数据流\" class=\"headerlink\" title=\"二、合并数据流\"></a>二、合并数据流</h2><h3 id=\"19-concat\"><a href=\"#19-concat\" class=\"headerlink\" title=\"19.concat\"></a>19.concat</h3><p>首尾相连多个数据流</p>\n<p>工作原理：</p>\n<p>假设concat有两个输⼊，分别称为source1$和source2$。<br>source1$产⽣的所有数据全都被concat直接转给了下游，当source1$完结的时候，concat会调⽤source1$.unsubscribe，<br>然后调⽤source2$.subscribe，继续从source2$中抽取数据传给下游。</p>\n<p>PS:concat开始从下⼀个Observable对象抽取数据只能在前⼀个Observable对象完结之后，<br>所以参与到这个concat之中的Observable对象应该都能完结，如果⼀个Observable对象不会完结，<br>那排在后⾯的Observable对象永远没有上场的机会</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ob1$ = Rx.Observable.of(1);</span><br><span class=\"line\">const ob2$ = Rx.Observable.of(2);</span><br><span class=\"line\">const ob3$ = Rx.Observable.of(3);</span><br><span class=\"line\">const concat$ = ob1$.concat(ob2$, ob3$);</span><br><span class=\"line\">concat$.subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"20-merge\"><a href=\"#20-merge\" class=\"headerlink\" title=\"20.merge\"></a>20.merge</h3><p>先到先处理，按时间顺序有序处理合并过来的数据流</p>\n<p>PS:merge的最后一个参数是允许处理的最大数据量，如这里是2，所以后面的ob3$会忽略掉（除非ob1$或者ob2$结束了，才有空位让它执行）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0A 0B 1A 1B 2A 2B...</span><br><span class=\"line\">const ob1$ = Rx.Observable.timer(0, 1000).map((x) =&gt; x + &quot;A&quot;);</span><br><span class=\"line\">const ob2$ = Rx.Observable.timer(500, 1000).map((x) =&gt; x + &quot;B&quot;);</span><br><span class=\"line\">const ob3$ = Rx.Observable.timer(1000, 1000).map((x) =&gt; x + &quot;C&quot;);</span><br><span class=\"line\">ob1$.merge(ob2$, ob3$, 2).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"21-zip\"><a href=\"#21-zip\" class=\"headerlink\" title=\"21.zip\"></a>21.zip</h3><p>拉链式合并数据流，一一对应组合成数组</p>\n<p>吐出数据最少的上游Observable决定了zip产⽣的数据个数。<br>zip在完结的时候，会退订所有的上游数据，所以ob1$这个“永生的”⽣命也会被终结。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//[0,1]一秒后[1,2]一秒后[2,3] end</span><br><span class=\"line\">const ob1$ = Rx.Observable.interval(1000);</span><br><span class=\"line\">const ob2$ = Rx.Observable.of(1, 2, 3);</span><br><span class=\"line\">ob1$.zip(ob2$).subscribe(console.log, undefined, () =&gt; console.log(&quot;end&quot;));</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"22-combineLatest\"><a href=\"#22-combineLatest\" class=\"headerlink\" title=\"22.combineLatest\"></a>22.combineLatest</h3><p>每次数据源有更新就播报一次最新数据</p>\n<p>只有当所有上游Observable对象都完结之后，combineLatest才会给下游⼀个complete信号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//[0,0] [1,0] [1,1] [2,1] [2,2]...</span><br><span class=\"line\">const ob1$ = Rx.Observable.timer(0, 1000);</span><br><span class=\"line\">const ob2$ = Rx.Observable.timer(500, 1000);</span><br><span class=\"line\">const res$ = ob1$.combineLatest(ob2$).subscribe(console.log);</span><br><span class=\"line\"></span><br><span class=\"line\">//[&apos;c&apos;,1] [&apos;c&apos;,2] [&apos;c&apos;,3]</span><br><span class=\"line\">const ob1$ = Rx.Observable.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class=\"line\">const ob2$ = Rx.Observable.of(1, 2, 3);</span><br><span class=\"line\">const res$ = ob1$.combineLatest(ob2$).subscribe(console.log);</span><br><span class=\"line\"></span><br><span class=\"line\">//[&apos;0a&apos;,&apos;0b&apos;] [&apos;1a&apos;,&apos;0b&apos;] [&apos;1a&apos;,&apos;1b&apos;] [&apos;2a&apos;,&apos;1b&apos;] [&apos;2a&apos;,&apos;2b&apos;]...</span><br><span class=\"line\">const original$ = Observable.timer(0, 1000);</span><br><span class=\"line\">const source1$ = original$.map((x) =&gt; x + &quot;a&quot;);</span><br><span class=\"line\">const source2$ = original$.map((x) =&gt; x + &quot;b&quot;);</span><br><span class=\"line\">const result$ = source1$.combineLatest(source2$).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"23-withLatestFrom\"><a href=\"#23-withLatestFrom\" class=\"headerlink\" title=\"23.withLatestFrom\"></a>23.withLatestFrom</h3><p>ob1$才能引发，引发时拿到ob2$的最新数据来组合成数据源（ob2$不能引发）（用弹珠图比较好理解）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//101 203 305 407....</span><br><span class=\"line\">const ob1$ = Rx.Observable.timer(0, 2000).map((x) =&gt; 100 * x);</span><br><span class=\"line\">const ob2$ = Rx.Observable.timer(500, 1000);</span><br><span class=\"line\">const res$ = ob1$.withLatestFrom(ob2$, (a, b) =&gt; a + b).subscribe(console.log);</span><br><span class=\"line\"></span><br><span class=\"line\">//这个可以解决combineLatest对于同步数据的“非同步”问题</span><br><span class=\"line\">//x:12,y:34 x:65,y:87</span><br><span class=\"line\">const event$ = Rx.Observable.fromEvent(document.body, &quot;click&quot;);</span><br><span class=\"line\">const x$ = event$.map((e: any) =&gt; e.x);</span><br><span class=\"line\">const y$ = event$.map((e: any) =&gt; e.y);</span><br><span class=\"line\">const result$ = x$.combineLatest(y$, (x, y) =&gt; `x: $&#123;x&#125;, y: $&#123;y&#125;`).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"24-race\"><a href=\"#24-race\" class=\"headerlink\" title=\"24.race\"></a>24.race</h3><p>谁快谁就占领整条水管</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0a 1a 2a 3a...</span><br><span class=\"line\">const source1$ = Observable.timer(0, 2000).map((x) =&gt; x + &quot;a&quot;);</span><br><span class=\"line\">const source2$ = Observable.timer(500, 1000).map((x) =&gt; x + &quot;b&quot;);</span><br><span class=\"line\">const winner$ = source1$.race(source2$).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"25-startWith\"><a href=\"#25-startWith\" class=\"headerlink\" title=\"25.startWith\"></a>25.startWith</h3><p>在数据源头部插一条数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//-1 0 1 2 3...</span><br><span class=\"line\">const ob$ = Rx.Observable.timer(0, 1000);</span><br><span class=\"line\">const res$ = ob$.startWith(-1).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"26-forkJoin\"><a href=\"#26-forkJoin\" class=\"headerlink\" title=\"26.forkJoin\"></a>26.forkJoin</h3><p>rxjs里面的promise.all</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//3秒后输出[&quot;0a&quot;,&quot;2b&quot;]</span><br><span class=\"line\">const source1$ = Observable.interval(1000).map((x) =&gt; x + &quot;a&quot;).take(1);</span><br><span class=\"line\">const source2$ = Observable.interval(1000).map((x) =&gt; x + &quot;b&quot;).take(3);</span><br><span class=\"line\">const concated$ = Observable.forkJoin(source1$, source2$).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"27-concatAll\"><a href=\"#27-concatAll\" class=\"headerlink\" title=\"27.concatAll\"></a>27.concatAll</h3><p>高阶observable的concat</p>\n<p>只有当第⼀个Observable对象完结的时候，才会去订阅第⼆个内部Observable对象。<br>也就是说，虽然⾼阶Observable对象已经产⽣了第⼆个Observable对象，<br>不代表concatAll会⽴刻去订阅它，因为这个Observable对象是懒执⾏，<br>所以不去订阅⾃然也不会产⽣数据，最后⽣成1:0的时间也就被推迟到产⽣0:1之后。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0:0 0:1 1:0 1:1</span><br><span class=\"line\">const ho$ = Rx.Observable.interval(1000).take(2)</span><br><span class=\"line\">.map((x) =&gt; Observable.interval(1500).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class=\"line\">const res$ = ho$.concatAll().subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"28-mergeAll\"><a href=\"#28-mergeAll\" class=\"headerlink\" title=\"28.mergeAll\"></a>28.mergeAll</h3><p>高阶observable的merge</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0:0 1:0 0:1 1:1</span><br><span class=\"line\">const ho$ = Rx.Observable.interval(1000).take(2)</span><br><span class=\"line\">.map((x) =&gt; Observable.interval(1500).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class=\"line\">const res$ = ho$.mergeAll().subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"29-zipAll\"><a href=\"#29-zipAll\" class=\"headerlink\" title=\"29.zipAll\"></a>29.zipAll</h3><p>高阶observable的zip</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//[0:0,1:0,2:0] [0:1,1:1,2:1]</span><br><span class=\"line\">const ho$ = Rx.Observable.interval(1000).take(3)</span><br><span class=\"line\">.map((x) =&gt; Observable.interval(1500).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class=\"line\">const res$ = ho$.zipAll().subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"30-combineAll\"><a href=\"#30-combineAll\" class=\"headerlink\" title=\"30.combineAll\"></a>30.combineAll</h3><p>高阶observable的combineLatest</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//[0:0,1:0] [0:1,1:0] [0:1,1:1]</span><br><span class=\"line\">const ho$ = Rx.Observable.interval(1000).take(2)</span><br><span class=\"line\">.map((x) =&gt; Observable.interval(1500).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class=\"line\">const res$ = ho$.combineAll().subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"31-switch\"><a href=\"#31-switch\" class=\"headerlink\" title=\"31.switch\"></a>31.switch</h3><p>高阶observable，有新的外部observable产生，就切换到它上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0:0 1:0 2:0 2:1</span><br><span class=\"line\">const ho$ = Observable.interval(1000).take(3)</span><br><span class=\"line\">.map((x) =&gt; Observable.interval(700).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class=\"line\">const res$ = ho$.switch().subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"32-exhaust\"><a href=\"#32-exhaust\" class=\"headerlink\" title=\"32.exhaust\"></a>32.exhaust</h3><p>高阶observable，耗尽一个外部observable，再找下一个来耗尽</p>\n<p>对于这个例⼦，exhaust⾸先从第⼀个内部Observable对象获取数据，<br>然后再考虑后续的内部Observable对象。第⼆个内部Observable⽣不逢时，<br>当它产⽣的时候第⼀个内部Observable对象还没有完结，这时候exhaust会<br>直接忽略第⼆个Observable对象，甚⾄不会去订阅它；第三个内部<br>Observable对象会被订阅并提取数据，是因为在它出现之前，第⼀个内部Observable对象已经完结了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0:0 0:1 2:0 2:1</span><br><span class=\"line\">const ho$ = Observable.interval(1000).take(3)</span><br><span class=\"line\">.map((x) =&gt; Observable.interval(700).map((y) =&gt; x + &quot;:&quot; + y).take(2));</span><br><span class=\"line\">const result$ = ho$.exhaust().subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"三、辅助型操作符\"><a href=\"#三、辅助型操作符\" class=\"headerlink\" title=\"三、辅助型操作符\"></a>三、辅助型操作符</h2><h3 id=\"33-count\"><a href=\"#33-count\" class=\"headerlink\" title=\"33.count\"></a>33.count</h3><p>数据个数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//2</span><br><span class=\"line\">const ob$ = Rx.Observable.timer(1000).concat(Rx.Observable.timer(1000));</span><br><span class=\"line\">const res = ob$.count().subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"34-min-max\"><a href=\"#34-min-max\" class=\"headerlink\" title=\"34.min/max\"></a>34.min/max</h3><p>最小/大的数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//&#123; name: &quot;RxJS&quot;, year: 2011 &#125; &#123; name: &quot;Redux&quot;, year: 2015 &#125;</span><br><span class=\"line\">const intialRelease$ = Observable.of(</span><br><span class=\"line\">        &#123; name: &quot;RxJS&quot;, year: 2011 &#125;,</span><br><span class=\"line\">        &#123; name: &quot;React&quot;, year: 2013 &#125;,</span><br><span class=\"line\">        &#123; name: &quot;Redux&quot;, year: 2015 &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">const min$ = intialRelease$.min((a: any, b: any) =&gt; a.year - b.year).subscribe(console.log);</span><br><span class=\"line\">const max$ = intialRelease$.max((a: any, b: any) =&gt; a.year - b.year).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"35-reduce\"><a href=\"#35-reduce\" class=\"headerlink\" title=\"35.reduce\"></a>35.reduce</h3><p>类似于数组的reduce</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//55</span><br><span class=\"line\">const src$ = Rx.Observable.range(1, 10);</span><br><span class=\"line\">const res$ = src$.reduce((sum, cur) =&gt; sum + cur, 0).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"36-every\"><a href=\"#36-every\" class=\"headerlink\" title=\"36.every\"></a>36.every</h3><p>类似于数组的every</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//false</span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const every$ = source$.every((x) =&gt; x &lt; 3).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"37-find-findIndex\"><a href=\"#37-find-findIndex\" class=\"headerlink\" title=\"37.find/findIndex\"></a>37.find/findIndex</h3><p>类似于数组的find/findIndex</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//4 2</span><br><span class=\"line\">const source$ = Observable.of(3, 1, 4, 1, 5, 9);</span><br><span class=\"line\">const find$ = source$.find((x) =&gt; x % 2 === 0).subscribe(console.log);</span><br><span class=\"line\">const findIndex$ = source$.findIndex((x) =&gt; x % 2 === 0).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"38-isEmpty-defaultIfEmpty\"><a href=\"#38-isEmpty-defaultIfEmpty\" class=\"headerlink\" title=\"38.isEmpty/defaultIfEmpty\"></a>38.isEmpty/defaultIfEmpty</h3><p>检查⼀个上游Observable对象是不是没有吐出任何数据就完结的Observable对象/如果上游是empty，那就输出default值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1秒后输出true,asas</span><br><span class=\"line\">const source$ = Observable.create((observer: any) =&gt; &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; observer.complete(1), 1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">const isEmpty$ = source$.isEmpty().subscribe(console.log);</span><br><span class=\"line\">const deEmpty$ = source$.defaultIfEmpty(&quot;asas&quot;).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"四、过滤型操作符\"><a href=\"#四、过滤型操作符\" class=\"headerlink\" title=\"四、过滤型操作符\"></a>四、过滤型操作符</h2><h3 id=\"39-filter\"><a href=\"#39-filter\" class=\"headerlink\" title=\"39.filter\"></a>39.filter</h3><p>过滤</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0 2 4 6...</span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const even$ = source$.filter((x) =&gt; x % 2 === 0).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"40-first-last\"><a href=\"#40-first-last\" class=\"headerlink\" title=\"40.first/last\"></a>40.first/last</h3><p>取第一个/最后一个到达的数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//[4,2] [10,4]</span><br><span class=\"line\">const source$ = Observable.of(3, 1, 4, 1, 10, 9);</span><br><span class=\"line\">const first$ = source$.first((x) =&gt; x % 2 === 0, (value, index) =&gt; [value, index]).subscribe(console.log);</span><br><span class=\"line\">const last$ = source$.last((x) =&gt; x % 2 === 0, (value, index) =&gt; [value, index]).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"41-take\"><a href=\"#41-take\" class=\"headerlink\" title=\"41.take\"></a>41.take</h3><p>取多少个数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0 1 2</span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const last$ = source$.take(3).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"42-takeLast\"><a href=\"#42-takeLast\" class=\"headerlink\" title=\"42.takeLast\"></a>42.takeLast</h3><p>取后几个数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1 5 9</span><br><span class=\"line\">const source$ = Observable.of(3, 1, 4, 1, 5, 9);</span><br><span class=\"line\">const last3$ = source$.takeLast(3).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"42-takeWhile\"><a href=\"#42-takeWhile\" class=\"headerlink\" title=\"42.takeWhile\"></a>42.takeWhile</h3><p>一直取直到不符合传进去的条件函数为止</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//3 1</span><br><span class=\"line\">const source$ = Observable.of(3, 1, 4, 1, 5, 9);</span><br><span class=\"line\">const last3$ = source$.takeWhile((x) =&gt; x &lt; 4).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"43-takeUntil\"><a href=\"#43-takeUntil\" class=\"headerlink\" title=\"43.takeUntil\"></a>43.takeUntil</h3><p>一直取第一个observable直到第二个observable有数据出来就不取了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0 1</span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const notifier$ = Observable.timer(2500);</span><br><span class=\"line\">const takeUntil$ = source$.takeUntil(notifier$).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"44-skip\"><a href=\"#44-skip\" class=\"headerlink\" title=\"44.skip\"></a>44.skip</h3><p>跳过头几个数据才输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//4秒后才输出3 4 5...</span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const skip$ = source$.skip(3);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"45-skipWhile\"><a href=\"#45-skipWhile\" class=\"headerlink\" title=\"45.skipWhile\"></a>45.skipWhile</h3><p>跳过头几个数据才输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//3秒后才输出2 3 4</span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const skip$ = source$.skipWhile((x) =&gt; x &lt; 2).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"46-skipUntil\"><a href=\"#46-skipUntil\" class=\"headerlink\" title=\"46.skipUntil\"></a>46.skipUntil</h3><p>跳过头几个数据才输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//3秒后才输出2 3 4</span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const notifier$ = Observable.timer(2500);</span><br><span class=\"line\">const skip$ = source$.skipUntil(notifier$).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"47-throttleTime-debounceTime\"><a href=\"#47-throttleTime-debounceTime\" class=\"headerlink\" title=\"47.throttleTime/debounceTime\"></a>47.throttleTime/debounceTime</h3><p>节流，指定时间内只能触发一次;防抖，一定时间内没有新数据流入才触发</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0 3 6...</span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const filter$ = source$.filter((x) =&gt; x % 3 === 0);</span><br><span class=\"line\">const result$ = filter$.throttleTime(2000).subscribe(console.log);</span><br><span class=\"line\"></span><br><span class=\"line\">//2秒后输出0 3 6...</span><br><span class=\"line\">const result2$ = filter$.debounceTime(2000).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"48-throttle\"><a href=\"#48-throttle\" class=\"headerlink\" title=\"48.throttle\"></a>48.throttle</h3><p>以observable节流</p>\n<p>这个过程，相当于throttle每往下游传递⼀个数据，都关上了上下游之间闸门，只有当durationSelector产⽣数据的时候才打开这个闸门。到了2000毫秒的时刻，durationSelector第⼀次被调⽤产⽣的Observable对象终于产⽣了⼀个数据，闸门被打开，source$产⽣的第⼆个数据2正好赶上，被传递给了下游，同时关上闸门，这时候throttle会⽴刻退订上⼀次durationSelector返回的Observable对象，重新⽤数据2作为参数调⽤durationSelector来获得⼀个新的Observable对象，这个新的Observable对象产⽣数据的时候，闸门才会再次打开。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"># call durationSelector with 0</span><br><span class=\"line\">0</span><br><span class=\"line\"># call durationSelector with 2</span><br><span class=\"line\">2</span><br><span class=\"line\"># call durationSelector with 4</span><br><span class=\"line\">4</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const durationSelector = (value: number) =&gt; &#123;</span><br><span class=\"line\">        console.log(`# call durationSelector with $&#123;value&#125;`);</span><br><span class=\"line\">        return Observable.timer(2000);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const result$ = source$.throttle(durationSelector).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"49-debounce\"><a href=\"#49-debounce\" class=\"headerlink\" title=\"49.debounce\"></a>49.debounce</h3><p>以observable防抖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1 2 4 5 7 8 10...</span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const durationSelector = (value: number) =&gt; &#123;</span><br><span class=\"line\">        return Observable.timer(value % 3 === 0 ? 2000 : 1000);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const result$ = source$.debounce(durationSelector).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"50-auditTime-audit\"><a href=\"#50-auditTime-audit\" class=\"headerlink\" title=\"50.auditTime/audit\"></a>50.auditTime/audit</h3><p>可以认为audit是做throttle类似的⼯作，不同的是在“节流时间”范围内，throttle把第⼀个数据传给下游，audit是把最后⼀个数据传给下游。</p>\n<p>audit和auditTime的关系跟throttle/throttleTime一样，就不赘述了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1 3 5.。。</span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const result$ = source$.auditTime(2000).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"51-sampleTime\"><a href=\"#51-sampleTime\" class=\"headerlink\" title=\"51.sampleTime\"></a>51.sampleTime</h3><p>sampleTime会记录每⼀个时间块上游推下来的最后⼀个数据，到了每个时间块结尾，就把这个时间块上游的最后⼀个数据推给下游。表⾯上看sampleTime和auditTime⾮常像，auditTime也会把时间块中最后⼀个数据推给下游，但是对于auditTime时间块的开始是由上游产⽣数据触发的，⽽sampleTime的时间块开始则和上游数据完全⽆关，所以，可以看到sampleTime产⽣的数据序列分布⼗分均匀。</p>\n<p>注意，如果sampleTime发现⼀个时间块内上游没有产⽣数据，那在时间块结尾也不会给下游传递数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//A A B B C C</span><br><span class=\"line\">const source$ = Observable.interval(500).take(2).mapTo(&quot;A&quot;)</span><br><span class=\"line\">        .concat(Observable.interval(1000).take(3).mapTo(&quot;B&quot;))</span><br><span class=\"line\">        .concat(Observable.interval(500).take(3).mapTo(&quot;C&quot;));</span><br><span class=\"line\">const result$ = source$.sampleTime(800).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"52-sample\"><a href=\"#52-sample\" class=\"headerlink\" title=\"52.sample\"></a>52.sample</h3><p>通常sample的参数被称为notifier，当notifier产⽣⼀个数据的时候，sample就从上游拿最后⼀个产⽣的数据传给下游。<br>我们希望点击Sample按钮的时候，id为text的div中会显⽰逝去的时间，这种⽅式可以有很多实现⽅式，利⽤sample的实现⽅式如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const notifer$ = Rx.Observable.fromEvent(document.querySelector(&quot;#sample&quot;), &quot;click&quot;);</span><br><span class=\"line\">const tick$ = Rx.Observable.timer(0, 10).map((x) =&gt; x * 10);</span><br><span class=\"line\">const sample$ = tick$.sample(notifer$);</span><br><span class=\"line\">sample$.subscribe((value) =&gt; &#123;</span><br><span class=\"line\">        document.querySelector(&quot;#text&quot;).innerText = value;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"53-distinct\"><a href=\"#53-distinct\" class=\"headerlink\" title=\"53.distinct\"></a>53.distinct</h3><p>去重</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const source$ = Observable.of(0, 1, 1, 2, 0, 0, 1, 3, 3);</span><br><span class=\"line\">const distinct$ = source$.distinct().subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<p>distinct还提供第⼆个可选的参数flush，第⼆个参数可以是⼀个Observable对象，每当这个Observable对象产⽣数据时，<br>distinct就清空为了判断是否重复而生成的“唯⼀数据集合”，⼀切重来，这样就避免了内存泄露。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const source$ = Observable.interval(100).map((x) =&gt; x % 1000);</span><br><span class=\"line\">const distinct$ = source$.distinct(null, Observable.interval(500));</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"54-distinctUntilChanged\"><a href=\"#54-distinctUntilChanged\" class=\"headerlink\" title=\"54.distinctUntilChanged\"></a>54.distinctUntilChanged</h3><p>拿到⼀个数据不是和全部⽐较，⽽是直接和上⼀个数据⽐较</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0 1 2 0 1 3</span><br><span class=\"line\">const source$ = Observable.of(0, 1, 1, 2, 0, 0, 1, 3, 3);</span><br><span class=\"line\">const distinct$ = source$.distinctUntilChanged();</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"55-ignoreElements\"><a href=\"#55-ignoreElements\" class=\"headerlink\" title=\"55.ignoreElements\"></a>55.ignoreElements</h3><p>忽略所有的元素，这⾥的元素是指上游产⽣的数据，忽略所有上游数据，只关⼼complete和error事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const source$ = Observable.interval(1000).take(5);</span><br><span class=\"line\">const result$ = source$.ignoreElements();</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"56-elementAt\"><a href=\"#56-elementAt\" class=\"headerlink\" title=\"56.elementAt\"></a>56.elementAt</h3><p>elementAt把上游数据当数组，只获取指定下标的那⼀个数据，它的第⼆个参数可以指定没有对应下标数据时的默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//null</span><br><span class=\"line\">const source$ = Observable.of(3, 1, 2);</span><br><span class=\"line\">const result$ = source$.elementAt(3, null);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"57-single\"><a href=\"#57-single\" class=\"headerlink\" title=\"57.single\"></a>57.single</h3><p>检查上游是否只有⼀个满⾜对应条件的数据，如果答案为“是”，就向下游传递这个数据；如果答案为“否”，就向下游传递⼀个异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0</span><br><span class=\"line\">const source$ = Observable.interval(1000).take(2);</span><br><span class=\"line\">const result$ = source$.single((x) =&gt; x % 2 === 0).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"五、转化型操作符\"><a href=\"#五、转化型操作符\" class=\"headerlink\" title=\"五、转化型操作符\"></a>五、转化型操作符</h2><h3 id=\"58-map-mapTo\"><a href=\"#58-map-mapTo\" class=\"headerlink\" title=\"58.map/mapTo\"></a>58.map/mapTo</h3><p>一对一映射转化/转化为某个值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0 2 4 6...</span><br><span class=\"line\">const source$ = Observable.interval(1000);</span><br><span class=\"line\">const result$ = source$.map((x) =&gt; x * 2).subscribe(console.log);</span><br><span class=\"line\">//a a a a...</span><br><span class=\"line\">const result$ = source$.mapTo(&quot;a&quot;).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<p>ps:实现一下map操作符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function map(fn: (val: any) =&gt; any) &#123;</span><br><span class=\"line\">    return new Observable((observer) =&gt; &#123;</span><br><span class=\"line\">        const sub = this.subscribe(&#123;</span><br><span class=\"line\">            next: (val: any) =&gt; &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    observer.next(fn(val));</span><br><span class=\"line\">                &#125; catch (e) &#123;</span><br><span class=\"line\">                    observer.error(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            error: (err: any) =&gt; &#123;</span><br><span class=\"line\">                observer.error(err);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            complete: () =&gt; &#123;</span><br><span class=\"line\">                observer.complete();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            unsubscribe: () =&gt; &#123;</span><br><span class=\"line\">                sub.unsubscribe();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"59-pluck\"><a href=\"#59-pluck\" class=\"headerlink\" title=\"59.pluck\"></a>59.pluck</h3><p>只挑选指定key的value</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//RxJS React React RxJS</span><br><span class=\"line\">const source$ = Observable.of(</span><br><span class=\"line\">        &#123; name: &#123;n:&quot;RxJS&quot;,m:1&#125;, version: &quot;v4&quot; &#125;,</span><br><span class=\"line\">        &#123; name: &#123;n:&quot;React&quot;,m:1&#125;, version: &quot;v15&quot; &#125;,</span><br><span class=\"line\">        &#123; name: &#123;n:&quot;React&quot;,m:1&#125;, version: &quot;v16&quot; &#125;,</span><br><span class=\"line\">        &#123; name: &#123;n:&quot;RxJS&quot;,m:1&#125;, version: &quot;v5&quot; &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">const result$ = source$.pluck(&quot;name&quot;,&quot;n&quot;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"60-windowTime\"><a href=\"#60-windowTime\" class=\"headerlink\" title=\"60.windowTime\"></a>60.windowTime</h3><p>如，windowTime的参数是400，也就会把时间划分为连续的400毫秒长度区块，<br>在每个时间区块中，上游传下来的数据不会直接送给下游，<br>⽽是在该时间区块的开始就新创建⼀个Observable对象推送给下游，<br>然后在这个时间区块内上游产⽣的数据放到这个新创建的Observable对象中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const source$ = Observable.timer(0, 100);</span><br><span class=\"line\">const result$ = source$.windowTime(300).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"61-bufferTime\"><a href=\"#61-bufferTime\" class=\"headerlink\" title=\"61.bufferTime\"></a>61.bufferTime</h3><p>其中的数据是数组形式，bufferTime会把时间区块内的数据缓存，<br>在时间区块结束的时候把所有缓存的数据放在⼀个数组⾥传给下游。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const source$ = Observable.timer(0, 100);</span><br><span class=\"line\">const result$ = source$.bufferTime(300).subscribe(console.log);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"62-windowCount-bufferCount\"><a href=\"#62-windowCount-bufferCount\" class=\"headerlink\" title=\"62.windowCount/bufferCount\"></a>62.windowCount/bufferCount</h3><p>跟上面一样，不同的是参数是数据数量而不是时间</p>\n<hr>\n<h3 id=\"63-windowWhen-bufferWhen\"><a href=\"#63-windowWhen-bufferWhen\" class=\"headerlink\" title=\"63.windowWhen/bufferWhen\"></a>63.windowWhen/bufferWhen</h3><p>略</p>\n<hr>\n<h3 id=\"64-windowToggle-bufferToggle\"><a href=\"#64-windowToggle-bufferToggle\" class=\"headerlink\" title=\"64.windowToggle/bufferToggle\"></a>64.windowToggle/bufferToggle</h3><p>windowToggle和bufferToggle需要两个参数，第⼀个参数opening$是⼀个Observable对象，<br>每当opening$产⽣⼀个数据，代表⼀个缓冲窗⼜的开始，<br>同时，第⼆个参数closingSelector也会被调⽤，⽤来获得缓冲窗⼜结束的通知。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const source$ = Observable.timer(0, 100);</span><br><span class=\"line\">const openings$ = Observable.timer(0, 400);</span><br><span class=\"line\">const closingSelector = (value) =&gt; &#123;</span><br><span class=\"line\">        return value % 2 === 0 ? Observable.timer(200) : Observable.timer(100);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const result$ = source$.windowToggle(openings$, closingSelector);</span><br></pre></td></tr></table></figure>\n<p>其中，opening$每400毫秒产⽣⼀个数据，所以每400毫秒就会有⼀个缓冲区间开始。<br>每当opening$产⽣⼀个数据时，closingSelector就会被调⽤返回控制对应缓冲区间结束的Observable对象，<br>如果参数为偶数，就会延时200毫秒产⽣⼀个数据，否则就延时100毫秒产⽣⼀个数据。</p>\n<hr>\n<h3 id=\"65-window-buffer\"><a href=\"#65-window-buffer\" class=\"headerlink\" title=\"65.window/buffer\"></a>65.window/buffer</h3><p>它只⽀持⼀个Observable类型的参数，称为notifier$，<br>每当notifer$产⽣⼀个数据，既是前⼀个缓存窗⼜的结束，也是后⼀个缓存窗⼜的开始。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const source$ = Observable.timer(0, 100);</span><br><span class=\"line\">const notifer$ = Observable.timer(400, 400);</span><br><span class=\"line\">const result$ = source$.window(notifer$);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"66-concatMap\"><a href=\"#66-concatMap\" class=\"headerlink\" title=\"66.concatMap\"></a>66.concatMap</h3><p>高阶observable的map的concat形态（外层observable处理完自己的内层后才到下一个外层）</p>\n<p>拖拽例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const box = document.querySelector(&quot;#box&quot;);</span><br><span class=\"line\">const mouseDown$ = Rx.Observable.fromEvent(box, &quot;mousedown&quot;);</span><br><span class=\"line\">const mouseUp$ = Rx.Observable.fromEvent(box, &quot;mouseup&quot;);</span><br><span class=\"line\">const mouseOut$ = Rx.Observable.fromEvent(box, &quot;mouseout&quot;);</span><br><span class=\"line\">const mouseMove$ = Rx.Observable.fromEvent(box, &quot;mousemove&quot;);</span><br><span class=\"line\">const drag$ = mouseDown$.concatMap((startEvent) =&gt; &#123;</span><br><span class=\"line\">        const initLeft = box.offsetLeft;</span><br><span class=\"line\">        const initTop = box.offsetTop;</span><br><span class=\"line\">        const stop$ = mouseOut$.merge(mouseUp$);</span><br><span class=\"line\">        return mouseMove$.takeUntil(stop$).map((e) =&gt; &#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">                x: e.x - startEvent.x + initLeft,</span><br><span class=\"line\">                y: e.y - startEvent.y + initTop</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">drag$.subscribe((e) =&gt; &#123;</span><br><span class=\"line\">        box.style.left = e.x + &quot;px&quot;;</span><br><span class=\"line\">        box.style.top = e.y + &quot;px&quot;;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"67-mergeMap\"><a href=\"#67-mergeMap\" class=\"headerlink\" title=\"67.mergeMap\"></a>67.mergeMap</h3><p>高阶observable的map的merge形态<br>（mergeMap对于每个内部Observable对象直接合并，也就是任何内部Observable对象中的数据，来⼀个给下游传⼀个，不做任何等待。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const sendButton = document.querySelector(&quot;#send&quot;);</span><br><span class=\"line\">Rx.Observable.fromEvent(sendButton, &quot;click&quot;)</span><br><span class=\"line\">    .mergeMap(() =&gt; &#123;</span><br><span class=\"line\">        return Rx.Observable.ajax(apiUrl);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .subscribe((result) =&gt; &#123;</span><br><span class=\"line\">        // 正常处理AJAX返回的结果</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"68-switchMap\"><a href=\"#68-switchMap\" class=\"headerlink\" title=\"68.switchMap\"></a>68.switchMap</h3><p>⽤户点击按钮，⼀个AJAX请求发出去，这时候RxJS的star数为9907，不过因为⽹络速度⽐较慢的原因，<br>这个AJAX请求的延时⽐较⼤，⽤户等不及了，又点了⼀次按钮，又⼀个AJAX请求发出去了。<br>这时候，第⼀个AJAX请求已经获得了数据9907，⽽恰在此时世界某个地⽅的开发者也很喜欢RxJS，点击了RxJS项⽬的star，<br>于是RxJS的star数变成了9908，然后，⽤户触发的第⼆个AJAX也到了，拿到了9908的数据。只要涉及输⼊输出，延时就是不可预期的，<br>先发出去的AJAX未必就会先返回，完全有可能第⼆个AJAX请求的结果⽐第⼀个更早返回，这时候使⽤mergeMap就会出问题了，<br>⽤户会先看到9908，然后又会被第⼀个AJAX请求的返回修改为9907，毫⽆疑问，9907并不是最新的数据。<br>switchMap这个特点适⽤于总是要获取最新AJAX请求返回的应⽤，<br>只需要把上⾯使⽤mergeMap来合并AJAX请求的代码中改为⽤switchMap就可以了。</p>\n<hr>\n<h3 id=\"69-exhaustMap\"><a href=\"#69-exhaustMap\" class=\"headerlink\" title=\"69.exhaustMap\"></a>69.exhaustMap</h3><p>exhaustMap对数据的处理策略和switchMap正好相反，先产⽣的内部Observable优先级总是更⾼，<br>后产⽣的内部Observable对象被利⽤的唯⼀机会，就是之前的内部Observable对象已经完结。</p>\n<hr>\n<h3 id=\"70-concatMapTo-mergeMapTo-switchMapTo\"><a href=\"#70-concatMapTo-mergeMapTo-switchMapTo\" class=\"headerlink\" title=\"70.concatMapTo/mergeMapTo/switchMapTo\"></a>70.concatMapTo/mergeMapTo/switchMapTo</h3><p>作用跟楼上一样，<br>参数直接就是⼀个Observable对象，⽽不是⼀个返回Observable对象的函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const source$ = Observable.interval(200);</span><br><span class=\"line\">const result$ = source$.concatMapTo(Observable.interval(100).take(5));</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"71-groupBy\"><a href=\"#71-groupBy\" class=\"headerlink\" title=\"71.groupBy\"></a>71.groupBy</h3><p>可以把groupBy看作⼀个分发器，对于上游推送下来的任何数据，检查这个数据的key值，<br>如果这个key值是第⼀次出现，就产⽣⼀个新的内部Observable对象，同时这个数据就是内部Observable对象的第⼀个数据；<br>如果key值已经出现过，就直接把这个数据塞给对应的内部Observable对象。</p>\n<p>例子：事件委托，分class来处理元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const click$ = Rx.Observable.fromEvent(document, &quot;click&quot;);</span><br><span class=\"line\">const groupByClass$ = click$.groupBy((event) =&gt; event.target.className);</span><br><span class=\"line\">groupByClass$.filter((value) =&gt; value.key === &quot;foo&quot;).mergeAll().subscribe(fooEventHandler);</span><br><span class=\"line\">groupByClass$.filter((value) =&gt; value.key === &quot;bar&quot;).mergeAll().subscribe(barEventHandler);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"72-partition\"><a href=\"#72-partition\" class=\"headerlink\" title=\"72.partition\"></a>72.partition</h3><p>partition接受⼀个判定函数作为参数，对上游的每个数据进⾏判定，<br>满⾜条件的放⼀个Observable对象，不满⾜条件的放到另⼀个Observable对象，就这样⼀分⼆。<br>partition是RxJS提供的操作符中唯⼀的不返回Observable对象的操作符，它返回的是⼀个数组，<br>包含两个元素，第⼀个元素是容纳满⾜判定条件的Observable对象，第⼆个元素⾃然是不满⾜判定条件的Observable对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const source$ = Observable.timer(0, 100);</span><br><span class=\"line\">const [even$, odd$] = source$.partition((x) =&gt; x % 2 === 0);</span><br><span class=\"line\">even$.subscribe((value) =&gt; console.log(&quot;even:&quot;, value));</span><br><span class=\"line\">odd$.subscribe((value) =&gt; console.log(&quot;odd:&quot;, value));</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"73-scan\"><a href=\"#73-scan\" class=\"headerlink\" title=\"73.scan\"></a>73.scan</h3><p>累加操作符</p>\n<p>scan和reduce的区别在于scan对上游每⼀个数据都会产⽣⼀个规约结果，⽽reduce是对上游所有数据进⾏规约，<br>reduce最多只给下游传递⼀个数据，如果上游数据永不完结，那reduce也永远不会产⽣数据，<br>⽽scan完全可以处理⼀个永不完结的上游Observable对象。<br>scan可能是RxJS中对构建交互式应⽤程序最重要的⼀个操作符，因为它能够维持应⽤的当前状态，<br>⼀⽅⾯可以根据数据流持续更新这些状态，另⼀⽅⾯可以持续把更新的状态传给另⼀个数据流⽤来做必要处理。<br>在使⽤RxJS的应⽤中，如果需要维持应⽤的状态，scan是⾸选。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//0 1 3 6 .。。</span><br><span class=\"line\">const source$ = Observable.interval(100);</span><br><span class=\"line\">const result$ = source$.scan((accumulation, value) =&gt; &#123;</span><br><span class=\"line\">        return accumulation + value;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"六、错误处理操作符\"><a href=\"#六、错误处理操作符\" class=\"headerlink\" title=\"六、错误处理操作符\"></a>六、错误处理操作符</h2><h3 id=\"74-catch\"><a href=\"#74-catch\" class=\"headerlink\" title=\"74.catch\"></a>74.catch</h3><p>它接受一个函数参数，这个函数有两个参数，第⼀个参数是error，也就是被捕获的错误，第⼆个参数caught$，代表上游紧邻的那个Observable对象。<br>原本出现4的位置，被catch$⽤8来替换，但是因为发⽣了错误，正常的序列被打断，原本source$应该吐出的5不会有机会⾛到catch$的下游。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1 2 3 8</span><br><span class=\"line\">const source$ = Observable.range(1, 5);</span><br><span class=\"line\">const error$ = source$.map((value) =&gt; &#123;</span><br><span class=\"line\">        if (value === 4) &#123;</span><br><span class=\"line\">        throw new Error(&quot;unlucky number 4&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">const catch$ = error$.catch((err, caught$) =&gt; Observable.of(8));</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"75-retry\"><a href=\"#75-retry\" class=\"headerlink\" title=\"75.retry\"></a>75.retry</h3><p>作⽤就是让上游的Observable重新⾛⼀遍，达到重试的⽬的。这个操作符接受⼀个数值参数number，<br>number⽤于指定重试的次数，如果number为负数或者没有number参数，那么就是⽆限次retry，直到上游不再抛出错误异常为⽌。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1 2 3 1 2 3 1 2 3 8</span><br><span class=\"line\">const source$ = Observable.range(1, 5);</span><br><span class=\"line\">const error$ = source$.map((value) =&gt; &#123;</span><br><span class=\"line\">        if (value === 4) &#123;</span><br><span class=\"line\">        throw new Error(&quot;unlucky number 4&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">const retry$ = error$.retry(2);</span><br><span class=\"line\">const catch$ = retry$.catch((err) =&gt; Observable.of(8));</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"76-retryWhen\"><a href=\"#76-retryWhen\" class=\"headerlink\" title=\"76.retryWhen\"></a>76.retryWhen</h3><p>接受⼀个函数作为参数，这个参数称为notifer，⽤于控制“重试”的节奏和次数，这⽐retry单纯只能控制重试次数要前进⼀步。<br>notifer有⼀个参数名为error$，注意这个参数名后⾯有⼀个$，表⽰它实际上代表的不是⼀个错误，<br>⽽是由⼀组错误组成的Observable对象；notifer返回⼀个Observable对象，当上游扔下来错误的时候，<br>retryWhen就会调⽤notifer，然后根据notifer返回的Observable对象来决定何时重试，<br>这个返回的Observable就是⼀个“节奏控制器”，“节奏控制器”每吐出⼀个数据，就会进⾏⼀次重试。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const source$ = Observable.range(1, 5);</span><br><span class=\"line\">const error$ = source$.map((value) =&gt; &#123;</span><br><span class=\"line\">        if (value === 4) &#123;</span><br><span class=\"line\">        throw new Error(&quot;unlucky number 4&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">const retryWhen$ = error$.retryWhen((err$) =&gt; Observable.interval(1000));</span><br></pre></td></tr></table></figure>\n<p>用retryWhen模拟实现retry</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.prototype.retryCount = function(maxCount) &#123;</span><br><span class=\"line\">        return this.retryWhen((err$) =&gt; &#123;</span><br><span class=\"line\">        return err$.scan((errorCount, err) =&gt; &#123;</span><br><span class=\"line\">                if (errorCount &gt;= maxCount) &#123;</span><br><span class=\"line\">                throw err;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return errorCount + 1;</span><br><span class=\"line\">        &#125;, 0);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"77-finally\"><a href=\"#77-finally\" class=\"headerlink\" title=\"77.finally\"></a>77.finally</h3><p>finally和do操作符很像，它们传⼊的函数⽆法影响数据流，所以要做点事只能通过其他副作⽤，<br>⽐如释放数据流之外的资源，输出⼀个⽇志信息之类。finally和do也有很⼤的不同，<br>finally的参数只在上游数据完结或者出错的时候才执⾏，⼀个数据流中finally只会发挥⼀次作⽤；⽽do是对上游吐出的每个数据均执⾏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const source$ = Observable.range(1, 10);</span><br><span class=\"line\">const error$ = source$.map(throwOnUnluckyNumber);</span><br><span class=\"line\">const final$ = error$</span><br><span class=\"line\">        .retry(3)</span><br><span class=\"line\">        .catch((err) =&gt; Observable.of(8))</span><br><span class=\"line\">        .finally((x) =&gt; console.log(&quot;finally&quot;));</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"七、多播subject\"><a href=\"#七、多播subject\" class=\"headerlink\" title=\"七、多播subject\"></a>七、多播subject</h2><h3 id=\"78-Hot和Cold\"><a href=\"#78-Hot和Cold\" class=\"headerlink\" title=\"78.Hot和Cold\"></a>78.Hot和Cold</h3><p>Observable都具有“懒”的特质，不过Cold更“懒”⼀些，两者的数据管道内逻辑都是只有存在订阅者存在才执⾏，<br>Cold Observable更“懒”体现在，如果没有订阅者，连数据都不会真正产⽣，对于HotObservable，没有订阅者的情况下，数据依然会产⽣，只不过不传⼊数据管道。所以，Cold Observable实现的是单播，Hot Observable实现的多播。</p>\n<p>在RxJS的创建类操作符中，下⾯⼏个产⽣的是Hot Observable</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fromPromise</span><br><span class=\"line\">fromEvent</span><br><span class=\"line\">fromEventPattern</span><br></pre></td></tr></table></figure>\n<p>不难看出，这些产⽣Hot Observable对象的操作符数据源都在外部，或者是来⾃于Promise，<br>或者是来⾃于DOM，或者是来⾃于Event Emitter，真正的数据源和有没有Observer没有任何关系。</p>\n<hr>\n<h3 id=\"79-用subject实现多播\"><a href=\"#79-用subject实现多播\" class=\"headerlink\" title=\"79.用subject实现多播\"></a>79.用subject实现多播</h3><p>既然Subject既有Observable又有Observer的特性，那么，想象⼀下，<br>让⼀个Subject对象成为⼀个Cold Observable对象的下游，其他想要Hot数据源的Observer就不要去订阅那个ColdObservable对象了，<br>⽽是去订阅这个Subject对象。我们知道，Hot Observable可以认为是“⽣产者”独⽴于订阅⾏为之外的Observable，<br>现在，以Subject为中⼼，Subject就是这个Hot Observable，它所订阅的Cold Observable对象就是那个“⽣产者”。<br>Subject同时也是⼀个Observer，作为Observer会接受和消化“⽣产者”推过来的数据，最简单的消化⽅法，<br>就是把数据、错误和完结通知都⼀股脑原样推给Subject⾃⼰的Observer。</p>\n<p>ps:实现makeHot()函数，让上游cold observable变为hot observable</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.prototype.makeHot = function()&#123;</span><br><span class=\"line\">    const cold$ = this;</span><br><span class=\"line\">    const subject = new Subject();</span><br><span class=\"line\">    cold$.subscribe(subject);</span><br><span class=\"line\">    return Observable.create((observer) =&gt; subject.subscribe(observer));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"80-当subject上游有多个observable时需要注意的\"><a href=\"#80-当subject上游有多个observable时需要注意的\" class=\"headerlink\" title=\"80.当subject上游有多个observable时需要注意的\"></a>80.当subject上游有多个observable时需要注意的</h3><p>虽然Subject理论上可以合并多个数据流，但是，因为任何⼀个上游数据流的完结或者出错信息都可以终结Subject对象的⽣命，<br>让Subject来做合并数据流的⼯作显得并不合适。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">observer 1: a</span><br><span class=\"line\">observer 2: a</span><br><span class=\"line\">observer 1: b</span><br><span class=\"line\">observer 2: b</span><br><span class=\"line\">observer 1: a</span><br><span class=\"line\">observer 2: a</span><br><span class=\"line\">*/</span><br><span class=\"line\">const tick1$ = Observable.interval(1000).mapTo(&quot;a&quot;).take(2);</span><br><span class=\"line\">const tick2$ = Observable.interval(1000).mapTo(&quot;b&quot;).take(2);</span><br><span class=\"line\">const subject = new Subject();</span><br><span class=\"line\">tick1$.subscribe(subject);</span><br><span class=\"line\">tick2$.subscribe(subject);</span><br><span class=\"line\">subject.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class=\"line\">subject.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br></pre></td></tr></table></figure>\n<p>因为tick1$是由take产⽣的，也就是说在吐出2个数据之后就会调⽤下游的complete函数，也就是调⽤subject的complete函数。<br>⼀个Subject对象是不能被重复使⽤的，只要complete函数被调⽤，它的⽣命周期也就结束了，再来调⽤它的next函数是不会有任何反应的。<br>tick2$传给下游的第⼆个b，发⽣在tick$完结之后，所以第⼆个数据b传给subject时它已经“死”了，⾃然不会得到任何输出。</p>\n<hr>\n<h3 id=\"81-subject错误处理\"><a href=\"#81-subject错误处理\" class=\"headerlink\" title=\"81.subject错误处理\"></a>81.subject错误处理</h3><p>有意思的是Subject有多个Observer的场景，如果Subject的某个下游数据流产⽣了⼀个错误异常，<br>⽽且这个错误异常没有被Observer处理，那这个Subject其他的Observer都会失败。直观上，<br>我们会觉得Subject对象的各个Observer是相互独⽴的，⼀个Observer没有处理错误异常，不应该影响其他的Observer，<br>但是，实际上并不是如此。</p>\n<p>如果某个observer.next函数调⽤抛出错误异常怎么办呢？结果当然是其他的Observer也会受到牵连，⽆法接收到数据。</p>\n<hr>\n<h3 id=\"82-multicast\"><a href=\"#82-multicast\" class=\"headerlink\" title=\"82.multicast\"></a>82.multicast</h3><p>多播操作符，把cold变成hot，但需要自己手动调用connect才开始多播</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">observer 1: 0</span><br><span class=\"line\">observer 1: 1</span><br><span class=\"line\">observer 2: 1</span><br><span class=\"line\">observer 1: 2</span><br><span class=\"line\">observer 2: 2</span><br><span class=\"line\">*/</span><br><span class=\"line\">const coldSource$ = Observable.interval(1000).take(3);</span><br><span class=\"line\">const tick$ = coldSource$.multicast(new Subject());</span><br><span class=\"line\">tick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        tick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class=\"line\">&#125;, 1500);</span><br><span class=\"line\">tick$.connect();</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"83-refCount\"><a href=\"#83-refCount\" class=\"headerlink\" title=\"83.refCount\"></a>83.refCount</h3><p>自动计数，对Observer的个数进⾏跟踪，当Observer数量⼤于1时订阅上游，<br>当Observer数量减少为0时退订上游，⽽这正是refCount函数的作⽤。也不用手动调用connect。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const coldSource$ = Observable.interval(1000).take(3);</span><br><span class=\"line\">const tick$ = coldSource$.multicast(new Subject()).refCount();</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        tick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class=\"line\">&#125;, 500);</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        tick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class=\"line\">&#125;, 2000);</span><br></pre></td></tr></table></figure>\n<p>不过，如果使⽤refCount，那么对应的multicast往往不能只是接受⼀个Subject对象作为参数，⽽是接受⼀个返回Subject对象的函数作为参数。</p>\n<p>让hot又变成cold，多播管道之间互不影响（因为之前比如说observer1退订了，subject也会退订，这使得observer2也接收不到数据）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">observer 1: 0</span><br><span class=\"line\">observer 1: 1</span><br><span class=\"line\">observer 2: 1</span><br><span class=\"line\">observer 1: 2</span><br><span class=\"line\">observer 2: 2</span><br><span class=\"line\">observer 3: 0</span><br><span class=\"line\">observer 3: 1</span><br><span class=\"line\">observer 3: 2</span><br><span class=\"line\">*/</span><br><span class=\"line\">const subjectFactory = () =&gt; new Subject();</span><br><span class=\"line\">const coldSource$ = Observable.interval(1000).take(3);</span><br><span class=\"line\">const tick$ = coldSource$.multicast(subjectFactory).refCount();</span><br><span class=\"line\">tick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        tick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class=\"line\">&#125;, 1500);</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        tick$.subscribe((value) =&gt; console.log(&quot;observer 3: &quot; + value));</span><br><span class=\"line\">&#125;, 5000);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"84-publish\"><a href=\"#84-publish\" class=\"headerlink\" title=\"84.publish\"></a>84.publish</h3><p>封装版multicast</p>\n<p>实现方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function publish(selector) &#123;</span><br><span class=\"line\">    if (selector) &#123;</span><br><span class=\"line\">        return this.multicast(() =&gt; new Subject(), selector);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return this.multicast(new Subject());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到publish的实现极其简单，也有⼀个可选的selector参数，根据是否有selector⽅法，<br>决定调⽤multicast的时候是使⽤⼀个Subject对象，还是使⽤⼀个产⽣Subject对象的⼯⼚⽅法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">observer 1: 0</span><br><span class=\"line\">observer 1: 1</span><br><span class=\"line\">observer 1: 2</span><br><span class=\"line\">*/</span><br><span class=\"line\">const tick$ = Observable.interval(1000).take(3);</span><br><span class=\"line\">const sharedTick$ = tick$.publish().refCount();</span><br><span class=\"line\">sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class=\"line\">&#125;, 5000);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"85-share\"><a href=\"#85-share\" class=\"headerlink\" title=\"85.share\"></a>85.share</h3><p>封装版multicast</p>\n<p>实现方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.prototype.share = function share() &#123;</span><br><span class=\"line\">        This.multicast(() =&gt; new Subject()).refCount();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>考虑到Observer增加然后减少为0之后，新的Observer添加也希望获得数据的场景，<br>传递给multicast的不是Subject对象，⽽是产⽣Subject对象的⼯⼚函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">observer 1: 0</span><br><span class=\"line\">observer 1: 1</span><br><span class=\"line\">observer 1: 2</span><br><span class=\"line\">observer 2: 0</span><br><span class=\"line\">observer 2: 1</span><br><span class=\"line\">observer 2: 2</span><br><span class=\"line\">*/</span><br><span class=\"line\">const tick$ = Observable.interval(1000).take(3);</span><br><span class=\"line\">const sharedTick$ = tick$.share();</span><br><span class=\"line\">sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class=\"line\">&#125;, 5000);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"86-publishLast和AsyncSubject\"><a href=\"#86-publishLast和AsyncSubject\" class=\"headerlink\" title=\"86.publishLast和AsyncSubject\"></a>86.publishLast和AsyncSubject</h3><p>多播的是上游的最后⼀个数据。</p>\n<p>AsyncSubject对象表现得“可以重⽤”，即使上游Cold Observable完结时候调⽤了AsyncSubject对象的complete⽅法，<br>之后添加的Observer依然可以从AsyncSubject中获得数据，⽽且是⽴刻获得数据，当然，这⽴刻获得数据就是上游吐出的最后⼀个数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">observer 1: 2</span><br><span class=\"line\">observer 2: 2</span><br><span class=\"line\">*/</span><br><span class=\"line\">const tick$ = Observable.interval(1000).take(3);</span><br><span class=\"line\">const sharedTick$ = tick$.publishLast().refCount();</span><br><span class=\"line\">sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class=\"line\">&#125;, 5000);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"87-pubishReplay和ReplaySubject\"><a href=\"#87-pubishReplay和ReplaySubject\" class=\"headerlink\" title=\"87.pubishReplay和ReplaySubject\"></a>87.pubishReplay和ReplaySubject</h3><p>replay就是把Observable对象吐出的数据重新⾛⼀遍，⽽不是让数据管道重新产⽣⼀遍数据，<br>参数接受一个n，n是relay后几个数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">source 0</span><br><span class=\"line\">observer 1: 0</span><br><span class=\"line\">source 1</span><br><span class=\"line\">observer 1: 1</span><br><span class=\"line\">source 2</span><br><span class=\"line\">observer 1: 2</span><br><span class=\"line\">observer 2: 1</span><br><span class=\"line\">observer 2: 2</span><br><span class=\"line\">*/</span><br><span class=\"line\">const tick$ = Observable.interval(1000)</span><br><span class=\"line\">        .take(3)</span><br><span class=\"line\">        .do((x) =&gt; console.log(&quot;source &quot;, x));</span><br><span class=\"line\">const sharedTick$ = tick$.publishReplay(2).refCount();</span><br><span class=\"line\">sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class=\"line\">&#125;, 5000);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"88-publishBehavior和BehaviorSubject\"><a href=\"#88-publishBehavior和BehaviorSubject\" class=\"headerlink\" title=\"88.publishBehavior和BehaviorSubject\"></a>88.publishBehavior和BehaviorSubject</h3><p>可以提供⼀个“默认数据”，当添加Observer的时候，即使上游还没有吐出数据Observer也会⽴即获得这个“默认数据”；<br>⽽且，这个“默认数据”总是会被上游吐出的最新数据替代，也就是说，任何新添加的Observer都有⼀个⼤礼包在等着他，<br>这个⼤礼包要么是指定的“默认数据”，要么就是上游吐出的最新数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">observer 1: -1</span><br><span class=\"line\">observer 1: 0</span><br><span class=\"line\">observer 1: 1</span><br><span class=\"line\">observer 2: 1</span><br><span class=\"line\">observer 1: 2</span><br><span class=\"line\">observer 2: 2</span><br><span class=\"line\">*/</span><br><span class=\"line\">const tick$ = Observable.interval(1000).take(3);</span><br><span class=\"line\">const sharedTick$ = tick$.publishBehavior(-1).refCount();</span><br><span class=\"line\">sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 1: &quot; + value));</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 2: &quot; + value));</span><br><span class=\"line\">&#125;, 2500);</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        sharedTick$.subscribe((value) =&gt; console.log(&quot;observer 3: &quot; + value));</span><br><span class=\"line\">&#125;, 5000);</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"八、scheduler，掌握时间调度\"><a href=\"#八、scheduler，掌握时间调度\" class=\"headerlink\" title=\"八、scheduler，掌握时间调度\"></a>八、scheduler，掌握时间调度</h2><h3 id=\"89-在RxJS中，提供了下列Scheduler实例\"><a href=\"#89-在RxJS中，提供了下列Scheduler实例\" class=\"headerlink\" title=\"89.在RxJS中，提供了下列Scheduler实例\"></a>89.在RxJS中，提供了下列Scheduler实例</h3><p>·undefined/null，也就是不指定Scheduler，代表同步执⾏的Scheduler。</p>\n<p>·asap，尽快执⾏的Scheduler。</p>\n<p>·async，利⽤setInterval实现的Scheduler，⽤于基于时间吐出数据的场景。</p>\n<p>·queue，利⽤队列实现的Scheduler，⽤于迭代⼀个⼤的集合的场景。</p>\n<p>·animationFrame，⽤于动画场景的Scheduler。</p>\n<p>RxJS默认选择Scheduler的原则是尽量减少并发运⾏。所以，对于range，就选择undefined；对于很⼤的数据，就选择queue；对于时间相关的操作符⽐如interval，就选择async。<br>asap和async两个Scheduler都是利⽤事件循环来实现异步的效果，两者的不同，就是asap会尽量使⽤Micro Task，⽽async利⽤的是Macro Task。<br>queue这个Scheduler，如果调⽤它的schedule函数式参数delay是0，<br>那它就⽤同步的⽅式执⾏，如果delay参数⼤于0，那queue的表现其实就和async⼀模⼀样。</p>\n<hr>\n<h3 id=\"90-observeOn-subscribeOn（略）\"><a href=\"#90-observeOn-subscribeOn（略）\" class=\"headerlink\" title=\"90.observeOn/subscribeOn（略）\"></a>90.observeOn/subscribeOn（略）</h3><p>调用scheduler的api</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">before subscribe</span><br><span class=\"line\">after subscribe</span><br><span class=\"line\">data：1</span><br><span class=\"line\">data：2</span><br><span class=\"line\">data：3</span><br><span class=\"line\">*/</span><br><span class=\"line\">const source$ = Observable.range(1, 3);</span><br><span class=\"line\">const asapSource$ = source$.observeOn(asap);</span><br><span class=\"line\">console.log(&quot;before subscribe&quot;);</span><br><span class=\"line\">asapSource$.subscribe(</span><br><span class=\"line\">        (value) =&gt; console.log(&quot;data: &quot;, value),</span><br><span class=\"line\">        (error) =&gt; console.log(&quot;error: &quot;, error),</span><br><span class=\"line\">        () =&gt; console.log(&quot;complete&quot;)</span><br><span class=\"line\">);</span><br><span class=\"line\">console.log(&quot;after subscribe&quot;);</span><br></pre></td></tr></table></figure>\n<p>⼀般来说，observeOn在数据流管道接近末尾的位置使⽤，最好就是在调⽤subscribe之前，<br>因为通常RxJS默认的Scheduler已经⾜够合理，如果我们要修改Scheduler，在整个数据管道中只需要修改⼀处就⾜够，<br>既然数据管道中的数据是被Observer使⽤，当然应该在添加Observer的subscribe调⽤之前使⽤observeOn调整Scheduler最合适。</p>\n<hr>\n<h2 id=\"九、调试\"><a href=\"#九、调试\" class=\"headerlink\" title=\"九、调试\"></a>九、调试</h2><h3 id=\"91-提示\"><a href=\"#91-提示\" class=\"headerlink\" title=\"91.提示\"></a>91.提示</h3><p>不要⽤subscribe⽅法来增加输出log的调试代码，如果要增加调试代码，就⼀定要在数据管道中利⽤do这个操作符来增加。<br>这样，就可以在数据管道中不⽤do⽽是⽤debug来增加调试代码，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.prototype.debug = function(fn) &#123;</span><br><span class=\"line\">        if (global.debug) &#123;</span><br><span class=\"line\">        return this.do(fn);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">        return this;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const source$ = original$.debug((x) =&gt; console.log(&quot;source$ data = &quot;, x));</span><br></pre></td></tr></table></figure>","prev":{"title":"canvas世界","slug":"canvas世界"},"next":{"title":"一探Webpack模块化机制","slug":"一探Webpack模块化机制"}}