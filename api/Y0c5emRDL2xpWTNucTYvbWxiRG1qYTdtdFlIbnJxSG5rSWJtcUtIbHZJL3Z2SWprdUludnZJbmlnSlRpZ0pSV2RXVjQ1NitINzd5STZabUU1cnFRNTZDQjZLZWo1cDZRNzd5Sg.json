{"title":"前端数据流管理模式（三）——Vuex篇（附源码解析）","date":"2018-04-29T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1524651452546&di=8ebdead009a05512e7c4a41d396e232d&imgtype=0&src=http%3A%2F%2Fwww.cgaeo.com%2Fwp-content%2Fuploads%2F2017%2F03%2FVue-JS-2-The-Complete-Guide-incl.-Vuex-2017.jpg","excerpt":"","slug":"前端数据流管理模式（三）——Vuex篇（附源码解析）","comments":true,"dropcap":false,"tags":["js","前端数据流"],"categories":["js"],"updated":"2018-04-26T05:16:14.904Z","content":"<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><p>先来看看官网对Vuex的描述：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<p>Vuex也是属于Flux流派的一种，通过单向数据流的方式来管理数据。但是它是专门为Vue定制的数据管理框架，主要是为了配合Vue本身的响应式机制，对框架的依赖性更高。</p>\n<h3 id=\"Vuex各部分职能：\"><a href=\"#Vuex各部分职能：\" class=\"headerlink\" title=\"Vuex各部分职能：\"></a>Vuex各部分职能：</h3><ul>\n<li>Store：存储数据和管理数据方法的仓库。</li>\n<li>State：状态数据。</li>\n<li>Getters：computed过后的状态，对State进行的二次包装。</li>\n<li>Mutations：所有状态修改都是通过它来提交，必须是同步的。</li>\n<li>Actions：允许异步执行，其本质是在回调中提交Mutations。</li>\n<li>Modules：为解决Store过大，分化Store到每个Module中。</li>\n</ul>\n<h3 id=\"Vuex流程：\"><a href=\"#Vuex流程：\" class=\"headerlink\" title=\"Vuex流程：\"></a>Vuex流程：</h3><p>Vuex流程示意图：<br><img src=\"https://vuex.vuejs.org/zh-cn/images/vuex.png\" alt=\"Vuex流程示意图\"></p>\n<ol>\n<li>在Vue组件中手动触发Action，Action中执行异步操作，并在回调中commit到mutation。（如果是同步操作，你可以直接在Vue组件中直接触发mutation）。</li>\n<li>mutation同步修改state。</li>\n<li>state修改完成之后，通知Vue组件进行rerender。这样一来，一次数据的单向流动就完成了。</li>\n</ol>\n<h3 id=\"与同门师兄Redux的区别：\"><a href=\"#与同门师兄Redux的区别：\" class=\"headerlink\" title=\"与同门师兄Redux的区别：\"></a>与同门师兄Redux的区别：</h3><ol>\n<li>Vuex是一个针对Vue特化的Flux，能够很好地去配合Vue自身的响应式机制。</li>\n<li>Vuex没有强制immutability，并不像Redux的纯函数那么严格，你可以在mutation中直接修改state，或是引发一些副作用，这一点比较宽松。</li>\n<li>在异步流程处理这方面，Vuex通过action和mutation之间的配合来实现：action可以是异步的（下面的源码解析也会说到action在Vuex内部会被包装成Promise），然后异步处理完后，commit给mutation必须是同步的。而Redux通过引入中间件（如redux-thunk 、redux-saga等等）来处理异步流程。</li>\n</ol>\n<h4 id=\"ps：为什么mutation中必须是同步提交的？\"><a href=\"#ps：为什么mutation中必须是同步提交的？\" class=\"headerlink\" title=\"ps：为什么mutation中必须是同步提交的？\"></a>ps：为什么mutation中必须是同步提交的？</h4><p>尤大原话：同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。</p>\n<p>因此mutations和状态树正确的对应关系是实现时间旅行的关键，异步的话不能保证这点。</p>\n<h3 id=\"Vuex源码解读：\"><a href=\"#Vuex源码解读：\" class=\"headerlink\" title=\"Vuex源码解读：\"></a>Vuex源码解读：</h3><p>Vuex的源码不多，适合阅读学习~</p>\n<h4 id=\"入口文件index-js\"><a href=\"#入口文件index-js\" class=\"headerlink\" title=\"入口文件index.js\"></a>入口文件index.js</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Store, install &#125; from &apos;./store&apos;</span><br><span class=\"line\">import &#123; mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers &#125; from &apos;./helpers&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">//导出store类，install方法，版本，一些操作state,mutations,actions,getters的语法糖</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  Store,</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  version: &apos;__VERSION__&apos;,</span><br><span class=\"line\">  mapState,</span><br><span class=\"line\">  mapMutations,</span><br><span class=\"line\">  mapGetters,</span><br><span class=\"line\">  mapActions,</span><br><span class=\"line\">  createNamespacedHelpers</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>入口文件的主要功能就是把个模块部分实现的方法、属性等等聚合起来，然后再提供一个出口供外部来调用。</p>\n<h4 id=\"将store注入Vue实例\"><a href=\"#将store注入Vue实例\" class=\"headerlink\" title=\"将store注入Vue实例\"></a>将store注入Vue实例</h4><p>接下来看看Vuex是如何把store注入到每个Vue实例中，使得每个Vue实例拿到同一份store。这里的实现逻辑主要是在mixin.js文件中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Vue2.x和Vue1.x的注入方式有点不同</span><br><span class=\"line\">const version = Number(Vue.version.split(&apos;.&apos;)[0])</span><br><span class=\"line\">if (version &gt;= 2) &#123;</span><br><span class=\"line\">  Vue.mixin(&#123; beforeCreate: vuexInit &#125;)</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  const _init = Vue.prototype._init</span><br><span class=\"line\">  Vue.prototype._init = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    options.init = options.init</span><br><span class=\"line\">      ? [vuexInit].concat(options.init)</span><br><span class=\"line\">      : vuexInit</span><br><span class=\"line\">    _init.call(this, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//注入实现逻辑</span><br><span class=\"line\">function vuexInit () &#123;</span><br><span class=\"line\">  const options = this.$options</span><br><span class=\"line\">  // store injection</span><br><span class=\"line\">  if (options.store) &#123;</span><br><span class=\"line\">    this.$store = typeof options.store === &apos;function&apos;</span><br><span class=\"line\">      ? options.store()</span><br><span class=\"line\">      : options.store</span><br><span class=\"line\">  &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class=\"line\">    this.$store = options.parent.$store</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里只说下Vue2.x的注入流程：调用Vue的mixin方法把vuexInit方法混入到每个组件的beforeCreate钩子中。在vuexInit中通过vm.$options判断有没有store，有就说明是root组件（因为在vue初始化root组件的时候会注入），没有的话就从它的parent那里获取。这样一来，所有组件都能拿到同一份store了。</p>\n<h4 id=\"重头戏store-js\"><a href=\"#重头戏store-js\" class=\"headerlink\" title=\"重头戏store.js\"></a>重头戏store.js</h4><p>这个文件是Vuex的主文件，定义了Vuex的运行逻辑、方法等等。先说说它初始化的一些东西：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义的一些内部变量</span><br><span class=\"line\">//判断是否通过mutation来修改state，严格模式实现的主要参数（下文会说怎么实现严格模式）</span><br><span class=\"line\">this._committing = false</span><br><span class=\"line\">//存放actions</span><br><span class=\"line\">this._actions = Object.create(null)</span><br><span class=\"line\">//存放mutations</span><br><span class=\"line\">this._mutations = Object.create(null)</span><br><span class=\"line\">//存放getters</span><br><span class=\"line\">this._wrappedGetters = Object.create(null)</span><br><span class=\"line\">this._modules = new ModuleCollection(options)</span><br><span class=\"line\">this._modulesNamespaceMap = Object.create(null)</span><br><span class=\"line\">//存放订阅者</span><br><span class=\"line\">this._subscribers = []</span><br><span class=\"line\">//借用这个vue实例来使用它的watch方法</span><br><span class=\"line\">this._watcherVM = new Vue()</span><br></pre></td></tr></table></figure></p>\n<p>两个主要方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//安装各个module，给不同的module加上不同的命名空间，避免命名污染，遍历注册mutation、action、getter、子module。</span><br><span class=\"line\">installModule(this, state, [], this._modules.root)</span><br><span class=\"line\"></span><br><span class=\"line\">//通过vm重设store，利用vue的响应式使得vuex的数据也变得响应式</span><br><span class=\"line\">resetStoreVM(this, state)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"着重说说resetStoreVM方法\"><a href=\"#着重说说resetStoreVM方法\" class=\"headerlink\" title=\"着重说说resetStoreVM方法\"></a>着重说说resetStoreVM方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function resetStoreVM (store, state, hot) &#123;</span><br><span class=\"line\">  const oldVm = store._vm </span><br><span class=\"line\"></span><br><span class=\"line\">  store.getters = &#123;&#125;</span><br><span class=\"line\">  const wrappedGetters = store._wrappedGetters</span><br><span class=\"line\">  const computed = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /* 通过Object.defineProperty方法为每一个getter方法设置它的get，比如获取this.$store.getters.age的时候获取的是store._vm.age，这赋值到Vue对象的computed属性上的，利用了computed本身就有的响应式，从而实现了响应式 */</span><br><span class=\"line\">  forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class=\"line\">    computed[key] = () =&gt; fn(store)</span><br><span class=\"line\">    Object.defineProperty(store.getters, key, &#123;</span><br><span class=\"line\">      get: () =&gt; store._vm[key],</span><br><span class=\"line\">      enumerable: true</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  const silent = Vue.config.silent</span><br><span class=\"line\">  </span><br><span class=\"line\">  /* 这里新建一个vue实例，运用Vue内部的响应式实现注册state以及computed（把state赋值到vue实例的data上，把getter赋值到vue实例的computed上）*/</span><br><span class=\"line\">  store._vm = new Vue(&#123;</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      $$state: state</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    computed</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  Vue.config.silent = silent</span><br><span class=\"line\"></span><br><span class=\"line\">  //严格模式是否启用</span><br><span class=\"line\">  if (store.strict) &#123;</span><br><span class=\"line\">    enableStrictMode(store)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (oldVm) &#123;</span><br><span class=\"line\">    if (hot) &#123;</span><br><span class=\"line\">      store._withCommit(() =&gt; &#123;</span><br><span class=\"line\">        oldVm._data.$$state = null</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Vue.nextTick(() =&gt; oldVm.$destroy())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"commit方法\"><a href=\"#commit方法\" class=\"headerlink\" title=\"commit方法\"></a>commit方法</h4><p>Mutation的commit方法用于同步修改state<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">commit (_type, _payload, _options) &#123;</span><br><span class=\"line\">   const &#123;</span><br><span class=\"line\">     type,</span><br><span class=\"line\">     payload,</span><br><span class=\"line\">     options</span><br><span class=\"line\">   &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class=\"line\"></span><br><span class=\"line\">   const mutation = &#123; type, payload &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   //找到Mutations中对应的type的mutation</span><br><span class=\"line\">   const entry = this._mutations[type]</span><br><span class=\"line\">   if (!entry) &#123;</span><br><span class=\"line\">     if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">       console.error(`[vuex] unknown mutation type: $&#123;type&#125;`)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   //遍历执行刚才拿到的mutations</span><br><span class=\"line\">   /* ps：这个_withCommit方法会先保存当前的_committing值，然后把它修改为true，再去执行回调，最后把_committing复原。这也是下文提到的严格模式的控制实现 */</span><br><span class=\"line\">   this._withCommit(() =&gt; &#123;</span><br><span class=\"line\">     entry.forEach(function commitIterator (handler) &#123;</span><br><span class=\"line\">       handler(payload)</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">   &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">   //通知所有的订阅者</span><br><span class=\"line\">   this._subscribers.forEach(sub =&gt; sub(mutation, this.state))</span><br><span class=\"line\"></span><br><span class=\"line\">   if (</span><br><span class=\"line\">     process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">     options &amp;&amp; options.silent</span><br><span class=\"line\">   ) &#123;</span><br><span class=\"line\">     console.warn(</span><br><span class=\"line\">       `[vuex] mutation type: $&#123;type&#125;. Silent option has been removed. ` +</span><br><span class=\"line\">       &apos;Use the filter functionality in the vue-devtools&apos;</span><br><span class=\"line\">     )</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>commit方法会根据传进来的type找到对应的mutation去执行，执行完之后，又会通知所有订阅者有新的state（这个subscribe一般在devtool那里用到；如果是渲染更新state的话直接利用vue自身的响应式就好，不用这个subscribe）。</p>\n<h4 id=\"dispatch方法\"><a href=\"#dispatch方法\" class=\"headerlink\" title=\"dispatch方法\"></a>dispatch方法</h4><p>处理action的dispatch<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch (_type, _payload) &#123;</span><br><span class=\"line\">  const &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    payload</span><br><span class=\"line\">  &#125; = unifyObjectStyle(_type, _payload)</span><br><span class=\"line\"></span><br><span class=\"line\">  const entry = this._actions[type]</span><br><span class=\"line\">  if (!entry) &#123;</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      console.error(`[vuex] unknown action type: $&#123;type&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return entry.length &gt; 1</span><br><span class=\"line\">    ? Promise.all(entry.map(handler =&gt; handler(payload)))</span><br><span class=\"line\">    : entry[0](https://cdn.example.com/payload?m=webp&q=80)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过type拿到所有的actions，如果actions大于1，那就把它们包装在Promise.all里面去并行执行，等于1就直接执行。那么，为什么这里可以把actions放在Promise.all里面呢？Promise.all里不是只能放Promise对象吗？</p>\n<p>对，每个action都是一个Promise，这是通过registerAction来注册实现的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function registerAction (store, type, handler, local) &#123;</span><br><span class=\"line\">  const entry = store._actions[type] || (store._actions[type] = [])</span><br><span class=\"line\">  entry.push(function wrappedActionHandler (payload, cb) &#123;</span><br><span class=\"line\">    let res = handler.call(store, &#123;</span><br><span class=\"line\">      dispatch: local.dispatch,</span><br><span class=\"line\">      commit: local.commit,</span><br><span class=\"line\">      getters: local.getters,</span><br><span class=\"line\">      state: local.state,</span><br><span class=\"line\">      rootGetters: store.getters,</span><br><span class=\"line\">      rootState: store.state</span><br><span class=\"line\">    &#125;, payload, cb)</span><br><span class=\"line\">    </span><br><span class=\"line\">    //它就会把每一个action转化为Promise对象</span><br><span class=\"line\">    if (!isPromise(res)) &#123;</span><br><span class=\"line\">      res = Promise.resolve(res)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (store._devtoolHook) &#123;</span><br><span class=\"line\">      return res.catch(err =&gt; &#123;</span><br><span class=\"line\">        store._devtoolHook.emit(&apos;vuex:error&apos;, err)</span><br><span class=\"line\">        throw err</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      return res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"严格模式的实现\"><a href=\"#严格模式的实现\" class=\"headerlink\" title=\"严格模式的实现\"></a>严格模式的实现</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//启用严格模式</span><br><span class=\"line\">function enableStrictMode (store) &#123;</span><br><span class=\"line\">  store._vm.$watch(function () &#123; return this._data.$$state &#125;, () =&gt; &#123;</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, &#123; deep: true, sync: true &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上文也说到，store中有个_committing属性，是用来标志是否正在通过mutation来修改state，如果是的话，它的值为true，否则为false。启用严格模式后，严格模式中会通过vue的$watch方法来检测state的变化，如果有变化，那就判断_committing属性，_committing为false的话就抛出异常。</p>\n<h4 id=\"语法糖：mapState-mapMutations-mapActions-mapGetters\"><a href=\"#语法糖：mapState-mapMutations-mapActions-mapGetters\" class=\"headerlink\" title=\"语法糖：mapState,mapMutations,mapActions,mapGetters\"></a>语法糖：mapState,mapMutations,mapActions,mapGetters</h4><p>mapState,mapMutations,mapActions,mapGetters它们都是一些提供给开发者操作store的一些语法糖函数。<br>它们几个在实现上也比较类似，主要流程是先将state,mutations等等这些转化成[{key, val},{key, val},{key, val}…]的数据结构<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function normalizeMap (map) &#123;</span><br><span class=\"line\">  return Array.isArray(map)</span><br><span class=\"line\">    ? map.map(key =&gt; (&#123; key, val: key &#125;))</span><br><span class=\"line\">    : Object.keys(map).map(key =&gt; (&#123; key, val: map[key] &#125;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后遍历这个数据结构，把每一项都包装成一个函数。<br>mapState和mapGetters是把它们的值作为该函数的返回值返回出去，这样在vue示例中的computed就能拿到它们的值了。<br>如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed:&#123;</span><br><span class=\"line\">    ...mapState([</span><br><span class=\"line\">        &apos;name&apos;</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//就会转化成</span><br><span class=\"line\">computed:&#123;</span><br><span class=\"line\">    name () &#123;</span><br><span class=\"line\">      return this.$store.state.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而mapMutations和mapActions分别是返回调用它们的commit和dispatch方法，这样在vue示例中的methods也就存在它们的方法了。<br>如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    ...mapMutation([</span><br><span class=\"line\">        &apos;addName&apos;</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//就会转化成</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    addName(...args)&#123;</span><br><span class=\"line\">        return this.$store.commit.apply(this.$store,[&apos;addName&apos;].concat(args));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Vuex的错误处理方式\"><a href=\"#Vuex的错误处理方式\" class=\"headerlink\" title=\"Vuex的错误处理方式\"></a>Vuex的错误处理方式</h4><p>Vuex的错误处理是通过自定义函数assert实现，内容很简单，值得一学<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//假设现在要判断当前环境支不支持Promise</span><br><span class=\"line\">assert(typeof Promise!==&apos;undefined&apos;,&apos;当前环境不支持Promise&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function assert(condition,msg)&#123;</span><br><span class=\"line\">    if(!condition) throw new Error(`[vuex] $&#123;msg&#125;`);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","prev":{"title":"前端数据流管理模式（四））.md","slug":"前端数据流管理模式（四）——MobX篇（附源码解析）"},"next":{"title":"前端数据流管理模式（二）——Redux篇","slug":"前端数据流管理模式（二）——Redux篇"}}