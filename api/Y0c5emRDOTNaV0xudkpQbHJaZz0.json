{"title":"web缓存","date":"2017-09-11T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1521386052390&di=7b7e7a0967a5ed9ca22178f5442da3c6&imgtype=0&src=http%3A%2F%2Fqimg.hxnews.com%2F2018%2F0212%2F1518396012437.jpeg","excerpt":"","slug":"web缓存","comments":true,"dropcap":true,"tags":["js","web缓存"],"categories":["js"],"updated":"2018-04-24T16:33:55.258Z","content":"<h2 id=\"Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。\"><a href=\"#Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存-。\" class=\"headerlink\" title=\"Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存 。\"></a>Web缓存可以分为这几种：浏览器缓存、CDN缓存、服务器缓存、数据库数据缓存 。</h2><p>浏览器HTTP缓存可以分为强缓存和协商缓存。强缓存和协商缓存最大也是最根本的区别是：强缓存命中的话不会发请求到服务器（比如chrome中的200 from memory cache），协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）。简略流程图如下：</p>\n<p><img src=\"/2017/09/12/web缓存/1.png\" alt=\"web缓存流程图1\"></p>\n<p><img src=\"/2017/09/12/web缓存/2.png\" alt=\"web缓存流程图2\"></p>\n<p>浏览器HTTP缓存由HTTP报文的首部字段决定</p>\n<h2 id=\"控制强缓存的字段按优先级介绍：\"><a href=\"#控制强缓存的字段按优先级介绍：\" class=\"headerlink\" title=\"控制强缓存的字段按优先级介绍：\"></a>控制强缓存的字段按优先级介绍：</h2><h3 id=\"1-Pragma\"><a href=\"#1-Pragma\" class=\"headerlink\" title=\"1.Pragma\"></a>1.Pragma</h3><p>Pragma是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。虽然它是一个通用首部，但是它在响应报文中时的行为没有规范，依赖于浏览器的实现。RFC中该字段只有no-cache一个可选值，会通知浏览器不直接使用缓存，要求向服务器发请求校验新鲜度。因为它优先级最高，当存在时一定不会命中强缓存。</p>\n<h3 id=\"2-Expires\"><a href=\"#2-Expires\" class=\"headerlink\" title=\"2.Expires\"></a>2.Expires</h3><p>Expires是一个响应首部字段，它指定了一个日期/时间，在这个时间/日期之前，HTTP缓存被认为是有效的。无效的日期比如0，表示这个资源已经过期了。如果同时设置了Cache-Control响应首部字段的max-age，则Expires会被忽略。它也是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。</p>\n<h3 id=\"3-Cache-Control\"><a href=\"#3-Cache-Control\" class=\"headerlink\" title=\"3.Cache-Control\"></a>3.Cache-Control</h3><p>Cache-Control是一个通用首部字段，也是HTTP/1.1控制浏览器缓存的主流字段。和浏览器缓存相关的是如下几个响应指令：</p>\n<p>指令 参数 说明</p>\n<p>private 无 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）</p>\n<p>public 可省略 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存</p>\n<p>no-cache 可省略 缓存前必需确认其有效性</p>\n<p>no-store 无 不缓存请求或响应的任何内容</p>\n<p>max-age=[s] 必需 响应的最大值</p>\n<p>max-age（单位为s）设置缓存的存在时间，相对于发送请求的时间。只有响应报文首部设置Cache-Control为非0的max-age或者设置了大于请求日期的Expires（下文会讲）才有可能命中强缓存。当满足这个条件，同时响应报文首部中Cache-Control不存在no-cache、no-store且请求报文首部不存在Pragma字段，才会真正命中强缓存。max-age=0相当于no-cache。</p>\n<p>no-cache 表示请求必须先与服务器确认缓存的有效性，如果有效才能使用缓存（协商缓存），无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存。Chrome硬性重新加载（Command+shift+R）会在请求的首部加上Pragma：no-cache和Cache-Control：no-cache。会缓存，但是使用这份缓存之前先到服务器上确认这份缓存是不是最新的，是最新的才使用。</p>\n<p>no-store 表示禁止浏览器以及所有中间缓存存储任何版本的返回响应，一定不会出现强缓存和协商缓存，适合个人隐私数据或者经济类数据。绝对不缓存。</p>\n<p>public 表明响应可以被浏览器、CDN等等缓存。对于public，则允许所有服务器缓存该资源。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），Cache-Control 设为 public 是合理的。</p>\n<p>private 响应只作为私有的缓存，不能被CDN等缓存。如果要求HTTP认证，响应会自动设置为private。如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。</p>\n<h2 id=\"控制协商缓存的字段：\"><a href=\"#控制协商缓存的字段：\" class=\"headerlink\" title=\"控制协商缓存的字段：\"></a>控制协商缓存的字段：</h2><h3 id=\"1-Last-Modified-If-Modified-Since\"><a href=\"#1-Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"1.Last-Modified/If-Modified-Since\"></a>1.Last-Modified/If-Modified-Since</h3><p>If-Modified-Since是一个请求首部字段，并且只能用在GET或者HEAD请求中。Last-Modified是一个响应首部字段，包含服务器认定的资源作出修改的日期及时间。当带着If-Modified-Since头访问服务器请求资源时，服务器会检查Last-Modified，如果Last-Modified的时间早于或等于If-Modified-Since则会返回一个不带主体的304响应，否则将重新返回资源。</p>\n<h3 id=\"2-ETag-If-None-Match\"><a href=\"#2-ETag-If-None-Match\" class=\"headerlink\" title=\"2.ETag/If-None-Match\"></a>2.ETag/If-None-Match</h3><p>ETag是一个响应首部字段，它是根据实体内容生成的一段hash字符串，标识资源的状态，由服务端产生。If-None-Match是一个条件式的请求首部。如果请求资源时在请求首部加上这个字段，值为之前服务器端返回的资源上的ETag，则当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的时候，服务器才会返回带有所请求资源实体的200响应，否则服务器会返回不带实体的304响应。ETag优先级比Last-Modified高，同时存在时会以ETag为准。</p>\n<h3 id=\"ps：\"><a href=\"#ps：\" class=\"headerlink\" title=\"ps：\"></a>ps：</h3><p>在有效期内更新资源可以用资源加时间戳命名的方式，如下图的<img>。<br>按F5相当于no-cache，按ctrl+f5相当于强制刷新，拉取新资源。</p>\n<h3 id=\"缓存策略：\"><a href=\"#缓存策略：\" class=\"headerlink\" title=\"缓存策略：\"></a>缓存策略：</h3><h4 id=\"为静态资源设置长缓存时间\"><a href=\"#为静态资源设置长缓存时间\" class=\"headerlink\" title=\"为静态资源设置长缓存时间\"></a>为静态资源设置长缓存时间</h4><p>有些资源是很长时间不会改变的，比如网站的 logo 图片、jQuery 库、字体等，因此可以为它们设定「永不过期」的缓存时间，例如设定为 10 年。</p>\n<h4 id=\"确保文件修改生效\"><a href=\"#确保文件修改生效\" class=\"headerlink\" title=\"确保文件修改生效\"></a>确保文件修改生效</h4><p>有些时候我们会修改一些资源，比如更新了 jQuery 版本，或网站的 CSS 样式。如果这些资源已经被缓存，那么除非用户手工刷新页面，否则要等缓存自然过期之后用户才会获得新版本。如何在这种情况下强制浏览器重新下载呢？最有效的一个办法就是在这类资源的文件名中包含版本信息，并在更改之后对应地修改文件名。浏览器发现文件更换后，自然无法使用缓存，而会重新下载。</p>\n<h4 id=\"对于-HTML-文档谨慎设定过期时间\"><a href=\"#对于-HTML-文档谨慎设定过期时间\" class=\"headerlink\" title=\"对于 HTML 文档谨慎设定过期时间\"></a>对于 HTML 文档谨慎设定过期时间</h4><p>大部分情况下，对于其他图片、CSS、JavaScript 等资源的请求都来自一个单一的 HTML 文档。对于这类页面通常应该设定比较短的过期时间，或者干脆不设定。因为如果这类页面被缓存，那么页面中包含的资源的文件名等等信息都会一并被缓存，导致对它的更新难以确保立即对用户生效。</p>\n<p>html文件用no-cache的方式设置，css,js文件用max-age设置.可以对静态资源进行版本控制（比如给静态资源的文件名加上hash值），其次对网页设置合适时长的缓存时间（长短取决于实际场景）。这样就兼顾了版本升级和性能</p>\n<h4 id=\"引用静态资源时，不要使用-Query-String\"><a href=\"#引用静态资源时，不要使用-Query-String\" class=\"headerlink\" title=\"引用静态资源时，不要使用 Query String\"></a>引用静态资源时，不要使用 Query String</h4><p>Query String 就是例如?key=val的字符串，如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;/static/js/func.js?v=a87ff8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这会阻止一部分较老的浏览器（包括 IE6 ）对该资源进行缓存。</p>\n","prev":{"title":"CSS世界学习笔记","slug":"css世界学习笔记"},"next":{"title":"Three.js开发指南笔记","slug":"Three.js开发指南笔记"}}