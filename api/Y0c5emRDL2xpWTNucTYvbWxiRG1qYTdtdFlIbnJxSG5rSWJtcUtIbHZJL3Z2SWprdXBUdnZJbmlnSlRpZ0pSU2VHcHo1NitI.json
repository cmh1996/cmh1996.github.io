{"title":"前端数据流管理模式（五）——Rxjs篇","date":"2018-05-14T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1524818817776&di=dfc0c4149f33224c5ffe3112df02fb6a&imgtype=0&src=http%3A%2F%2Fimgsrc.baidu.com%2Fimgad%2Fpic%2Fitem%2F21a4462309f790525bd51d0207f3d7ca7acbd5c0.jpg","excerpt":"","slug":"前端数据流管理模式（五）——Rxjs篇","comments":true,"dropcap":false,"tags":["js","前端数据流"],"categories":["js"],"updated":"2018-04-27T05:59:09.774Z","content":"<h2 id=\"Rxjs\"><a href=\"#Rxjs\" class=\"headerlink\" title=\"Rxjs\"></a>Rxjs</h2><p>基于标准Flux／Redux的实践有一个共同点：繁琐。产生这种繁琐的最主要原因是，它们都是以自定义事件为核心的，自定义事件本身就是繁琐的。由于收发事件通常位于两个以上不相同的模块中，不得不以封装的事件对象为通信载体，并且必须显式定义事件的key，否则接收方无法指定自己的响应。</p>\n<p>一旦整个应用都是以此为基石，其中的繁琐程度可想而知，所以社区会存在一些简化action创建，或者通过约定来减少action收发中间环节的Redux周边。</p>\n<p>如果不从根本上对事件这种机制进行抽象，就不可能彻底解决繁琐的问题，基于Reactive理念的这几个库天然就是为了处理对事件机制的抽象而出现的，所以用在这种场景下有奇效，能把action的派发与处理过程描述得优雅精妙。</p>\n<p>一些基于Reactive Programming的库可以提供一种能力，把数据包装成可持续变更、可观测的类型，供后续使用</p>\n<p>在这样的机制里，我们可以很清楚地看到一块数据的来龙去脉，它最初是哪里来的，后来可能会被谁修改过。所有这样的数据都放置在管道中，除了指定的入口，不会有其他东西能够修改这些数据，视图可以很安全地订阅他们。</p>\n<p>rxjs 是 FRP 的另一个分支，是基于 Event Stream 的，所以从对 view 的辅助作用来说，相比 mobx，显得不是那么智能，但是对数据源的定义，和 TFRP 有着本质的区别，似的 rxjs 这类框架几乎可以将任何事件转成数据源。</p>\n<p>同时，rxjs 其对数据流处理能力非常强大，当我们把前端的一切都转为数据源后，剩下的一切都由无所不能的 rxjs 做数据转换，你会发现，副作用已经在数据源转换这一层完全隔离了，接下来会进入一个美妙的纯函数世界，最后输出到 dom driver 渲染，如果再加上虚拟 dom 的点缀，那岂不是。。岂不就是 cyclejs 吗？</p>\n<p>多提一句，rxjs 对数据流纯函数的抽象能力非常强大，因此前端主要工作在于抽一个工具，将诸如事件、请求、推送等等副作用都转化为数据源。cyclejs 就是这样一个框架：提供了一套上述的工具库，与 dom 对接增加了虚拟 dom 能力。<br>rxjs 给前端数据流管理方案带来了全新的视角，它的概念由 mobx 引发，但解题思路却与 redux 相似。</p>\n<p>rxjs 带来了两种新的开发方式，第一种是类似 cyclejs，将一切前端副作用转化为数据源，直接对接到 dom。另一种是类似 redux-observable，将 rxjs 数据流处理能力融合到已有数据流框架中，</p>\n<p>redux-observable 将 action 与 reducer 改造为 stream 模式，对 action 中副作用行为，比如发请求，也提供了封装好的函数转化为数据源，因此，将 redux middleware 中的副作用，转移到了数据源转换做成中，让 action 保持纯函数，同时增强了原本就是纯函数的 reducer 的数据处理能力，非常棒。</p>\n<p>如果说 redux-saga 解决了异步，那么 redux-observable 就是解决了副作用，同时赠送了 rxjs 数据处理能力。</p>\n<p>回头看一下 mobx，发现 rxjs 与 mobx 都有对 redux 的增强方案，前端数据流的发展就是在不断交融。</p>\n<p>我们不但在时间线上，将 redux、mobx、rxjs 串了起来，还发现了他们内在的关联，这三个思想像一张网，复杂的交织在一起。</p>\n<ol>\n<li>跟Redux的对比<br>Rx和Redux其实没有什么关系。在表达数据变更的时候，从逻辑上讲，这两种技术是等价的，一种方式能表达出的东西，另外一种也都能够。</li>\n</ol>\n<p>比如说，同样是表达数据a到b这么一个转换，两者所关注的点可能是不一样的：</p>\n<p>Redux：定义一个action叫做AtoB，在其实现中，把a转换成b<br>Rx：定义两个数据流A和B，B是从A经过一次map转换得到的，map的表达式是把a转成b<br>由于Redux更多地是一种理念，它的库功能并不复杂，而Rx是一种强大的库，所以两者直接对比并不合适，比如说，可以用Rx依照Redux的理念作实现，但反之不行。</p>\n<p>在数据变更的链路较长时，Rx是具有很大优势的，它可以很简便地做多级状态变更的连接，也可以做数据变更链路的复用（比如存在a -&gt; b -&gt; c，又存在a -&gt; b -&gt; d，可以把a -&gt; b这个过程拿出来复用），还天生能处理好包括竞态在内的各种异步的情况，Redux可能要借助saga等理念才能更好地组织代码。</p>\n<p>我们之前有些demo代码也提到了，比如说：</p>\n<p>用户信息数据流 := 用户信息的查询 + 用户信息的更新<br>这段东西就是按照reducer的理念去写的，跟Redux类似，我们把变更操作放到一个数据流中，然后用它去累积在初始状态上，就能得到始终反映某个实体当前状态的数据流。</p>\n<p>在Redux方案中，中间件是一种比较好的东西，能够对业务产生一定的约束，如果我们用RxJS实现，可以把变更过程中间接入一个统一的数据流来完成同样的事情。</p>\n<p>RxJS 与事件驱动应用<br>事件驱动的前端应用中，对异步逻辑的把握则显得非常重要。这方面，redux-saga 一类的库提供了一些处理异步副作用的方式，但如果你了解了 RxJS，会发现 Saga 看似强大的能力在 Rx 的事件流思维模型面前，简直就是玩具。</p>\n<p>如果用数据驱动应用的思维来理解 RxJS，你只会感觉它的 API 十分沉重，侵入性很强。实际上，你需要在事件驱动的场景下来感受这一套理念的强大。这里的一个例子，是每天等电梯时电梯的调度方式：电梯的状态直接由用户按下楼层按钮的事件流所决定，这时通过 RxJS 的响应式编程能够很合理地建模这个业务。作为从例子出发学习 RxJS 的教程，笔者之前撰写过一篇《响应式编程入门：实现电梯调度模拟器》的专栏，还有一个配套的 Demo 实现，欢迎有兴趣的同学阅读。</p>\n<h4 id=\"——开坑中，稍安勿躁-╯□╰-——\"><a href=\"#——开坑中，稍安勿躁-╯□╰-——\" class=\"headerlink\" title=\"——开坑中，稍安勿躁( ╯□╰ )——\"></a>——开坑中，稍安勿躁( ╯□╰ )——</h4><p>数据状态管理没有银弹，不论黑猫白猫，抓到老鼠的才是好猫。</p>\n","next":{"title":"前端数据流管理模式（四）——MobX篇（附源码解析）","slug":"前端数据流管理模式（四）——MobX篇（附源码解析）"}}