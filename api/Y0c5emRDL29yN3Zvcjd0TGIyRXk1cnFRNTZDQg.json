{"title":"读读Koa2源码","date":"2018-06-13T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1540309853637&di=f75c1480b281257f2fd2fdf7ea523b4c&imgtype=0&src=http%3A%2F%2Ftc.sinaimg.cn%2Fmaxwidth.800%2Ftc.service.weibo.com%2Fp%2Fww1_sinaimg_cn%2Fc577e973a86dfc8bc40c15642459bb0d.jpg","excerpt":"","slug":"读读Koa2源码","comments":true,"dropcap":false,"tags":["Koa2"],"categories":["nodejs"],"updated":"2018-10-23T15:05:45.001Z","content":"<h2 id=\"读读Koa2源码\"><a href=\"#读读Koa2源码\" class=\"headerlink\" title=\"读读Koa2源码\"></a>读读Koa2源码</h2><p>本人因为一直用的都是Koa2作为nodejs的开发框架，所以也对Koa2的原理产生了兴趣。于是我便花了一点时间分析了一下Koa2的源码，看看这个轻量级框架到底有多“轻”。</p>\n<p>koa2的源码只有四个主要文件，我们一个一个来分析：<br><code>application.js</code>，<code>context.js</code>，<code>request.js</code>，<code>response.js</code></p>\n<hr>\n<h3 id=\"application-js-主入口文件\"><a href=\"#application-js-主入口文件\" class=\"headerlink\" title=\"application.js 主入口文件\"></a>application.js 主入口文件</h3><h4 id=\"继承events\"><a href=\"#继承events\" class=\"headerlink\" title=\"继承events\"></a>继承events</h4><p>这个文件导出了一个类<code>Application</code>，它继承了Emitter类，这样做是为了让koa也能监听事件，<br>例如，我们在koa中是这样来监听错误的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//没有处理过的错误将在这里被捕获</span><br><span class=\"line\">const Koa = require(&apos;koa&apos;);</span><br><span class=\"line\">const app = new Koa();</span><br><span class=\"line\">app.on(&apos;error&apos;, err =&gt; console.log(err));</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"listen函数\"><a href=\"#listen函数\" class=\"headerlink\" title=\"listen函数\"></a>listen函数</h4><p>然后我们继续往下看，看到listen函数。<br>listen函数用于监听端口，它其实是对原生http模块的listen做了一下封装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen(...args) &#123;</span><br><span class=\"line\">    debug(&apos;listen&apos;);</span><br><span class=\"line\">    const server = http.createServer(this.callback());</span><br><span class=\"line\">    return server.listen(...args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"callback函数\"><a href=\"#callback函数\" class=\"headerlink\" title=\"callback函数\"></a>callback函数</h4><p>我们看到createSever的时候传入了一个callback函数，它是创建完服务器之后要执行的回调函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callback() &#123;</span><br><span class=\"line\">    const fn = compose(this.middleware);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!this.listenerCount(&apos;error&apos;)) this.on(&apos;error&apos;, this.onerror);</span><br><span class=\"line\"></span><br><span class=\"line\">    const handleRequest = (req, res) =&gt; &#123;</span><br><span class=\"line\">      const ctx = this.createContext(req, res);</span><br><span class=\"line\">      return this.handleRequest(ctx, fn);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    return handleRequest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它首先会把传入的中间件都用compose来处理（这是中间件的处理函数，后面会说到），然后返回一个handleRequest函数：先用createContext函数创建一个context环境，然后再把ctx和中间件放到handleRequest中去处理。</p>\n<h4 id=\"compose函数\"><a href=\"#compose函数\" class=\"headerlink\" title=\"compose函数\"></a>compose函数</h4><p>在koa中compose是交给了<code>koa-compose</code>来处理，所以我们找来了<code>koa-compose</code>库来看看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function compose (middleware) &#123;</span><br><span class=\"line\">  if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;)</span><br><span class=\"line\">  for (const fn of middleware) &#123;</span><br><span class=\"line\">    if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return function (context, next) &#123;</span><br><span class=\"line\">    // last called middleware #</span><br><span class=\"line\">    let index = -1</span><br><span class=\"line\">    return dispatch(0)</span><br><span class=\"line\">    function dispatch (i) &#123;</span><br><span class=\"line\">      if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;))</span><br><span class=\"line\">      index = i</span><br><span class=\"line\">      let fn = middleware[i]</span><br><span class=\"line\">      if (i === middleware.length) fn = next</span><br><span class=\"line\">      if (!fn) return Promise.resolve()</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        return Promise.resolve(fn(context, function next () &#123;</span><br><span class=\"line\">          return dispatch(i + 1)</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">      &#125; catch (err) &#123;</span><br><span class=\"line\">        return Promise.reject(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它先对传进来的中间件数组做一些合法性检测，然后返回一个函数来通过递归去遍历执行所有的中间件函数。<br>通过在<code>Promise.resolve(fn)</code>的回调中执行fn即实现了对异步函数的处理。我们可以关注一下 最初是执行的是 dispatch(0) 也就是this.middleware数组中下标为0的函数，也就是说 最先进入的中间件函数会最先被执行就像一个执行队列。<br>执行完成以后执行next()到下一步处理，next就是下一个的中间件。</p>\n<h4 id=\"use函数\"><a href=\"#use函数\" class=\"headerlink\" title=\"use函数\"></a>use函数</h4><p>use函数也很简单，就是把中间件push到中间件数组当中最后返回this来提供链式调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use(fn) &#123;</span><br><span class=\"line\">    if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;);</span><br><span class=\"line\">    if (isGeneratorFunction(fn)) &#123;</span><br><span class=\"line\">      deprecate(&apos;Support for generators will be removed in v3. &apos; +</span><br><span class=\"line\">                &apos;See the documentation for examples of how to convert old middleware &apos; +</span><br><span class=\"line\">                &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;);</span><br><span class=\"line\">      fn = convert(fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;);</span><br><span class=\"line\">    this.middleware.push(fn);</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"createContext函数\"><a href=\"#createContext函数\" class=\"headerlink\" title=\"createContext函数\"></a>createContext函数</h4><p>在上面的callback函数中我们看到它是通过createContext来创建ctx，<br>平时使用koa2的时候，ctx用的比较多，我们在ctx上面既可以处理req，又可以处理res，那它是怎么做到的呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createContext(req, res) &#123;</span><br><span class=\"line\">    const context = Object.create(this.context);</span><br><span class=\"line\">    const request = context.request = Object.create(this.request);</span><br><span class=\"line\">    const response = context.response = Object.create(this.response);</span><br><span class=\"line\">    context.app = request.app = response.app = this;</span><br><span class=\"line\">    context.req = request.req = response.req = req;</span><br><span class=\"line\">    context.res = request.res = response.res = res;</span><br><span class=\"line\">    request.ctx = response.ctx = context;</span><br><span class=\"line\">    request.response = response;</span><br><span class=\"line\">    response.request = request;</span><br><span class=\"line\">    context.originalUrl = request.originalUrl = req.url;</span><br><span class=\"line\">    context.cookies = new Cookies(req, res, &#123;</span><br><span class=\"line\">      keys: this.keys,</span><br><span class=\"line\">      secure: request.secure</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    request.ip = request.ips[0] || req.socket.remoteAddress || &apos;&apos;;</span><br><span class=\"line\">    context.accept = request.accept = accepts(req);</span><br><span class=\"line\">    context.state = &#123;&#125;;</span><br><span class=\"line\">    return context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实它也就是把一些常用的属性挂载到ctx上，让ctx就像一个大管家那样，拥有许多的权力。</p>\n<h4 id=\"handleRequest函数\"><a href=\"#handleRequest函数\" class=\"headerlink\" title=\"handleRequest函数\"></a>handleRequest函数</h4><p>上面的callback函数就是把经过createContext处理的ctx和经过compose处理的fn传入到这个函数中，最终返回这个handleRequest函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class=\"line\">    const res = ctx.res;</span><br><span class=\"line\">    res.statusCode = 404;</span><br><span class=\"line\">    const onerror = err =&gt; ctx.onerror(err);</span><br><span class=\"line\">    const handleResponse = () =&gt; respond(ctx);</span><br><span class=\"line\">    onFinished(res, onerror);</span><br><span class=\"line\">    return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>handleRequest中首先先取出res，先把默认状态置为404，然后对执行中间件后的成功和失败状态注册方法，失败调用ctx.onerror捕获异常，成功调用respond方法处理结果。这里还是用了onFinished模块，onFinished能确保一个流在关闭、完成和报错时都会执行相应的回调函数，这里把我们的异常处理函数传入用以处理错误信息。而respond方法，里面做的，就是读取ctx信息，把数据写入res中并响应请求。</p>\n<h4 id=\"respond函数\"><a href=\"#respond函数\" class=\"headerlink\" title=\"respond函数\"></a>respond函数</h4><p>koa是通过respond来把数据写入res中并响应请求的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function respond(ctx) &#123;</span><br><span class=\"line\">  //ctx.respond不存在则return</span><br><span class=\"line\">  if (false === ctx.respond) return;</span><br><span class=\"line\">    </span><br><span class=\"line\">  //writable 是原生的 response 对象的 writeable 属性, 检查是否是可写流</span><br><span class=\"line\">  const res = ctx.res;</span><br><span class=\"line\">  if (!ctx.writable) return;</span><br><span class=\"line\"></span><br><span class=\"line\">  let body = ctx.body;</span><br><span class=\"line\">  const code = ctx.status;</span><br><span class=\"line\"></span><br><span class=\"line\">  //如果响应的statusCode是属于body为空的类型, 例如204,205,304将body置为null</span><br><span class=\"line\">  if (statuses.empty[code]) &#123;</span><br><span class=\"line\">    ctx.body = null;</span><br><span class=\"line\">    return res.end();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  //如果是HEAD方法，检查 http 响应头部是否已经被发送，如果头部未被发送, 那么添加 length 头部</span><br><span class=\"line\">  if (&apos;HEAD&apos; == ctx.method) &#123;</span><br><span class=\"line\">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span><br><span class=\"line\">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res.end();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //body为空的情况，那就把body设为message或者code，并修改头部的type和length</span><br><span class=\"line\">  if (null == body) &#123;</span><br><span class=\"line\">    body = ctx.message || String(code);</span><br><span class=\"line\">    if (!res.headersSent) &#123;</span><br><span class=\"line\">      ctx.type = &apos;text&apos;;</span><br><span class=\"line\">      ctx.length = Buffer.byteLength(body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res.end(body);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //分别针对buffer，字符串，stream类型作相应的反应</span><br><span class=\"line\">  if (Buffer.isBuffer(body)) return res.end(body);</span><br><span class=\"line\">  if (&apos;string&apos; == typeof body) return res.end(body);</span><br><span class=\"line\">  if (body instanceof Stream) return body.pipe(res);</span><br><span class=\"line\"></span><br><span class=\"line\">  //对 body 为 json 格式的数据进行处理</span><br><span class=\"line\">  body = JSON.stringify(body);</span><br><span class=\"line\">  if (!res.headersSent) &#123;</span><br><span class=\"line\">    ctx.length = Buffer.byteLength(body);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  res.end(body);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"context-js\"><a href=\"#context-js\" class=\"headerlink\" title=\"context.js\"></a>context.js</h3><p>context主要做的就是：</p>\n<ol>\n<li><p>将 request, response对象上的属性方法代理到 context 对象上。也就是说例如 this.ctx.headersSent 相当于 this.response.headersSent。request对象与response对象的所有方法与属性都能在 ctx 对象上找到。</p>\n</li>\n<li><p>对在中间函数数组生成的 Promise 的 catch 中与 res 对象的 onFinished 函数的回调的错误进行处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onerror(err) &#123;</span><br><span class=\"line\">    if (null == err) return;</span><br><span class=\"line\">    // 将错误转化为 Error 实例</span><br><span class=\"line\">    if (!(err instanceof Error)) err = new Error(util.format(&apos;non-error thrown: %j&apos;, err));</span><br><span class=\"line\"></span><br><span class=\"line\">    let headerSent = false;</span><br><span class=\"line\">    if (this.headerSent || !this.writable) &#123;</span><br><span class=\"line\">      headerSent = err.headerSent = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 触发 koa 实例对象的 error 事件, application 上的 onerror 函数会执行</span><br><span class=\"line\">    this.app.emit(&apos;error&apos;, err, this);</span><br><span class=\"line\">    // 如果响应头部已经发送(或者 socket 不可写)则返回</span><br><span class=\"line\">    if (headerSent) &#123;</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const &#123; res &#125; = this;</span><br><span class=\"line\">    // 如果出错那么之前中间件或者其他地方设置的 HTTP 头部就无效了, 应该清空设置</span><br><span class=\"line\">    if (typeof res.getHeaderNames === &apos;function&apos;) &#123;</span><br><span class=\"line\">      res.getHeaderNames().forEach(name =&gt; res.removeHeader(name));</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      res._headers = &#123;&#125;; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    this.set(err.headers);</span><br><span class=\"line\">    // 出错后响应类型为 text/plain</span><br><span class=\"line\">    this.type = &apos;text&apos;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 对 ENOENT 错误进行处理, ENOENT 的错误 message 是文件或者路径不存在, 所以状态码应该是 404</span><br><span class=\"line\">    if (&apos;ENOENT&apos; == err.code) err.status = 404;</span><br><span class=\"line\">    // 默认设置状态码为 500</span><br><span class=\"line\">    if (&apos;number&apos; != typeof err.status || !statuses[err.status]) err.status = 500;</span><br><span class=\"line\"></span><br><span class=\"line\">    const code = statuses[err.status];</span><br><span class=\"line\">    const msg = err.expose ? err.message : code;</span><br><span class=\"line\">    this.status = err.status;</span><br><span class=\"line\">    this.length = Buffer.byteLength(msg);</span><br><span class=\"line\">    this.res.end(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h3 id=\"request-js-和-response-js\"><a href=\"#request-js-和-response-js\" class=\"headerlink\" title=\"request.js 和 response.js\"></a>request.js 和 response.js</h3><p><code>request.js</code>和<code>response.js</code>主要是对原生的http模块的requets和response对象进行封装, 其实就是对request和response对象某些属性或方法通过重写<code>getter/setter</code>函数进行代理。<br>因为重写封装的比较多，所以具体的也不多说了，有兴趣可以看看源码：<br><a href=\"https://github.com/koajs/koa/blob/master/lib/request.js\" target=\"_blank\" rel=\"noopener\">koa的request.js</a><br><a href=\"https://github.com/koajs/koa/blob/master/lib/response.js\" target=\"_blank\" rel=\"noopener\">koa的response.js</a></p>\n","prev":{"title":"一探Webpack模块化机制","slug":"一探Webpack模块化机制"},"next":{"title":"浅谈前端数据流管理方案（五）——Rxjs篇","slug":"浅谈前端数据流管理方案（五）——Rxjs篇"}}