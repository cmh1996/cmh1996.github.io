{"title":"jQuery源码学习——笔记","date":"2017-08-01T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1540309211036&di=f63653ce49168dce6c0bba026cf623b2&imgtype=0&src=http%3A%2F%2Fimgsrc.baidu.com%2Fforum%2Fw%3D580%2Fsign%3D1369fd766f224f4a5799731b39f69044%2Fed57ed1f4134970a91dc9b7f97cad1c8a6865db3.jpg","excerpt":"","slug":"jQuery源码学习笔记","comments":true,"dropcap":true,"tags":["jquery"],"categories":["js"],"updated":"2018-10-25T11:44:31.003Z","content":"<h3 id=\"1-立即调用表达式\"><a href=\"#1-立即调用表达式\" class=\"headerlink\" title=\"1.立即调用表达式\"></a>1.立即调用表达式</h3><p>任何库与框架设计的第一个要点就是解决命名空间与变量污染的问题。jQuery就是利用了JavaScript函数作用域的特性，采用立即调用表达式包裹了自身的方法来解决这个问题。</p>\n<p><strong>写法1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(window,factory)&#123;</span><br><span class=\"line\">    factory(window);</span><br><span class=\"line\">&#125;(this,function()&#123;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        //jQuery调用</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>写法1主要是为了判断jQuery在不同平台的下的加载逻辑，主流的库一般都有对 AMD 和 CommonJS 的支持代码。</p>\n<p><strong>写法2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var factory = function()&#123;</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var jQuery = factory();</span><br></pre></td></tr></table></figure>\n<p><strong>写法3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(window,undefined)&#123;</span><br><span class=\"line\">    var jQuery = function()&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    window.jQuery = window.$ = jQuery;</span><br><span class=\"line\">&#125;)(window);</span><br></pre></td></tr></table></figure>\n<p>传递参数undefined的原因是：<br>Javascript 中的undefined并不是作为关键字，因此可以允许用户对其赋值，为了避免有人在外面给undefined赋了值，所以我们就把它设置为参数。设置undefined参数后，函数内部它默认就是undefined，不会产生歧义。</p>\n<hr>\n<h3 id=\"2-处理兼容性\"><a href=\"#2-处理兼容性\" class=\"headerlink\" title=\"2.处理兼容性\"></a>2.处理兼容性</h3><p>ie9以前的浏览器对xmlNode.method的存在检测有问题，如window.a == undefined达不到检测效果，而用typeof window.a == ‘undefined’能达到效果。</p>\n<hr>\n<h3 id=\"3-jq的面向对象的写法\"><a href=\"#3-jq的面向对象的写法\" class=\"headerlink\" title=\"3.jq的面向对象的写法\"></a>3.jq的面向对象的写法</h3><p>在jquery源码里面，面向对象的写法是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jQuery()&#123;</span><br><span class=\"line\">    //这样写就能实现调用jQuery的时候，直接调用初始化方法，生成实例，这就省去了jq.init()这一步。</span><br><span class=\"line\">    return new jQuery.prototype.init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">jQuery.prototype.init = function()&#123;&#125;;</span><br><span class=\"line\">jQuery.prototype.css = function()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//把init方法的原型指向jQuery的原型，使得它们共享一份原型，所以也就使得init可以用到jQuery原型上的方法了</span><br><span class=\"line\">jQuery.prototype.init.prototype = jQuery.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\">//就可以这样调用了</span><br><span class=\"line\">jQuery().css();</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"4-prototype两种写法的差异\"><a href=\"#4-prototype两种写法的差异\" class=\"headerlink\" title=\"4.prototype两种写法的差异\"></a>4.prototype两种写法的差异</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这是往原型上去添加或修改属性、方法</span><br><span class=\"line\">A.prototype.age = 18;</span><br><span class=\"line\">A.prototype.name = &apos;lala&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//这是重写原型，会覆盖掉默认生成的A.prototype.constructor，所以要把constructor写上</span><br><span class=\"line\">A.prototype = &#123;</span><br><span class=\"line\">    constructor:A,</span><br><span class=\"line\">    age:18,</span><br><span class=\"line\">    name:&apos;lala&apos;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"5-init方法的参数处理\"><a href=\"#5-init方法的参数处理\" class=\"headerlink\" title=\"5.init方法的参数处理\"></a>5.init方法的参数处理</h3><p>我们在jQuery中用$()用得很多，它实际上调用的是jQuery的init方法，它可以接受以下这么几种参数，接受不同的参数，它的处理方式也是不一样的：</p>\n<p>1.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;&quot;),$(null),$(undefined),$(false)</span><br></pre></td></tr></table></figure></p>\n<p>这种情况就直接return this，不做其他处理。</p>\n<p>2.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;&lt;li&gt;1&lt;/li&gt;&quot;),$(&quot;&lt;div&gt;&quot;),$(&quot;#div1&quot;),$(&quot;div&quot;),$(&quot;#div1 div.box&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>遇到这种参数是字符串的，就会经过一系列判断、处理，最终生成这么一个对象格式：this = {0:’li’,1:’li’,length:2}。</p>\n<p>(1)参数是字符串且匹配&lt;&gt;括号，说明是创建元素，那就调用parseHTML方法把它转化为元素节点数组，再调用merge方法转成上面所说到的this对象。</p>\n<p>(2)参数是一个id选择器的，那就调用原生js的getElementById来获取它，然后也是再转化为this对象。</p>\n<p>(3)参数是复杂多重选择器的，那就调用find方法（实现逻辑参见sizzle）来获取到元素节点。</p>\n<p>3.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(this),$(document)</span><br></pre></td></tr></table></figure></p>\n<p>这种就会判断参数是不是一个node，是的话也是生成一个this对象。</p>\n<p>4.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(function()&#123;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>如果参数是一个函数，就会在ready方法的回调中执行这个函数</p>\n<p>5.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$([]),$(&#123;&#125;)</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"6-pushStack方法\"><a href=\"#6-pushStack方法\" class=\"headerlink\" title=\"6.pushStack方法\"></a>6.pushStack方法</h3><p>jq对象的入栈（在slice,eq,map等方法中都是调用到这个方法）<br>它是一个栈结构，会先处理后入栈的对象，调用end()方法就会回溯到前一个对象</p>\n<hr>\n<h3 id=\"7-extend和-fn-extend\"><a href=\"#7-extend和-fn-extend\" class=\"headerlink\" title=\"7.$.extend和$.fn.extend\"></a>7.$.extend和$.fn.extend</h3><p>jq里面的继承是拷贝继承</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//扩展工具方法</span><br><span class=\"line\">$.extend(&#123;</span><br><span class=\"line\">    a:function()&#123;&#125;,</span><br><span class=\"line\">    b:function()&#123;&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//调用：</span><br><span class=\"line\">$.a();</span><br><span class=\"line\">$.b();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//扩展jq实例方法</span><br><span class=\"line\">$.fn.extend(&#123;</span><br><span class=\"line\">    a:function()&#123;&#125;,</span><br><span class=\"line\">    b:function()&#123;&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//调用：</span><br><span class=\"line\">$().a();</span><br><span class=\"line\">$().b();</span><br><span class=\"line\"></span><br><span class=\"line\">//对一个对象进行扩展</span><br><span class=\"line\">var a = &#123;&#125;;</span><br><span class=\"line\">$.extend(a,&#123;age:18&#125;,&#123;name:&apos;lala&apos;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//深浅拷贝</span><br><span class=\"line\">$.extend(a,b);//浅拷贝</span><br><span class=\"line\">$.extend(true,a,b);//深拷贝</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"8-extend方法详解\"><a href=\"#8-extend方法详解\" class=\"headerlink\" title=\"8.extend方法详解\"></a>8.extend方法详解</h3><p><strong>(1)生成唯一字符串(内部)</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.expando</span><br></pre></td></tr></table></figure></p>\n<p><strong>(2)解决冲突</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.noConflict()</span><br><span class=\"line\">//写到上一个插件前面</span><br><span class=\"line\">var aaa=$.noConflict();</span><br><span class=\"line\">aaa(function()&#123;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>(3)ready回调</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(function()&#123;&#125;) </span><br><span class=\"line\">相当于</span><br><span class=\"line\">$(document).ready(function()&#123;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>DOM加载完就执行，它通过判断document.readyState或者给document加一个DOMContentLoaded事件监听来触发调用。<br>（ps：可以通过holdReady来控制同步异步，它的实现方式是以计数的方式判断是否能执行下去）</p>\n<p><strong>(4)isWindow方法用来判断是不是window对象</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isWindow:function(obj)&#123;</span><br><span class=\"line\">    return obj!=null &amp;&amp; obj===obj.window;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(5)isNumeric方法用来判断是不是数值</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isNumeric:function(obj)&#123;</span><br><span class=\"line\">    return !isNaN(parseFloat(obj)) &amp;&amp; isFinite(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(6)isPlainObject判断是不是对象自变量</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isPlainObject:function(obj)&#123;</span><br><span class=\"line\">    if(jQuery.type(obj)!==&quot;object&quot; || obj.nodeType || jQuery.isWindow(obj))&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        if(obj.constructor &amp;&amp; !core_hasOwn.call(obj.constructor.prototype,&quot;isPrototypeOf&quot;))&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; catch(e)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(7)parseHTML方法把标签字符串转换为html元素节点数组</strong></p>\n<p>判断逻辑：</p>\n<p>1.先用正则判断是不是单标签，是单标签就直接createElement</p>\n<p>2.多标签就调用buildFragment</p>\n<p><strong>(8)globalEval方法在全局执行传递进去的字符串参数</strong></p>\n<p>判断逻辑：</p>\n<p>如果是严格模式，那就新建一个script标签，标签里的内容是参数的内容，然后插入到文档中。</p>\n<p>如果不是那就直接eval（因为严格模式下eval有自身的作用域，不是全局的作用域）</p>\n<p><strong>(9)camelCase转驼峰写法（ps：ms前缀与众不同）</strong></p>\n<p>ps:replace方法第二个参数可以是一个函数，这个函数有4个参数可以传入：第一个参数：正则所匹配到的字符；第二个参数：捕获括号所捕获到的字符；<br>第三个参数：正则匹配到的每段字符的第一个字符的索引；第四个参数：用于匹配的字符串主体；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">camelCase:function(str)&#123;</span><br><span class=\"line\">    return str.replace(/^-ms-/,&quot;ms-&quot;).replace(/-([\\da-z])/gi,(all,letter)=&gt;&#123;</span><br><span class=\"line\">        return letter.toUpperCase();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(10)nodeName方法判断节点的nodename</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nodeName:function(elem,name)&#123;</span><br><span class=\"line\">    return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase()===name.toLowerCase();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(11)merge方法合并两个数组或形如{0:’a’,1:’b’,length:2}</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">merge:function(first,second)&#123;</span><br><span class=\"line\">    var l = second.length,</span><br><span class=\"line\">        i = first.length,</span><br><span class=\"line\">        j = 0;</span><br><span class=\"line\">    if(typeof l===&quot;number&quot;)&#123;</span><br><span class=\"line\">        for(;j&lt;l;j++)&#123;</span><br><span class=\"line\">            first[i++] = second[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        while(second[j]!==undefined)&#123;</span><br><span class=\"line\">            first[i++] = second[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    first.length = i;</span><br><span class=\"line\">    return first;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>(12)$(‘#div1’).width()</strong></p>\n<p>它能够获取到即使display为none的元素的宽度，原生的offsetWidth是获取不到的</p>\n<p>它的做法是先把display:none存起来，然后给元素加上display:block;visibility:hidden;position:absolute再获取它的offsetWidth，获取到之后再把刚才存起来的display:none还原，实现“偷梁换柱”（其实这种操作是依靠swap函数来实现的）</p>\n<hr>\n<h3 id=\"9-Callbacks-回调执行了解一下\"><a href=\"#9-Callbacks-回调执行了解一下\" class=\"headerlink\" title=\"9.$.Callbacks()回调执行了解一下\"></a>9.$.Callbacks()回调执行了解一下</h3><p>用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cb = $.Callbacks(options);</span><br><span class=\"line\">options可以是：&apos;once&apos;,&apos;memory&apos;,&apos;unique&apos;,&apos;stopOnFalse&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">//往回调数组中添加函数</span><br><span class=\"line\">function a()&#123;&#125;</span><br><span class=\"line\">function b()&#123;&#125;</span><br><span class=\"line\">cb.add(a);</span><br><span class=\"line\">cb.add(b);</span><br><span class=\"line\"></span><br><span class=\"line\">//依次调用</span><br><span class=\"line\">cb.fire();</span><br></pre></td></tr></table></figure></p>\n<p>首先有一个list数组来保存callbacks</p>\n<p><strong>(0)options配置参数：</strong></p>\n<p>once代表只能fire一次；</p>\n<p>memory代表即使你的add在fire后面添加，但是也还能生效，他的实现原理是在add方法里面加上fire；</p>\n<p>unique代表对list去重;</p>\n<p>stopOnFlase代表如果回调函数里有return false的话，那就停止后面的执行。</p>\n<p><strong>(1)add方法：</strong><br>往list里面push回调函数</p>\n<p><strong>(2)remove方法：</strong><br>对list进行splice操作来移除某个回调函数</p>\n<p><strong>(3)fire方法：</strong><br>遍历list，依次执行</p>\n<hr>\n<h3 id=\"10-Deferred-处理异步流程\"><a href=\"#10-Deferred-处理异步流程\" class=\"headerlink\" title=\"10.$.Deferred()处理异步流程\"></a>10.$.Deferred()处理异步流程</h3><p>实际上也是调用$.Callbacks()来处理。</p>\n<p>用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dfd = $.Deferred();</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    alert(1);</span><br><span class=\"line\">    dfd.resolve();  //这是成功触发，另外还有失败触发标志reject</span><br><span class=\"line\">&#125;,1000);</span><br><span class=\"line\">dfd.done(function()&#123;</span><br><span class=\"line\">    alert(2);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">dfd.fail(function()&#123;</span><br><span class=\"line\">    alert(3);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>done,fail方法对应callbacks的add方法，resolve,reject方法对应callbacks的fire方法。</p>\n<p>resolve,done实际上对应的是$.Callbacks(‘once memory’)，有once是为了使状态不可逆，只触发一次；</p>\n<p>reject,fail实际上对应的是$.Callbacks(‘once memory’)，有once是为了使状态不可逆，只触发一次；</p>\n<p>notify,progress实际上对应的是$.Callbacks(‘memory’)。</p>\n<p>内部还有一个自定义的promise对象来新增一些协助函数方法，它跟deferred不一样的地方就是它没有那三种状态，防止调用这个方法的时候把状态给改了。</p>\n<p><strong>$.when()方法：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//相当于promise.all</span><br><span class=\"line\">$.when(a(),b()).done(function()&#123;</span><br><span class=\"line\">    alert(&apos;success&apos;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>它会把参数放进一个数组里面并执行，内部有一个计数器，数值等于数组长度，每有一个参数完成计数器就减一，当计数器为0时那就执行内部新建的$.Deferred()</p>\n<hr>\n<h3 id=\"11-通过support进行功能检测\"><a href=\"#11-通过support进行功能检测\" class=\"headerlink\" title=\"11.通过support进行功能检测\"></a>11.通过support进行功能检测</h3><p>作为兼容性功能的判断实现，主要有样式兼容、h5兼容、js兼容等等。可以通过创建一些元素来检测不同浏览器下这些元素的表现行为、属性方法有什么异同，检测完之后就可以把元素给删掉。</p>\n<p>而针对不同环境下作出不同的反应是通过hooks实现的，support只是一个兼容判断。</p>\n<hr>\n<h3 id=\"12-attr、prop和data\"><a href=\"#12-attr、prop和data\" class=\"headerlink\" title=\"12.attr、prop和data\"></a>12.attr、prop和data</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#div1&apos;).attr(&apos;name&apos;,&apos;lala&apos;);</span><br><span class=\"line\">相当于</span><br><span class=\"line\">document.getElementById(&apos;div1&apos;).setAttribute(&apos;name&apos;,&apos;lala&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">$(&apos;#div1&apos;).prop(&apos;name&apos;,&apos;lala&apos;);</span><br><span class=\"line\">相当于</span><br><span class=\"line\">document.getElementById(&apos;div1&apos;).name=&apos;lala&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//当然不会这么简单直接设置，它们还会检测参数合法性，解决浏览器兼容问题等等</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这样不会内存泄漏</span><br><span class=\"line\">$(&apos;#div1&apos;).data(&apos;name&apos;,obj);</span><br><span class=\"line\">//这样有可能会内存泄漏</span><br><span class=\"line\">$(&apos;#div1&apos;).attr(&apos;name&apos;,obj);</span><br><span class=\"line\"></span><br><span class=\"line\">//ps：DOM元素和对象之间相互引用，大部分浏览器就会出现内存泄漏</span><br><span class=\"line\">var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class=\"line\">var obj = &#123;&#125;;</span><br><span class=\"line\">div1.name = obj;</span><br><span class=\"line\">obj.age = div1;</span><br></pre></td></tr></table></figure>\n<p>data方法是怎么做到消除内存泄漏的呢？</p>\n<p>其实它是先新建一个cache对象来存放一种对应联系，建立元素绑定的属性和你自定义要绑定进去的属性之间的联系，就是说这是一种间接绑定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//cache就是类似于以下这样的结构</span><br><span class=\"line\">this.cache=&#123;</span><br><span class=\"line\">    1:&#123;name:&apos;lala&apos;&#125;,</span><br><span class=\"line\">    2:&#123;name:&apos;lala&apos;,age:19&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//它会给每个data分配一个映射到实际属性的key：1、2、3...，同一个元素分配到的都是同一个key</span><br><span class=\"line\">//元素上挂载的实际上是类似于这样的东西：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div jquery784382547239469837=&quot;1&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//当this不是元素或者document节点时，这个cache会通过Object.defineProperty设置一个key为0，getter为&#123;&#125;的属性，这是处理非元素节点时用的</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"13-jQuery的queue\"><a href=\"#13-jQuery的queue\" class=\"headerlink\" title=\"13.jQuery的queue\"></a>13.jQuery的queue</h3><p>跟数据结构里的队列是一样的，只不过它存放的是函数，出队列的时候就会调用这个函数,要前一个函数出了队列才会执行下一个函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//多个动画animate就用到了queue</span><br><span class=\"line\">$(this).animate(&#123;width:300&#125;,2000);</span><br><span class=\"line\">$(this).animate(&#123;height:100&#125;,2000);</span><br><span class=\"line\">$(this).animate(&#123;left:500&#125;,2000);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"14-对class的操作\"><a href=\"#14-对class的操作\" class=\"headerlink\" title=\"14.对class的操作\"></a>14.对class的操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#div1&apos;).addClass(&apos;box1 box2&apos;);</span><br><span class=\"line\">$(&apos;#div1&apos;).removeClass(&apos;box1 box2&apos;);</span><br><span class=\"line\">$(&apos;#div1&apos;).toggleClass(&apos;box1 box2&apos;);</span><br></pre></td></tr></table></figure>\n<p>addClass实际上是对传进来的字符串进行检验、分割，然后再用indexOf判断元素原来的class里面有没有新增的class，没有才添加进去，有就不管。</p>\n","prev":{"title":"web性能优化","slug":"web性能优化"},"next":{"title":"fl效果器","slug":"fl效果器"}}