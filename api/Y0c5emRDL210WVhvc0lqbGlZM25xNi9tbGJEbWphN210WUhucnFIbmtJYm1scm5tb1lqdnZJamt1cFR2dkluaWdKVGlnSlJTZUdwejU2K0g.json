{"title":"浅谈前端数据流管理方案（五）——Rxjs篇","date":"2018-05-27T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1524818817776&di=dfc0c4149f33224c5ffe3112df02fb6a&imgtype=0&src=http%3A%2F%2Fimgsrc.baidu.com%2Fimgad%2Fpic%2Fitem%2F21a4462309f790525bd51d0207f3d7ca7acbd5c0.jpg","excerpt":"","slug":"浅谈前端数据流管理方案（五）——Rxjs篇","comments":true,"dropcap":false,"tags":["前端数据流","Rxjs"],"categories":["js"],"updated":"2018-09-11T05:59:57.987Z","content":"<h2 id=\"Rxjs\"><a href=\"#Rxjs\" class=\"headerlink\" title=\"Rxjs\"></a>Rxjs</h2><p>下面我们来说说第三个流派，响应式observable流式流派。代表库有RXJS，它是Observable的Javascript实现，是一个强大的Reactive编程（面向数据流和变化传播的编程范式）库，提供了强大的数据流组合与控制能力。</p>\n<p>它给人最直观的感觉就是通过链式操作让数据流动起来，把观察者模式和迭代器模式结合起来：数据源有变化的话就通知下游，通知的方式则是采用了迭代器中的next思想。它通常不会有取值这个操作，因为它是push-based的，下游obsever被动接受observable传来的数据。</p>\n<hr>\n<h3 id=\"Rxjs擅长做什么？\"><a href=\"#Rxjs擅长做什么？\" class=\"headerlink\" title=\"Rxjs擅长做什么？\"></a>Rxjs擅长做什么？</h3><ol>\n<li>同步和异步的“和谐共处”。它把用于实现某一功能的同步异步方法按一定顺序组合到一起，使得两者执行起来有条不紊。</li>\n<li>可组合的数据变更过程。当多个复杂的异步或者事件组合到一起的时候，它能够按一定顺序去处理多个数据序列。</li>\n<li>数据和视图的精确绑定。在observable中可以把DOM事件作为数据源，而在observer中也可以执行更新视图的操作。</li>\n<li>在操作时间轴方面得心应手。Rxjs提供的几个操作时间轴的Operator（delay,timeout,throttle,debounce,audit,bufferTime等等）使得我们对同步异步的处理更加随心所欲。</li>\n<li>在多个服务端实时消息流的应用场景中，我们可以把数据源通过 Rx 进行高阶处理，最后到 view 层就是很清晰的一个 Observable。</li>\n</ol>\n<hr>\n<h3 id=\"Rxjs的几个角色\"><a href=\"#Rxjs的几个角色\" class=\"headerlink\" title=\"Rxjs的几个角色\"></a>Rxjs的几个角色</h3><p>我们先通过Rxjs的几个角色，几种概念来去认识它。</p>\n<h4 id=\"Observable-被观察者，管道入口\"><a href=\"#Observable-被观察者，管道入口\" class=\"headerlink\" title=\"Observable 被观察者，管道入口\"></a>Observable 被观察者，管道入口</h4><p>它是一个数据或事件的流的集合，就像一个序列，里面的数据源会按顺序依次推送到下游，也可以同时处理同步和异步的操作。<br>虽然它跟观察者模式的observable名字一样，但是具体上还是有所区别：这里的observable没有一份需要维护的订阅者的列表，它只是一个函数，如果你想要订阅它的话，只需要通过subscribe()把observer传进回调函数就好了。<br>创建observable的方式：</p>\n<ul>\n<li>单值：of，empty，never</li>\n<li>多值：from</li>\n<li>定时：interval，timer</li>\n<li>事件：fromEvent</li>\n<li>promise：fromPromise</li>\n<li>自定义：create</li>\n</ul>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var observable = Rx.Observable</span><br><span class=\"line\">// 通过create方法创建一个Observable</span><br><span class=\"line\">// 回调函数会接受observer参数，也就是观察者角色</span><br><span class=\"line\">    .create(function(observer) &#123;</span><br><span class=\"line\">        observer.next(&apos;hi&apos;);</span><br><span class=\"line\">        observer.next(&apos;world&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            observer.next(&apos;这一段是异步操作&apos;);</span><br><span class=\"line\">        &#125;, 30)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 订阅这个 observable</span><br><span class=\"line\">// 只有在订阅之后，才会在流Observable变化的时候，调用observer提供的方法，并通知他 </span><br><span class=\"line\">// 订阅之后也可以取消订阅，调用unsubscribe()即可</span><br><span class=\"line\">console.log(&apos;start&apos;)</span><br><span class=\"line\">var subscription = observable.subscribe(function(value) &#123;</span><br><span class=\"line\">    console.log(value);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&apos;end&apos;)</span><br><span class=\"line\">setTimeOut(()=&gt; &#123;</span><br><span class=\"line\">  subscription.unsubscribe()</span><br><span class=\"line\">&#125;, 5000)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 程序会依次输出</span><br><span class=\"line\">&apos;start&apos;</span><br><span class=\"line\">&quot;hi&quot;</span><br><span class=\"line\">&apos;world&apos;</span><br><span class=\"line\">&apos;end&apos;</span><br><span class=\"line\">&apos;这一段是异步操作&apos;</span><br></pre></td></tr></table></figure></p>\n<p>Rx 中的 Observable 对象默认是 lazy 且 cold 的，lazy 说的是如果 Observable 对象的 subscribe 方法没有被调用，那么 Producer 函数也就不会被调用。cold 是说每调用一次 subscribe 方法，就会执行一次 Producer 来产生一个新的 Subscription 流，也就是不同的 Subscription 流内的状态不会相互影响。（ps：它也可以是hot的，调用share这个API来实现）<br>举个栗子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let interval = Rx.Observable.create(observer =&gt; &#123; </span><br><span class=\"line\">setInterval(() =&gt; observer.next(), 1000) </span><br><span class=\"line\">&#125;).scan(x =&gt; x+1, 0); //累加器，从 0 开始，类似在内部定义了一个count，然后每次count++ </span><br><span class=\"line\">// 1, 2, 3... </span><br><span class=\"line\">interval.subscribe(count =&gt; console.log(&apos;count1:&apos;+count)); </span><br><span class=\"line\">setTimeout(() =&gt; &#123; </span><br><span class=\"line\">// 3s 后监听，同样得到 1, 2, 3... 而不是 4, 5, 6..</span><br><span class=\"line\">interval.subscribe(count =&gt; console.log(&apos;count2:&apos;+count)); </span><br><span class=\"line\">&#125;, 3000);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Operator-对数据流的操作器\"><a href=\"#Operator-对数据流的操作器\" class=\"headerlink\" title=\"Operator 对数据流的操作器\"></a>Operator 对数据流的操作器</h4><p>可以用来对observable进行各种各样的操作。接受传进来的observable，通过操作后返回新的observable（这有点像immutable）。<br>操作符：</p>\n<ul>\n<li>改变数据值：map，mapTo</li>\n<li>过滤：filter，skip，first，last，take</li>\n<li>操作时间轴：delay，timeout，throttle，debounce，audit，bufferTime</li>\n<li>累加：scan</li>\n<li>异常处理：throw，catch</li>\n<li>条件执行：takeUntil，delayWhen，observeOn</li>\n<li>多个数据的合并操作：concat，merge，combineLatest，withLatestFrom，zip</li>\n</ul>\n<h4 id=\"Scheduler-控制Observable订阅开始执行和数据送达的时机\"><a href=\"#Scheduler-控制Observable订阅开始执行和数据送达的时机\" class=\"headerlink\" title=\"Scheduler 控制Observable订阅开始执行和数据送达的时机\"></a>Scheduler 控制Observable订阅开始执行和数据送达的时机</h4><p>一般有这么几种Scheduler：</p>\n<ul>\n<li>queue：把递归阻塞。</li>\n<li>asap：as soon as possible，表现形式为setTimeout(()=&gt;{},0)。多用于永不退订的observable，例如轮询。</li>\n<li>async：使observable执行方式变为异步。</li>\n<li>animationFrame：适合高频率UI动画触发，用requestAnimationFrame实现的。<br>使用例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var observable = Rx.Observable.create(function (observer) &#123;</span><br><span class=\"line\">    observer.next(1);</span><br><span class=\"line\">    observer.next(2);</span><br><span class=\"line\">    observer.next(3);</span><br><span class=\"line\">    observer.complete();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;before subscribe&apos;);</span><br><span class=\"line\">observable.observeOn(Rx.Scheduler.async) // 本来是同步的，变成了异步</span><br><span class=\"line\">.subscribe(&#123;</span><br><span class=\"line\">    next: (value) =&gt; &#123; console.log(value); &#125;,</span><br><span class=\"line\">    error: (err) =&gt; &#123; console.log(&apos;Error: &apos; + err); &#125;,</span><br><span class=\"line\">    complete: () =&gt; &#123; console.log(&apos;complete&apos;); &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&apos;after subscribe&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// &quot;before subscribe&quot;</span><br><span class=\"line\">// &quot;after subscribe&quot;</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// 3</span><br><span class=\"line\">// &quot;complete&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Subject-数据流管道的分岔接口，可进可出\"><a href=\"#Subject-数据流管道的分岔接口，可进可出\" class=\"headerlink\" title=\"Subject 数据流管道的分岔接口，可进可出\"></a>Subject 数据流管道的分岔接口，可进可出</h4><p>Subject可以向多个observer多路推送数据。每个subject既可以是一个observerable，也可以是一个observer。subject内部有一份它下游的observer的列表，在接收到上游传过来的值时，就会遍历这份列表并把值传递下去。<br>普通的subject:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建一个Observable，一秒钟输出一个数字，只取三个就结束</span><br><span class=\"line\">var source = Rx.Observable.interval(1000).take(3);</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义两个observer对象</span><br><span class=\"line\">var observerA = &#123;</span><br><span class=\"line\">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class=\"line\">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class=\"line\">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var observerB = &#123;</span><br><span class=\"line\">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class=\"line\">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class=\"line\">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建一个subject —— 特殊的Observable</span><br><span class=\"line\">var subject = new Rx.Subject()</span><br><span class=\"line\"></span><br><span class=\"line\">// observerA订阅Subject</span><br><span class=\"line\">subject.subscribe(observerA)</span><br><span class=\"line\"></span><br><span class=\"line\">// Subject又以observer的身份订阅Observable</span><br><span class=\"line\">source.subscribe(subject);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    subject.subscribe(observerB);</span><br><span class=\"line\">&#125;, 1000);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出：</span><br><span class=\"line\">// &quot;A next: 0&quot;</span><br><span class=\"line\">// &quot;A next: 1&quot;</span><br><span class=\"line\">// &quot;B next: 1&quot;</span><br><span class=\"line\">// &quot;A next: 2&quot;</span><br><span class=\"line\">// &quot;B next: 2&quot;</span><br><span class=\"line\">// &quot;A complete!&quot;</span><br><span class=\"line\">// &quot;B complete!&quot;</span><br><span class=\"line\"> A、B两个observer互不影响，是独立的</span><br></pre></td></tr></table></figure></p>\n<p>除了基本的subject外，它还有这么几种类型：</p>\n<ol>\n<li><p>BehaviorSubject：初始化的时候传入一个参数作为当前值，执行过后它会把最新的值记住，作为当前值，因此它是有状态的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// BehaviorSubject 在建立时就需要给定一个状态，并在之后任何一次订阅，就会先送出最新的状态。其实这种行为就是一种状态的表达而非单存的事件，就像是年龄跟生日一样，年龄是一种状态而生日就是事件；所以当我们想要用一个stream 来表达年龄时，就应该用BehaviorSubject 。</span><br><span class=\"line\"></span><br><span class=\"line\">var subject = new Rx.BehaviorSubject(0); // 0</span><br><span class=\"line\">var observerA = &#123;</span><br><span class=\"line\">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class=\"line\">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class=\"line\">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var observerB = &#123;</span><br><span class=\"line\">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class=\"line\">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class=\"line\">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">subject.subscribe(observerA);</span><br><span class=\"line\">// &quot;A next: 0&quot;</span><br><span class=\"line\">subject.next(1);</span><br><span class=\"line\">// &quot;A next: 1&quot;</span><br><span class=\"line\">subject.next(2);</span><br><span class=\"line\">// &quot;A next: 2&quot;</span><br><span class=\"line\">subject.next(3);</span><br><span class=\"line\">// &quot;A next: 3&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    subject.subscribe(observerB); </span><br><span class=\"line\">    // &quot;B next: 3&quot;</span><br><span class=\"line\">&#125;,3000)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ReplaySubject：在有新订阅时，重新发送最后的n个值，n是你传进来的参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var subject = new Rx.ReplaySubject(2); // 重复发送最后俩个元素</span><br><span class=\"line\">var observerA = &#123;</span><br><span class=\"line\">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class=\"line\">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class=\"line\">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var observerB = &#123;</span><br><span class=\"line\">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class=\"line\">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class=\"line\">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">subject.subscribe(observerA);</span><br><span class=\"line\">subject.next(1);</span><br><span class=\"line\">// &quot;A next: 1&quot;</span><br><span class=\"line\">subject.next(2);</span><br><span class=\"line\">// &quot;A next: 2&quot;</span><br><span class=\"line\">subject.next(3);</span><br><span class=\"line\">// &quot;A next: 3&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    subject.subscribe(observerB);</span><br><span class=\"line\">    // &quot;B next: 2&quot;</span><br><span class=\"line\">    // &quot;B next: 3&quot;</span><br><span class=\"line\">&#125;,3000)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>AsyncSubject：它会一直等等到complete后才会传值，传递最后一个值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var subject = new Rx.AsyncSubject();</span><br><span class=\"line\">var observerA = &#123;</span><br><span class=\"line\">    next: value =&gt; console.log(&apos;A next: &apos; + value),</span><br><span class=\"line\">    error: error =&gt; console.log(&apos;A error: &apos; + error),</span><br><span class=\"line\">    complete: () =&gt; console.log(&apos;A complete!&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var observerB = &#123;</span><br><span class=\"line\">    next: value =&gt; console.log(&apos;B next: &apos; + value),</span><br><span class=\"line\">    error: error =&gt; console.log(&apos;B error: &apos; + error),</span><br><span class=\"line\">    complete: () =&gt; console.log(&apos;B complete!&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">subject.subscribe(observerA);</span><br><span class=\"line\">subject.next(1);</span><br><span class=\"line\">subject.next(2);</span><br><span class=\"line\">subject.next(3);</span><br><span class=\"line\">subject.complete();</span><br><span class=\"line\">// &quot;A next: 3&quot;</span><br><span class=\"line\">// &quot;A complete!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    subject.subscribe(observerB);</span><br><span class=\"line\">    // &quot;B next: 3&quot;</span><br><span class=\"line\">    // &quot;B complete!&quot;</span><br><span class=\"line\">&#125;,3000)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"Observer-观察者，只进不出\"><a href=\"#Observer-观察者，只进不出\" class=\"headerlink\" title=\"Observer 观察者，只进不出\"></a>Observer 观察者，只进不出</h4><p>接受上游数据，并作出相应的反应。它的表现形式与迭代器模式相对应，形如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var observer = &#123;</span><br><span class=\"line\">    next:function(value)&#123;&#125;, //接收到observable的数据时触发</span><br><span class=\"line\">    error:function(err)&#123;&#125;,  //接收到错误时触发</span><br><span class=\"line\">    complete:function()&#123;&#125;   //执行完毕的时候触发(处理完所有的next后)，complete一旦执行后，next就不会再执行了</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"Rxjs流程图\"><a href=\"#Rxjs流程图\" class=\"headerlink\" title=\"Rxjs流程图\"></a>Rxjs流程图</h3><p><img src=\"https://user-gold-cdn.xitu.io/2017/8/1/e66826df704255809a7e9477996d60d7?imageslim\" alt=\"Rxjs\"></p>\n<hr>\n<h3 id=\"Observable和Promise的区别\"><a href=\"#Observable和Promise的区别\" class=\"headerlink\" title=\"Observable和Promise的区别\"></a>Observable和Promise的区别</h3><p>它们都可以用于对副作用进行归一化，但加以比较的话，使用 rxjs 来做更为适合。<br>首先事件机制与 rxjs 很像，另外 promise 只能返回一次，而且之后 resolve reject 两种状态，而 Observable 可以返回多次，而且没有内置的状态，所以可以更加灵活的表示状态。<br>我们可以把Observable看成是一个有可变数据量的Promise，而Promise只能处理一个数据。<br>在分发和联动关系多的时候，Rxjs才能够体现出它比起Promise,Generator的优势。<br>ps：这样可以把observable转化成promise：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise = observable.toPromise();</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"Rxjs实际使用\"><a href=\"#Rxjs实际使用\" class=\"headerlink\" title=\"Rxjs实际使用\"></a>Rxjs实际使用</h3><p><strong>示例1：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Observable = Rx.Observable  </span><br><span class=\"line\">const input = document.querySelector(&apos;input&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const search$ = Observable.fromEvent(input, &apos;input&apos;)  </span><br><span class=\"line\">  .map(e =&gt; e.target.value)</span><br><span class=\"line\">  .filter(value =&gt; value.length &gt;= 1)</span><br><span class=\"line\">  .throttleTime(100)</span><br><span class=\"line\">  .distinctUntilChanged()</span><br><span class=\"line\">  .switchMap(term =&gt; Observable.fromPromise(wikiIt(term)))</span><br><span class=\"line\">  .subscribe(</span><br><span class=\"line\">    x =&gt; renderSearchResult(x),</span><br><span class=\"line\">    err =&gt; console.error(err)</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码做了以下事情：</p>\n<p>监听 input 元素的 input 事件<br>一旦发生，把事件对象 e 映射成 input 元素的值<br>接着过滤掉值长度小于 1 的<br>并且还设置了一个 throttle ( 节流器 )，两次输入间隔不超过 100 毫秒为有效输入<br>如果该值和过去最新的值相等的话，忽略他<br>最后，拿到值便调用 Wikipedia 的一个 API<br>最后的最后，需要 subscribe 才能拿到 API 返回的数据</p>\n<p><strong>示例2（拖拽）：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var box = document.getElementById(&apos;box&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var scroll = Rx.Observable.fromEvent(document, &apos;scroll&apos;);</span><br><span class=\"line\">var mouseDown = Rx.Observable.fromEvent(box, &apos;mousedown&apos;)</span><br><span class=\"line\">var mouseUp = Rx.Observable.fromEvent(document, &apos;mouseup&apos;)</span><br><span class=\"line\">var mouseMove = Rx.Observable.fromEvent(document, &apos;mousemove&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var validValue = (value, max, min) =&gt; &#123;</span><br><span class=\"line\">    return Math.min(Math.max(value, min), max)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mouseDown</span><br><span class=\"line\">    .map(e =&gt; mouseMove.takeUntil(mouseUp))</span><br><span class=\"line\">    .concatAll()</span><br><span class=\"line\">//   完整版拖拽</span><br><span class=\"line\">//     .withLatestFrom(mouseDown, (move, down) =&gt; &#123;</span><br><span class=\"line\">//         return &#123;</span><br><span class=\"line\">//             x: validValue(move.clientX - down.offsetX, window.innerWidth - 320, 0),</span><br><span class=\"line\">//             y: validValue(move.clientY - down.offsetY, window.innerHeight - 180, 0)</span><br><span class=\"line\">//         &#125;</span><br><span class=\"line\">//     &#125;)</span><br><span class=\"line\">//  简单版拖拽</span><br><span class=\"line\">    .map(event =&gt; (&#123; x: event.clientX, y: event.clientY &#125;))</span><br><span class=\"line\">    .subscribe(pos =&gt; &#123;</span><br><span class=\"line\">        box.style.top = pos.y + &apos;px&apos;;</span><br><span class=\"line\">        box.style.left = pos.x + &apos;px&apos;;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例3（实时获取时间。如果某个用户停留在某个页面时间太长，评论上的时间信息会变得不准确，比如说，用户停留了一个小时，而它看到的信息还显示：5分钟之前发表了评论，实际时间是一个小时零5分钟以前的事了。）：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.interval(1000).subscribe(() =&gt; &#123;</span><br><span class=\"line\">  this.diff = moment(createAt).fromNow()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"结合Vue，Redux的使用\"><a href=\"#结合Vue，Redux的使用\" class=\"headerlink\" title=\"结合Vue，Redux的使用\"></a>结合Vue，Redux的使用</h3><p>在 React/Vue 应用中部分使用 Rx 是完全没有问题的。思路上来说就是把 React/Vue 组件的 local state 当做一个『中介』，在一个 Rx Observable 的 subscribe 回调里面更新组件状态。通过简单的绑定库支持，可以完全把 component state 作为一个实现细节封装掉，实现 Observable -&gt; view 的声明式绑定。</p>\n<h4 id=\"结合Vue\"><a href=\"#结合Vue\" class=\"headerlink\" title=\"结合Vue\"></a>结合Vue</h4><p>比如我们可以在created时初始化一个observable，beforeDestroy时取消订阅observable。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;  </span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    time: &apos;&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  created () &#123;</span><br><span class=\"line\">    this.timer$ = Rx.Observable.interval(1000)</span><br><span class=\"line\">      .map(() =&gt; new Date())</span><br><span class=\"line\">      .map(d =&gt; moment(d).format(&apos;hh:mm:ss&apos;))</span><br><span class=\"line\">      .subscribe(t =&gt; &#123;</span><br><span class=\"line\">        this.time = t</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeDestroy () &#123;</span><br><span class=\"line\">    this.timer$.unsubscribe()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"结合Redux\"><a href=\"#结合Redux\" class=\"headerlink\" title=\"结合Redux\"></a>结合Redux</h4><p>可以通过redux-observable这个库来配合Redux。（下文会提到这个库）</p>\n<hr>\n<h3 id=\"Redux中间件redux-observable\"><a href=\"#Redux中间件redux-observable\" class=\"headerlink\" title=\"Redux中间件redux-observable\"></a>Redux中间件redux-observable</h3><p>Rxjs带来了两种新的开发方式，第一种是将一切前端副作用转化为数据源，因此副作用已经在数据源转换这一层完全隔离了，然后通过纯函数的操作，最后直接对接到 dom。另一种是类似 redux-observable，将 rxjs 数据流处理能力融合到已有数据流框架中。</p>\n<p>redux-observable 将 action 与 reducer 改造为 stream 模式，对 action 中副作用行为，比如发请求，也提供了封装好的函数转化为数据源，因此，将 redux middleware 中的副作用，转移到了数据源转换，让 action 保持纯函数，同时增强了原本就是纯函数的 reducer 的数据处理能力。</p>\n<p>如果说 redux-saga 解决了异步，那么 redux-observable 就是解决了副作用，同时赠送了 Rxjs 数据处理能力。</p>\n<p>来看看它是怎么用的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义两个action creator</span><br><span class=\"line\">// 1. 拉取某用户数据</span><br><span class=\"line\">const fetchUser = username =&gt; (&#123; type: &apos;GET_DATA&apos;, target: username &#125;);</span><br><span class=\"line\">// 2. 拉取完成</span><br><span class=\"line\">const fetchUserDone = data =&gt; (&#123; type: &apos;GET_SUCCESS&apos;, data&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个Epics函数</span><br><span class=\"line\">const fetchEpics = (action$) =&gt; &#123;</span><br><span class=\"line\">        return action$.ofType(&apos;GET_DATA&apos;)</span><br><span class=\"line\">                      .mergeMap((action)=&gt;&#123;</span><br><span class=\"line\">                          return ajax.getJson(`/api/users/$&#123;action.target&#125;`)</span><br><span class=\"line\">                      &#125;)</span><br><span class=\"line\">                      .map((data)=&gt;&#123;</span><br><span class=\"line\">                          fetchUserDone(data)</span><br><span class=\"line\">                      &#125;)</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"Rxjs跟Redux的对比\"><a href=\"#Rxjs跟Redux的对比\" class=\"headerlink\" title=\"Rxjs跟Redux的对比\"></a>Rxjs跟Redux的对比</h3><p>基于Flux实现的方案中一个很大的痛点就是它的繁琐，造成它繁琐的原因就是它的自定义action，<br>如果不从根本上对事件这种机制进行抽象，就不可能彻底解决繁琐的问题。</p>\n<p>基于Reactive理念的库天然就是为了处理对事件机制的抽象而出现的，所以用在这种场景下有奇效，它能把action的派发与处理过程描述得优雅精妙。在这样的机制里，我们可以很清楚地看到一块数据的来龙去脉，它最初是哪里来的，后来可能会被谁修改过。所有这样的数据都放置在管道中，除了指定的入口，不会有其他东西能够修改这些数据，视图可以很安全地订阅他们。</p>\n<ol>\n<li><p>数据转换逻辑。打个比方，同样是表达数据a到b这么一个转换，两者所关注的点可能是不一样的：<br>Redux：定义一个action叫做AtoB，在其实现中，把a转换成b。<br>Rx：定义两个数据流A和B，B是从A经过一次map转换得到的，map的表达式是把a转成b。</p>\n</li>\n<li><p>数据处理逻辑。在数据变更的链路较长时，Rx是具有很大优势的，它可以很简便地做多级状态变更的连接，也可以做数据变更链路的复用（比如存在a -&gt; b -&gt; c，又存在a -&gt; b -&gt; d，可以把a -&gt; b这个过程拿出来复用），还天生能处理好包括竞态在内的各种异步的情况，Redux可能要借助saga等理念才能更好地组织代码。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>经过了这个系列文章的学习后，我们发现，Redux和Rxjs完全隔离了副作用，是因为他们有一个共性，那就是对前端副作用的抽象。redux 通过在 action 做副作用，将副作用隔离在 reducer 之外，使reducer成为了纯函数。rxjs将副作用先转化为数据源，将副作用隔离在管道流处理之外。<br>唯独 mobx，缺少了对副作用抽象这一层，所以导致了代码写的比redux和rxjs更爽，但副作用与纯函数混杂在一起，因此与函数式无缘。</p>\n<p>综上，我们可以看出，现代前端数据流流动过程分为以下几个部分：<br>更新触发 -&gt; 副作用隔离 -&gt; 数据状态变更 -&gt; 视图渲染</p>\n<ul>\n<li>更新触发往往是视图层发送一个指令来传达某个状态需要改变。</li>\n<li>副作用隔离就是把一切与数据本身修改无关的指令通通隔离，使得数据变更的这一过程变得“纯净”。</li>\n<li>数据状态变更就是修改值，修改最新状态，在这里也有immutable和mutable之分。</li>\n<li>视图渲染就是状态数据更新完成后到通知视图更新数据，再到经过virtualDom,diff等优化操作后将数据映射到视图上的过程。</li>\n</ul>\n<p>写到这里，前端数据流管理方案系列也告一段落了，从对这三者在特点、流程、角色上的学习也着实能感受到数据流的严谨、科学之处，数据流管理模式的探索肯定不会就此停滞，期待未来数据流管理的发展。</p>\n<p>总而言之，数据状态管理没有银弹，不论黑猫白猫，抓到老鼠的才是好猫。(●’◡’●)</p>\n","prev":{"title":"读读Koa2源码","slug":"读读Koa2源码"},"next":{"title":"浅谈前端数据流管理方案（四）——Redux篇","slug":"浅谈前端数据流管理方案（四）——Redux篇"}}