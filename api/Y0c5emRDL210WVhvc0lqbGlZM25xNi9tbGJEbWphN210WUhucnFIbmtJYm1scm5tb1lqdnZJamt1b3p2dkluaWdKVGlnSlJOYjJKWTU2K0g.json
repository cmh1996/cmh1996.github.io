{"title":"浅谈前端数据流管理方案（二）——MobX篇","date":"2018-05-02T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1524651580961&di=4dca135f67bfcced731800cb2543a2bd&imgtype=0&src=http%3A%2F%2Fimgsrc.baidu.com%2Fimage%2Fc0%253Dshijue1%252C0%252C0%252C294%252C40%2Fsign%3Db321bfd871899e516c8332572aceb346%2F0eb30f2442a7d9334e4e8856a74bd11373f00134.jpg","excerpt":"","slug":"浅谈前端数据流管理方案（二）——MobX篇","comments":true,"dropcap":false,"tags":["前端数据流","MobX"],"categories":["js"],"updated":"2018-09-11T05:59:39.820Z","content":"<h2 id=\"MobX\"><a href=\"#MobX\" class=\"headerlink\" title=\"MobX\"></a>MobX</h2><p>Mobx专注于解决数据级别的响应，它不关系数据的来源方式，只要一个对象中的属性、一个基本类型变量发生了变化，对这些数据的订阅就会自动执行。使用Mobx管理状态时，当我们更新观察对象的状态后，由观察对象的改变带来的界面重渲染、数据序列化等一系列副作用，Mobx会自动帮我们完成。</p>\n<hr>\n<h3 id=\"Mobx的主要概念\"><a href=\"#Mobx的主要概念\" class=\"headerlink\" title=\"Mobx的主要概念\"></a>Mobx的主要概念</h3><ol>\n<li><p>Actions: 改变state的操作。</p>\n</li>\n<li><p>ObservableState:应用的可被观察的数据状态。</p>\n</li>\n<li><p>Computed: 从state中通过纯函数的操作衍生出的值，state变化它也会跟着变化。</p>\n</li>\n<li><p>Reactions：需要对state变化动态作出反应的东西，它包含不同的概念，基于被观察数据的更新导致某个计算值，或者是发送网络请求以及更新视图等，都属于响应的范畴，这也是响应式编程在 JavaScript 中的一个应用。</p>\n</li>\n<li><p>Autorun。依赖收集，监听触发，autorun 背后由 reaction 实现。由于 autorun 与 view 的 render 函数很像，我们在 render 函数初始化执行时，使其包裹在 autorun 环境中，第 2 次 render 开始遍剥离外层的 autorun，保证只绑定一遍数据。这样 view 层在原本 props 更新机制的基础上，增加了 autorun 的功能，实现修改任何数据自动更新对应 view 的效果。（ps:使用autoRun实现Mobx-react非常简单，核心思想是将组件外面包上autoRun，这样代码中用到的所有属性都会像上面Demo一样，与当前组件绑定，一旦任何值发生了修改，就直接forceUpdate，而且精确命中，效率最高。）</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"Mobx流程\"><a href=\"#Mobx流程\" class=\"headerlink\" title=\"Mobx流程\"></a>Mobx流程</h3><p>一图胜千言~<br><img src=\"https://wx3.sinaimg.cn/mw690/768c39d5gy1fqvrrvmevqj21330dfq56.jpg\" alt=\"Mobx流程示意图\"><br>可以把 observable 理解为信号源，每当信号变化时，函数流会自动执行，并输出结果，最终会使视图刷新。这就是数据驱动视图。每当我们的可观察对象变化时，都会自动触发数据源的 dispatch，而且各视图也是自动订阅各数据源的，这就是依赖追踪。</p>\n<hr>\n<h3 id=\"Mobx的优缺点\"><a href=\"#Mobx的优缺点\" class=\"headerlink\" title=\"Mobx的优缺点\"></a>Mobx的优缺点</h3><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ol>\n<li>使用起来十分顺手，降低开发难度。十分“智能”，当我们更新观察对象的状态后，由观察对象的改变带来的界面重渲染、数据序列化等一系列副作用，Mobx会自动帮我们完成。</li>\n<li>面向对象的使用方法，较为符合我们平时开发的逻辑。</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li><p>无副作用隔离，非严格模式下可以对observable直接修改，这样容易造成 store 被随意修改。在项目规模比较大的时候，像 Vuex 和 Redux 一样对修改数据的入口进行限制可以提高安全性。因此如果不规范Mobx使用的话将会导致数据流变化混乱问题。</p>\n</li>\n<li><p>在收集依赖时，Mobx会把autorun执行一遍来触发里面observable的getter从而收集依赖。但是万一你写出了以下的代码，Mobx是收集不到你想要收集的依赖的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let val = 1;</span><br><span class=\"line\">let ob = observable(&#123;a: 1&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//在这里我们没有访问 ob.a ，而只是访问了 ob，autorun 没有收集到 ob.a 的依赖，所以当改变ob.a的时候也不会触发下面这个函数。</span><br><span class=\"line\">let test1 = autorun(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;log ob.a&apos;, ob);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//在这里有一个返回值为false的判断语句使得判断语句里面的内容没有执行，从而也收集不到依赖</span><br><span class=\"line\">let test2 = autorun(() =&gt; &#123;</span><br><span class=\"line\">    if (val === 2) &#123;</span><br><span class=\"line\">        console.log(&apos;判断 x&apos;, ob.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>observable跟普通的plainObject傻傻分不清楚，observable跟plainObject外貌上一摸一样，有时可能会误会了observable的本质</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const x = observable([1, 2, 3])</span><br><span class=\"line\">x.map(x =&gt; x + 1) // 我们可以像普通的数组一样操作 observable array</span><br><span class=\"line\"></span><br><span class=\"line\">//不会被执行，因为 Array.isArray(observable([1, 2, 3])) === false</span><br><span class=\"line\">if (Array.isArray(x)) &#123;</span><br><span class=\"line\">  x.push(4)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h3 id=\"Mobx与Redux的区别\"><a href=\"#Mobx与Redux的区别\" class=\"headerlink\" title=\"Mobx与Redux的区别\"></a>Mobx与Redux的区别</h3><ol>\n<li>从数据管理模式的差别上看，Mobx是基于双向绑定的响应式的实现，而redux是基于flux的单向数据流的实现。</li>\n<li>从开发上来看是和面向对象和函数式编程的区别。但是前端开发需要经常与副作用打交道，所以前端开发很难与完美的函数式编程相结合。</li>\n<li>redux的state是只读的，产生新的state的过程是pure的；Mobx的state可读可写，并且action并不是必须的，可以直接赋值改变，这也看出了Mobx改变数据的impure。</li>\n<li>在可预测性、可维护性上看，redux得益于它的清晰的单向数据流和纯函数的实现，在这方面优于Mobx。</li>\n<li>redux是单一数据源；而Mobx是多个store。</li>\n<li>redux中的store是普通的js对象结构，而Mobx中的会对其进行observable化，从而实现响应式。</li>\n<li>从代码量上看，Mobx能少写很多代码，而redux要通过action,reducer等等的编写才能实现整个流程。</li>\n</ol>\n<hr>\n<h3 id=\"Mobx与Rxjs\"><a href=\"#Mobx与Rxjs\" class=\"headerlink\" title=\"Mobx与Rxjs\"></a>Mobx与Rxjs</h3><p>它们两者都是响应式的，但又有所不同。<br>Mobx的observable是从store到view的数据变化的autorun响应。<br>Rxjs的observable是从数据源到store的数据源派发流的过程。</p>\n<p>Mobx和Rxjs可以是一种互补的关系，Rxjs响应数据的来源，Mobx响应数据的变化。<br>例如:如果想在更新state之前对用户的输入操作节流，大致工作流是：</p>\n<p>DOM events -&gt; RxJS -&gt; Update state -&gt; MobX -&gt; Update UI<br>//Rxjs仅用来隔离副作用与数据处理，Mobx用来响应数据的变化，拥有修改 store 的能力，并且精准更新使用的 View。</p>\n<hr>\n<h3 id=\"Mobx基本原理\"><a href=\"#Mobx基本原理\" class=\"headerlink\" title=\"Mobx基本原理\"></a>Mobx基本原理</h3><p>那么Mobx是怎么做到这个响应式双向绑定的呢？</p>\n<p>我们通过定义可观察对象，依赖收集，触发更新这个顺序来说说它的基本原理~</p>\n<h4 id=\"1-定义可观察对象\"><a href=\"#1-定义可观察对象\" class=\"headerlink\" title=\"1.定义可观察对象\"></a>1.定义可观察对象</h4><p>我们平时是这样来定义一个可观察对象的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class newsStore&#123;</span><br><span class=\"line\">    @observable hotNews=[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//在这里mobx用了修饰器的形式来定义，实质上，它是这样的：</span><br><span class=\"line\">function newsStore() &#123;</span><br><span class=\"line\">    extendObservable(this, &#123;</span><br><span class=\"line\">        hotNews: []</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到这里用到了<code>extendObservable</code>这个方法来让目标对象可观察化，在这个方法中：</p>\n<ol>\n<li>给<code>target</code>(当前的类，例子中的<code>newsStore</code>)设置一个<code>$mobx</code>属性作为它的代理对象，<code>$mobx</code>有一个属性<code>values</code>属性，就是用来存储可观察属性的。因此对其的可观察化不会对该对象本身产生影响，对其的所有操作都将通过其 <code>$mobx</code> 属性代理。</li>\n<li>然后将每个设置了<code>@observable</code>的属性值转化为一个可观察的对象，并存储在 <code>$mobx.values[propName]</code> 中，例如上面的例子，就是把<code>hotNews</code>放在了<code>target.$mobx.values[hotNews]</code>中。</li>\n<li>遍历可观察属性，给每个<code>observable</code>重写<code>get</code>和<code>set</code>来将外界对目标对象的读写操作代理到其代理对象。get和set分别会调用<code>reportObserved</code>和<code>reportChanged</code>进行相应操作。<br><img src=\"https://wx4.sinaimg.cn/mw690/768c39d5gy1fqvwcn2y8wj215q0dpmyk.jpg\" alt=\"$mobx\"><br>图片来源：阿里云中台前端/全栈团队专栏，侵删</li>\n</ol>\n<h4 id=\"2-依赖收集\"><a href=\"#2-依赖收集\" class=\"headerlink\" title=\"2.依赖收集\"></a>2.依赖收集</h4><p>依赖收集主要是在<code>autorun</code>中进行的，它会把参数包装成一个观察者，先执行一次，当执行过程中遇到可观察属性，就会触发到该可观察属性的getter，这个getter就会调用它的<code>reportObserved</code>方法,这个方法就会拿到全局状态下当前的<code>Derivation</code>（也就是当前这个autorun的Reaction），然后把这个<code>observableValue</code>放到当前<code>Derivation</code>的<code>newObserving</code>数组中，从而使得该<code>Reaction</code>中就绑定着它所观察的所有的<code>observableValue</code>。<br>然后，遍历每个<code>observableValue</code>，通过<code>addObserver</code>的方法将依赖该<code>observableValue</code>的<code>reaction</code>添加到它的<code>observers</code>属性中。<br>这样一来，在<code>Reaction</code>中储存着它依赖的<code>observableValue</code>，在每个<code>observableValue</code>中的<code>observers</code>属性中也储存着依赖它的<code>Reaction</code>。</p>\n<h4 id=\"3-触发更新\"><a href=\"#3-触发更新\" class=\"headerlink\" title=\"3.触发更新\"></a>3.触发更新</h4><p>当<code>observableValue</code>发生改变的时候，就会出发到它的<code>setter</code>。在这个<code>setter</code>中会遍历该<code>observable</code>的<code>observers</code>数组，把它们都标志为过期状态。当这个<code>reaction</code>处于过期状态的时候，就会把这个<code>reaction</code>放进<code>pendingReactions</code>（一个全局的数组）中，然后依次调用它们的<code>runReaction</code>方法（这里用到了事务的方式来进行批处理）。<br>然后在<code>runReaction</code>的流程中，就会运行这些<code>reaction</code>，从而触发了所有被观察的 <code>Observable</code> 的 <code>reportObserved</code> 方法，并更新了当前<code>Derivation</code>的<code>newObserving</code>数组，也即重新收集了依赖，更新了依赖。</p>\n<hr>\n<h3 id=\"Nobx——迷你版的Mobx\"><a href=\"#Nobx——迷你版的Mobx\" class=\"headerlink\" title=\"Nobx——迷你版的Mobx\"></a>Nobx——迷你版的Mobx</h3><p>最后贴一下本人通过学习Mobx原理来实现的迷你版Mobx(●’◡’●)</p>\n<p><a href=\"https://github.com/cmh1996/nobx\" target=\"_blank\" rel=\"noopener\">https://github.com/cmh1996/nobx</a></p>\n","prev":{"title":"浅谈前端数据流管理方案（三）——Vuex篇","slug":"浅谈前端数据流管理方案（三）——Vuex篇"},"next":{"title":"浅谈前端数据流管理方案（一）——Flux篇","slug":"浅谈前端数据流管理方案（一）——Flux篇"}}