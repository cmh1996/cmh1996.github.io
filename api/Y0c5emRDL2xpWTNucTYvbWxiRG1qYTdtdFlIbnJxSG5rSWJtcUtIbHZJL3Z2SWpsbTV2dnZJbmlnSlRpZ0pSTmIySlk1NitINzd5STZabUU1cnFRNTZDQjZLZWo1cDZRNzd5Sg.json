{"title":"前端数据流管理模式（四）——MobX篇（附源码解析）","date":"2018-05-09T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1524651580961&di=4dca135f67bfcced731800cb2543a2bd&imgtype=0&src=http%3A%2F%2Fimgsrc.baidu.com%2Fimage%2Fc0%253Dshijue1%252C0%252C0%252C294%252C40%2Fsign%3Db321bfd871899e516c8332572aceb346%2F0eb30f2442a7d9334e4e8856a74bd11373f00134.jpg","excerpt":"","slug":"前端数据流管理模式（四）——MobX篇（附源码解析）","comments":true,"dropcap":false,"tags":["js","前端数据流"],"categories":["js"],"updated":"2018-04-27T06:41:18.032Z","content":"<h2 id=\"MobX\"><a href=\"#MobX\" class=\"headerlink\" title=\"MobX\"></a>MobX</h2><p>可以把 observable 理解为信号源，每当信号变化时，函数流会自动执行，并输出结果，对前端而言，最终会使视图刷新。这就是数据驱动视图。然而 mobx 是 TFRP 框架，每当变量变化时，都会自动触发数据源的 dispatch，而且各视图也是自动订阅各数据源的，我们称为依赖追踪，或者叫自动依赖绑定。</p>\n<p>但是这种模式有一个隐患，它引发了副作用对纯函数的污染，就像 redux 把 action 与 reducer 合起来了一样。同时，对 props 的直接修改，也会导致与 react 对 props 的不可变定义冲突。因此 mobx 后来给出了 action 解决方案，解决了与 react props 的冲突，但是没有解决副作用未强制分离的问题。</p>\n<p>笔者认为，副作用与 mutable 是两件事，关于 mutable 与副作用的关系，后文会有说明。也就是 mobx 没有解决副作用问题，不代表 TFRP 无法分离副作用，而且 mutable 也不一定与 可回溯 冲突，比如 mobx-state-tree，就通过 mutable 的方式，完成了与 redux 的对接。</p>\n<p>MobX 与数据驱动应用<br>数据驱动的应用中，领域模型很可能非常细碎而繁多（比如对于每种不同的表单，都可以有自己的数据模型），而且对于每种领域模型，封装出与之对应的增查改删能力就基本足够满足需求了。这时候，MobX 状态管理的抽象显得非常自然：</p>\n<p>基于 class 的数据模型结构，可以非常轻松地封装每种模型的增查改删操作。并且可以非常方便地实例化多个不同 store 的实例，注入到所需的组件中。对于 store 间通信，实例化子 store 时注入一个到 RootStore 的引用即可。</p>\n<p>基于 TS 的类型声明远比 Redux 里原始的字符串常量 + 原生 JS 对象要先进。</p>\n<p>基于依赖追踪的更新机制能够精确地做到在对象某个属性更新时，按需更新组件。在一般的业务场景下，这比全量更改状态再 Diff 的操作的性能要更好。作为参考，在一个大量重绘的场景下，Dan Abramov 亲自操刀优化后的 Redux 实现，才基本达到了 MobX 开箱即用的水平。</p>\n<p>需要注意的是，MobX 在重绘时的性能优势是以访问劫持后更大的内存占用为代价的。关于这个 trade-off，笔者在 D2 上恰好也向分享 Web 优化的 UC 内核开发者讲师咨询了内存占用对前端性能的影响。根据 dalao 的回复，这方面主要的案例仍然是来自于大量下载图片等明显的反模式，而状态管理中数据模型的内存消耗则不是一个影响性能的瓶颈点。从这个角度来看，MobX 在设计上的权衡与取舍可以认为是值得的。</p>\n<p>虽然 Mobx 提供了便捷的代码书写方式，但这样容易造成 store 被随意修改，在项目规模比较大的时候，像 Vuex 和 Redux 一样对修改数据的入口进行限制可以提高安全性。在 Mobx 2.2 之后的版本中可以通过 useStrict 限制只能通过 action 对数据进行修改。</p>\n<hr>\n<h3 id=\"Mobx的特点\"><a href=\"#Mobx的特点\" class=\"headerlink\" title=\"Mobx的特点\"></a>Mobx的特点</h3><ol>\n<li>Observable。它的state是可被观察的，无论是基本数据类型还是引用数据类型，都可以使用 MobX 的 (@)observable 来转变为 observable value。</li>\n<li>Reactions。它包含不同的概念，基于被观察数据的更新导致某个计算值（computed values），或者是发送网络请求以及更新视图等，都属于响应的范畴，这也是响应式编程（Reactive Programming）在 JavaScript 中的一个应用。</li>\n<li>Actions。它相当于所有响应的源头，例如用户在视图上的操作，或是某个网络请求的响应导致的被观察数据的变更。</li>\n</ol>\n<hr>\n<h3 id=\"Mobx和Redux的区别\"><a href=\"#Mobx和Redux的区别\" class=\"headerlink\" title=\"Mobx和Redux的区别\"></a>Mobx和Redux的区别</h3><ol>\n<li>从数据管理模式的差别上看，mobx是基于mvvm的响应式的实现，而redux是基于flux的单向数据流的实现。</li>\n<li>从开发上来看是和面向对象和函数式编程的区别。但是前端开发需要经常与副作用打交道，所以前端开发很难与完美的函数式编程相结合。</li>\n<li>redux的state是只读的，产生新的state的过程是pure的；mobx的state可读可写，并且action并不是必须的，可以直接赋值改变，这也看出了mobx改变数据的impure。</li>\n<li>在可预测性、可维护性上看，redux得益于它的清晰的单向数据流和纯函数的实现，在这方面优于mobx。</li>\n<li>redux是单一数据源；而mobx是多个store。</li>\n<li>redux中的store是普通的js对象结构，而mobx中的会对其进行observable化，从而实现响应式。</li>\n<li>从代码量上看，mobx能少写很多代码，而redux要通过action,reducer等等的编写才能实现整个流程。</li>\n</ol>\n<hr>\n<h4 id=\"——开坑中，稍安勿躁-╯□╰-——\"><a href=\"#——开坑中，稍安勿躁-╯□╰-——\" class=\"headerlink\" title=\"——开坑中，稍安勿躁( ╯□╰ )——\"></a>——开坑中，稍安勿躁( ╯□╰ )——</h4>","next":{"title":"前端数据流管理模式（三）——Vuex篇（附源码解析）","slug":"前端数据流管理模式（三）——Vuex篇（附源码解析）"}}