{"title":"浅谈前端数据流管理方案（四）——MobX篇（附源码解析）","date":"2018-05-04T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1524651580961&di=4dca135f67bfcced731800cb2543a2bd&imgtype=0&src=http%3A%2F%2Fimgsrc.baidu.com%2Fimage%2Fc0%253Dshijue1%252C0%252C0%252C294%252C40%2Fsign%3Db321bfd871899e516c8332572aceb346%2F0eb30f2442a7d9334e4e8856a74bd11373f00134.jpg","excerpt":"","slug":"浅谈前端数据流管理方案（四）——MobX篇（附源码解析）","comments":true,"dropcap":false,"tags":["js","前端数据流"],"categories":["js"],"updated":"2018-04-30T11:36:41.928Z","content":"<h2 id=\"MobX\"><a href=\"#MobX\" class=\"headerlink\" title=\"MobX\"></a>MobX</h2><p>Mobx专注于解决数据级别的响应，它不关系数据的来源方式，只要一个对象中的属性、一个基本类型变量发生了变化，对这些数据的订阅就会自动执行。使用Mobx管理状态时，当我们更新观察对象的状态后，由观察对象的改变带来的界面重渲染、数据序列化等一系列副作用，Mobx会自动帮我们完成。</p>\n<hr>\n<h3 id=\"Mobx的主要概念\"><a href=\"#Mobx的主要概念\" class=\"headerlink\" title=\"Mobx的主要概念\"></a>Mobx的主要概念</h3><ol>\n<li><p>Actions: 改变state的操作。</p>\n</li>\n<li><p>ObservableState:应用的可被观察的数据状态。</p>\n</li>\n<li><p>Computed: 从state中通过纯函数的操作衍生出的值，state变化它也会跟着变化。</p>\n</li>\n<li><p>Reactions：需要对state变化动态作出反应的东西，它包含不同的概念，基于被观察数据的更新导致某个计算值，或者是发送网络请求以及更新视图等，都属于响应的范畴，这也是响应式编程在 JavaScript 中的一个应用。</p>\n</li>\n<li><p>Autorun。依赖收集，监听触发，autorun 背后由 reaction 实现。由于 autorun 与 view 的 render 函数很像，我们在 render 函数初始化执行时，使其包裹在 autorun 环境中，第 2 次 render 开始遍剥离外层的 autorun，保证只绑定一遍数据。这样 view 层在原本 props 更新机制的基础上，增加了 autorun 的功能，实现修改任何数据自动更新对应 view 的效果。（ps:使用autoRun实现Mobx-react非常简单，核心思想是将组件外面包上autoRun，这样代码中用到的所有属性都会像上面Demo一样，与当前组件绑定，一旦任何值发生了修改，就直接forceUpdate，而且精确命中，效率最高。）</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"Mobx流程\"><a href=\"#Mobx流程\" class=\"headerlink\" title=\"Mobx流程\"></a>Mobx流程</h3><p>一图胜千言~<br><img src=\"/2018/05/05/浅谈前端数据流管理方案（四）——MobX篇（附源码解析）/2.jpg\" alt=\"Mobx流程示意图\"><br>可以把 observable 理解为信号源，每当信号变化时，函数流会自动执行，并输出结果，最终会使视图刷新。这就是数据驱动视图。每当我们的可观察对象变化时，都会自动触发数据源的 dispatch，而且各视图也是自动订阅各数据源的，这就是依赖追踪。</p>\n<hr>\n<h3 id=\"Mobx的优缺点\"><a href=\"#Mobx的优缺点\" class=\"headerlink\" title=\"Mobx的优缺点\"></a>Mobx的优缺点</h3><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ol>\n<li>使用起来十分顺手，降低开发难度。十分“智能”，当我们更新观察对象的状态后，由观察对象的改变带来的界面重渲染、数据序列化等一系列副作用，Mobx会自动帮我们完成。</li>\n<li>面向对象的使用方法，较为符合我们平时开发的逻辑。</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li><p>无副作用隔离，非严格模式下可以对observable直接修改，这样容易造成 store 被随意修改。在项目规模比较大的时候，像 Vuex 和 Redux 一样对修改数据的入口进行限制可以提高安全性。因此如果不规范Mobx使用的话将会导致数据流变化混乱问题。</p>\n</li>\n<li><p>在收集依赖时，Mobx会把autorun执行一遍来触发里面observable的getter从而收集依赖。但是万一你写出了以下的代码，Mobx是收集不到你想要收集的依赖的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let val = 1;</span><br><span class=\"line\">let ob = observable(&#123;a: 1&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//在这里我们没有访问 ob.a ，而只是访问了 ob，autorun 没有收集到 ob.a 的依赖，所以当改变ob.a的时候也不会触发下面这个函数。</span><br><span class=\"line\">let test1 = autorun(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;log ob.a&apos;, ob);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//在这里有一个返回值为false的判断语句使得判断语句里面的内容没有执行，从而也收集不到依赖</span><br><span class=\"line\">let test2 = autorun(() =&gt; &#123;</span><br><span class=\"line\">    if (val === 2) &#123;</span><br><span class=\"line\">        console.log(&apos;判断 x&apos;, ob.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>observable跟普通的plainObject傻傻分不清楚，observable跟plainObject外貌上一摸一样，有时可能会误会了observable的本质</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const x = observable([1, 2, 3])</span><br><span class=\"line\">x.map(x =&gt; x + 1) // 我们可以像普通的数组一样操作 observable array</span><br><span class=\"line\"></span><br><span class=\"line\">//不会被执行，因为 Array.isArray(observable([1, 2, 3])) === false</span><br><span class=\"line\">if (Array.isArray(x)) &#123;</span><br><span class=\"line\">  x.push(4)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h3 id=\"Mobx与Redux的区别\"><a href=\"#Mobx与Redux的区别\" class=\"headerlink\" title=\"Mobx与Redux的区别\"></a>Mobx与Redux的区别</h3><ol>\n<li>从数据管理模式的差别上看，Mobx是基于双向绑定的响应式的实现，而redux是基于flux的单向数据流的实现。</li>\n<li>从开发上来看是和面向对象和函数式编程的区别。但是前端开发需要经常与副作用打交道，所以前端开发很难与完美的函数式编程相结合。</li>\n<li>redux的state是只读的，产生新的state的过程是pure的；Mobx的state可读可写，并且action并不是必须的，可以直接赋值改变，这也看出了Mobx改变数据的impure。</li>\n<li>在可预测性、可维护性上看，redux得益于它的清晰的单向数据流和纯函数的实现，在这方面优于Mobx。</li>\n<li>redux是单一数据源；而Mobx是多个store。</li>\n<li>redux中的store是普通的js对象结构，而Mobx中的会对其进行observable化，从而实现响应式。</li>\n<li>从代码量上看，Mobx能少写很多代码，而redux要通过action,reducer等等的编写才能实现整个流程。</li>\n</ol>\n<hr>\n<h3 id=\"Mobx与Rxjs\"><a href=\"#Mobx与Rxjs\" class=\"headerlink\" title=\"Mobx与Rxjs\"></a>Mobx与Rxjs</h3><p>它们两者都是响应式的，但又有所不同。<br>Mobx的observable是从store到view的数据变化的autorun响应。<br>Rxjs的observable是从数据源到store的数据源派发流的过程。</p>\n<p>Mobx和Rxjs可以是一种互补的关系，Rxjs响应数据的来源，Mobx响应数据的变化。<br>例如:如果想在更新state之前对用户的输入操作节流，大致工作流是：</p>\n<p>DOM events -&gt; RxJS -&gt; Update state -&gt; MobX -&gt; Update UI<br>//Rxjs仅用来隔离副作用与数据处理，Mobx用来响应数据的变化，拥有修改 store 的能力，并且精准更新使用的 View。</p>\n<hr>\n<h3 id=\"Mobx源码解析\"><a href=\"#Mobx源码解析\" class=\"headerlink\" title=\"Mobx源码解析\"></a>Mobx源码解析</h3>","prev":{"title":"浅谈前端数据流管理方案（五）——Rxjs篇","slug":"浅谈前端数据流管理方案（五）——Rxjs篇"},"next":{"title":"浅谈前端数据流管理方案（三）——Vuex篇（附源码解析）","slug":"浅谈前端数据流管理方案（三）——Vuex篇（附源码解析）"}}