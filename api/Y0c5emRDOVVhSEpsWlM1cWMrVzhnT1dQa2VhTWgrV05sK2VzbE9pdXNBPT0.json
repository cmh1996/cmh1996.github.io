{"title":"Three.js开发指南笔记","date":"2017-08-11T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1521383720002&di=ecf315b4b87e42e80e5ead1938b13728&imgtype=0&src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F010e4f589036c9a801219c777f7843.jpg","excerpt":"","slug":"Three.js开发指南笔记","comments":true,"dropcap":false,"tags":["js","three.js"],"categories":["js"],"updated":"2018-04-22T08:14:06.775Z","content":"<h2 id=\"1-渲染器初始化\"><a href=\"#1-渲染器初始化\" class=\"headerlink\" title=\"1.渲染器初始化\"></a>1.渲染器初始化</h2><p>渲染器将和Canvas元素进行绑定，如果之前在HTML中手动定义了id为mainCanvas的Canvas元素，那么Renderer可以这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var renderer = new THREE.WebGLRenderer(&#123;</span><br><span class=\"line\">    canvas: document.getElementById(&apos;mainCanvas&apos;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>而如果想要Three.js生成Canvas元素，在HTML中就不需要定义Canvas元素，在JavaScript代码中可以这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var renderer = new THREE.WebGLRenderer();</span><br><span class=\"line\">renderer.setSize(400, 300);</span><br><span class=\"line\">document.getElementsByTagName(&apos;body&apos;)[0].appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure>\n<p>背景色（清除色）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">renderer.setClearColor(0x000000);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-场景相关API\"><a href=\"#2-场景相关API\" class=\"headerlink\" title=\"2.场景相关API\"></a>2.场景相关API</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scene.add();    //添加东西</span><br><span class=\"line\">scene.remove();    //移除东西</span><br><span class=\"line\">scene.children();    //获取场景中所有子对象</span><br><span class=\"line\">scene.getChildByName();    //利用name属性，获取场景中某个特定物体</span><br><span class=\"line\">scene.traverse();   //参数接受一个函数，场景中每个子对象都会执行的，相当于forEach</span><br><span class=\"line\"></span><br><span class=\"line\">scene.fog = new THREE.Fog(0xffffff,0.015,100);  //雾化(两个参数时1是雾的颜色，2是雾的浓度；三个参数时1是雾的颜色，2是near值，3是far值)</span><br><span class=\"line\"></span><br><span class=\"line\">scene.overrideMaterial = new THREE.MeshLambertMaterial(&#123;color:0xffffff&#125;);   //设置场景中所有物体的材质</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-正交投影vs透视投影\"><a href=\"#3-正交投影vs透视投影\" class=\"headerlink\" title=\"3.正交投影vs透视投影\"></a>3.正交投影vs透视投影</h2><p>使用透视投影照相机获得的结果是类似人眼在真实世界中看到的有“近大远小”的效果；而使用正交投影照相机获得的结果就像我们在数学几何学课上老师教我们画的效果，对于在三维空间内平行的线，投影到二维空间中也一定是平行的。</p>\n<p>一般说来，对于制图、建模软件通常使用正交投影，这样不会因为投影而改变物体比例；而对于其他大多数应用，通常使用透视投影，因为这更接近人眼的观察效果。</p>\n<h2 id=\"4-正交投影照相机\"><a href=\"#4-正交投影照相机\" class=\"headerlink\" title=\"4.正交投影照相机\"></a>4.正交投影照相机</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.OrthographicCamera(left, right, top, bottom, near, far)</span><br></pre></td></tr></table></figure>\n<p>这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，这六个面围成一个长方体，我们称其为视景体（Frustum）。只有在视景体内部（下图中的灰色部分）的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉。</p>\n<p>为了保持照相机的横竖比例，需要保证(right - left)与(top - bottom)的比例与Canvas宽度与高度的比例一致。</p>\n<p>near与far都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般near的值设置得较小，far的值设置得较大，具体值视场景中物体的位置等决定。</p>\n<p><img src=\"http://www.ituring.com.cn/download/01YiZI4zr57Q.small\" alt=\"camera\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//分别设置照相机的x,y,z位置</span><br><span class=\"line\">camera.position.set(0,0,5);</span><br></pre></td></tr></table></figure>\n<p>另外，因为照相机默认是看向z的负方向，所以要想照相机往其他方向看，可以这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这样照相机就会看着(0,0,0)这个点（无论照相机在哪个位置）</span><br><span class=\"line\">camera.lookAt(new THREE.Vector3(0,0,0));</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-透视投影照相机\"><a href=\"#5-透视投影照相机\" class=\"headerlink\" title=\"5.透视投影照相机\"></a>5.透视投影照相机</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.PerspectiveCamera(fov, aspect, near, far);</span><br><span class=\"line\">var camera = new THREE.PerspectiveCamera(45, 400 / 300, 1, 10);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://www.ituring.com.cn/download/01YYrMaASOzm.small\" alt=\"camera\"></p>\n<p>透视图中，灰色的部分是视景体，是可能被渲染的物体所在的区域。fov是视景体竖直方向上的张角（是角度制而非弧度制），如侧视图所示。</p>\n<p>aspect等于width / height，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。</p>\n<p>near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near。</p>\n<h2 id=\"6-立方体\"><a href=\"#6-立方体\" class=\"headerlink\" title=\"6.立方体\"></a>6.立方体</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)</span><br></pre></td></tr></table></figure>\n<p>width是x方向上的长度；height是y方向上的长度；depth是z方向上的长度；后三个参数分别是在三个方向上的分段数，如widthSegments为3的话，代表x方向上水平分为三份。一般情况下不需要分段的话，可以不设置后三个参数，后三个参数的缺省值为1。其他几何形状中的分段也是类似的，下面不做说明。</p>\n<h2 id=\"7-平面\"><a href=\"#7-平面\" class=\"headerlink\" title=\"7.平面\"></a>7.平面</h2><p>这里的平面（PlaneGeometry）其实是一个长方形，而不是数学意义上无限大小的平面。其构造函数为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.PlaneGeometry(width, height, widthSegments, heightSegments)</span><br></pre></td></tr></table></figure></p>\n<p>其中，width是x方向上的长度；height是y方向上的长度；后两个参数同样表示分段。</p>\n<h2 id=\"8-球体\"><a href=\"#8-球体\" class=\"headerlink\" title=\"8.球体\"></a>8.球体</h2><p>其中，radius是半径；segmentsWidth表示经度上的切片数；segmentsHeight表示纬度上的切片数；phiStart表示经度开始的弧度；phiLength表示经度跨过的弧度；thetaStart表示纬度开始的弧度；thetaLength表示纬度跨过的弧度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-圆形\"><a href=\"#9-圆形\" class=\"headerlink\" title=\"9.圆形\"></a>9.圆形</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-圆柱体\"><a href=\"#10-圆柱体\" class=\"headerlink\" title=\"10.圆柱体\"></a>10.圆柱体</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)</span><br></pre></td></tr></table></figure>\n<p>其中，radiusTop与radiusBottom分别是顶面和底面的半径，由此可知，当这两个参数设置为不同的值时，实际上创建的是一个圆台；height是圆柱体的高度；radiusSegments与heightSegments可类比球体中的分段；openEnded是一个布尔值，表示是否没有顶面和底面，缺省值为false，表示有顶面和底面。</p>\n<h2 id=\"11-正n面体\"><a href=\"#11-正n面体\" class=\"headerlink\" title=\"11.正n面体\"></a>11.正n面体</h2><p>正四面体（TetrahedronGeometry）、正八面体（OctahedronGeometry）、正二十面体（IcosahedronGeometry）的构造函数较为类似，分别为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.TetrahedronGeometry(radius, detail)</span><br><span class=\"line\">THREE.OctahedronGeometry(radius, detail)</span><br><span class=\"line\">THREE.IcosahedronGeometry(radius, detail)</span><br></pre></td></tr></table></figure>\n<p>其中，radius是半径；detail是细节层次（Level of Detail）的层数，对于大面片数模型，可以控制在视角靠近物体时，显示面片数多的精细模型，而在离物体较远时，显示面片数较少的粗略模型。这里我们不对detail多作展开，一般可以对这个值缺省。</p>\n<h2 id=\"12-圆环面\"><a href=\"#12-圆环面\" class=\"headerlink\" title=\"12.圆环面\"></a>12.圆环面</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc)</span><br></pre></td></tr></table></figure>\n<p>其中，radius是圆环半径；tube是管道半径；radialSegments与tubularSegments分别是两个分段数，详见上图；arc是圆环面的弧度，缺省值为Math.PI * 2。</p>\n<p><img src=\"http://www.ituring.com.cn/download/01YZGqQBQI0k\" alt=\"pt\"></p>\n<h2 id=\"13-圆环结\"><a href=\"#13-圆环结\" class=\"headerlink\" title=\"13.圆环结\"></a>13.圆环结</h2><p>如果说圆环面是甜甜圈，那么圆环结（TorusKnotGeometry）就是打了结的甜甜圈，其构造参数为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments, p, q, heightScale)</span><br></pre></td></tr></table></figure></p>\n<p>前四个参数在圆环面中已经有所介绍，p和q是控制其样式的参数，一般可以缺省，如果需要详细了解，请学习圆环结的相关知识；heightScale是在z轴方向上的缩放。</p>\n<h2 id=\"14-文字形状\"><a href=\"#14-文字形状\" class=\"headerlink\" title=\"14.文字形状\"></a>14.文字形状</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.TextGeometry(text, parameters);</span><br></pre></td></tr></table></figure>\n<p>其中，text是文字字符串，parameters是以下参数组成的对象：</p>\n<p>size：字号大小，一般为大写字母的高度</p>\n<p>height：文字的厚度</p>\n<p>curveSegments：弧线分段数，使得文字的曲线更加光滑</p>\n<p>font：字体，默认是’helvetiker’，需对应引用的字体文件</p>\n<p>weight：值为’normal’或’bold’，表示是否加粗</p>\n<p>style：值为’normal’或’italics’，表示是否斜体</p>\n<p>bevelEnabled：布尔值，是否使用倒角，意为在边缘处斜切</p>\n<p>bevelThickness：倒角厚度</p>\n<p>bevelSize：倒角宽度</p>\n<p>ps:加载字体示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var loader = new THREE.FontLoader();</span><br><span class=\"line\">loader.load(&apos;../lib/helvetiker_regular.typeface.json&apos;, function(font) &#123;</span><br><span class=\"line\">    var mesh = new THREE.Mesh(new THREE.TextGeometry(&apos;Hello&apos;, &#123;</span><br><span class=\"line\">        font: font,</span><br><span class=\"line\">        size: 1,</span><br><span class=\"line\">        height: 1</span><br><span class=\"line\">    &#125;), material);</span><br><span class=\"line\">    scene.add(mesh);</span><br><span class=\"line\"></span><br><span class=\"line\">    // render</span><br><span class=\"line\">    renderer.render(scene, camera);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"15-自定义形状\"><a href=\"#15-自定义形状\" class=\"headerlink\" title=\"15.自定义形状\"></a>15.自定义形状</h2><p>由于自定义形状需要手动指定每个顶点位置，以及顶点连接情况，如果该形状非常复杂，程序员的计算量就会比较大。在这种情况下，建议在3ds Max之类的建模软件中创建模型，然后使用Three.js导入到场景中，这样会更高效方便。</p>\n<p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 初始化几何形状</span><br><span class=\"line\">var geometry = new THREE.Geometry();</span><br><span class=\"line\"></span><br><span class=\"line\">// 设置顶点位置</span><br><span class=\"line\">// 顶部4顶点</span><br><span class=\"line\">geometry.vertices.push(new THREE.Vector3(-1, 2, -1));</span><br><span class=\"line\">geometry.vertices.push(new THREE.Vector3(1, 2, -1));</span><br><span class=\"line\">geometry.vertices.push(new THREE.Vector3(1, 2, 1));</span><br><span class=\"line\">geometry.vertices.push(new THREE.Vector3(-1, 2, 1));</span><br><span class=\"line\">// 底部4顶点</span><br><span class=\"line\">geometry.vertices.push(new THREE.Vector3(-2, 0, -2));</span><br><span class=\"line\">geometry.vertices.push(new THREE.Vector3(2, 0, -2));</span><br><span class=\"line\">geometry.vertices.push(new THREE.Vector3(2, 0, 2));</span><br><span class=\"line\">geometry.vertices.push(new THREE.Vector3(-2, 0, 2));</span><br><span class=\"line\"></span><br><span class=\"line\">// 设置顶点连接情况</span><br><span class=\"line\">// 顶面</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(0, 1, 3));</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(1, 2, 3));</span><br><span class=\"line\">// 底面</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(4, 5, 6));</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(5, 6, 7));</span><br><span class=\"line\">// 四个侧面</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(1, 5, 6));</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(6, 2, 1));</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(2, 6, 7));</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(7, 3, 2));</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(3, 7, 0));</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(7, 4, 0));</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(0, 4, 5));</span><br><span class=\"line\">geometry.faces.push(new THREE.Face3(0, 5, 1));</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，new THREE.Vector3(-1, 2, -1)创建一个矢量，作为顶点位置追加到geometry.vertices数组中。</p>\n<p>而由new THREE.Face3(0, 1, 3)创建一个三个顶点组成的面片，追加到geometry.faces数组中。三个参数分别是四个顶点在geometry.vertices中的序号。</p>\n<h2 id=\"16-简单材质\"><a href=\"#16-简单材质\" class=\"headerlink\" title=\"16.简单材质\"></a>16.简单材质</h2><h3 id=\"1-基础材质\"><a href=\"#1-基础材质\" class=\"headerlink\" title=\"1.基础材质\"></a>1.基础材质</h3><p>对于基本材质，即使改变场景中的光源，使用该材质的物体也始终为颜色处处相同的效果。当然，这不是很具有真实感。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new THREE.MeshBasicMaterial(&#123;</span><br><span class=\"line\">    color: 0xffff00,</span><br><span class=\"line\">    opacity: 0.75</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>还可以设置以下属性：</p>\n<p>visible：是否可见，默认为true</p>\n<p>side：渲染面片正面或是反面，默认为正面THREE.FrontSide，可设置为反面THREE.BackSide，或双面THREE.DoubleSide</p>\n<p>wireframe：是否渲染线而非面，默认为false</p>\n<p>color：十六进制RGB颜色，如红色表示为0xff0000</p>\n<p>map：使用纹理贴图</p>\n<h3 id=\"2-深度材质\"><a href=\"#2-深度材质\" class=\"headerlink\" title=\"2.深度材质\"></a>2.深度材质</h3><p>其外观不由光照或某个材质属性决定，而是由物体到相机的距离决定。</p>\n<p>可以将这种材质与其他材质相结合，很容易创建出逐渐消失的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var depthMaterial = new THREE.MeshDepthMaterial();</span><br><span class=\"line\">depthMaterial.wireframe = true;  //是否显示线框</span><br><span class=\"line\">depthMaterial.wireframeLineWidth = 10;  //线框线的宽度</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-联合材质\"><a href=\"#3-联合材质\" class=\"headerlink\" title=\"3.联合材质\"></a>3.联合材质</h3><p>把材质结合起来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cube = new THREE.SceneUtils.createMultiMaterialObject(geometry,[basicMaterial,depthMaterial]);</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-每个面材质\"><a href=\"#4-每个面材质\" class=\"headerlink\" title=\"4.每个面材质\"></a>4.每个面材质</h3><p>相当于一个材质容器，为几何体每一个面制定不同的材质</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var matArray = [</span><br><span class=\"line\">    new THREE.MeshBasicMaterial(&#123;color:0x009e60&#125;),</span><br><span class=\"line\">    new THREE.MeshBasicMaterial(&#123;color:0x0051ba&#125;),</span><br><span class=\"line\">    new THREE.MeshBasicMaterial(&#123;color:0xffd500&#125;),</span><br><span class=\"line\">];</span><br><span class=\"line\">var faceMaterial = new THREE.MeshFaceMaterial(matArray);</span><br></pre></td></tr></table></figure>\n<p>ps:要创建一种透明的材质，仅仅设置opacity:0是不够的，还要将transparent设为0。为一个几何体赋予多种材质会复制几何体，从而创建出多个网格。</p>\n<h2 id=\"17-Lambert材质\"><a href=\"#17-Lambert材质\" class=\"headerlink\" title=\"17.Lambert材质\"></a>17.Lambert材质</h2><p>Lambert材质（MeshLambertMaterial）是符合Lambert光照模型的材质。Lambert光照模型的主要特点是只考虑漫反射而不考虑镜面反射的效果，因而对于金属、镜子等需要镜面反射效果的物体就不适应，对于其他大部分物体的漫反射效果都是适用的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new THREE.MeshLambertMaterial(&#123;</span><br><span class=\"line\">    color: 0xffff00</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>color是用来表现材质对散射光的反射能力，也是最常用来设置材质颜色的属性。除此之外，还可以用ambient和emissive控制材质的颜色。</p>\n<p>ambient表示对环境光的反射能力，只有当设置了AmbientLight后，该值才是有效的，材质对环境光的反射能力与环境光强相乘后得到材质实际表现的颜色。</p>\n<p>emissive是材质的自发光颜色，可以用来表现光源的颜色。</p>\n<h2 id=\"18-Phong材质\"><a href=\"#18-Phong材质\" class=\"headerlink\" title=\"18.Phong材质\"></a>18.Phong材质</h2><p>Phong材质（MeshPhongMaterial）是符合Phong光照模型的材质。和Lambert不同的是，Phong模型考虑了镜面反射的效果，因此对于金属、镜面的表现尤为适合。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">material = new THREE.MeshPhongMaterial(&#123;</span><br><span class=\"line\">    color: 0xff0000,</span><br><span class=\"line\">    specular: 0xffff00,</span><br><span class=\"line\">    shininess: 100</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>同样地，可以指定emissive和ambient值，这里不再说明。</p>\n<p>可以通过shininess属性控制光照模型中的n值，当shininess值越大时，高光的光斑越小，默认值为30。</p>\n<h2 id=\"19-法向材质\"><a href=\"#19-法向材质\" class=\"headerlink\" title=\"19.法向材质\"></a>19.法向材质</h2><p>法向材质可以将材质的颜色设置为其法向量的方向，有时候对于调试很有帮助。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new THREE.MeshNormalMaterial()</span><br></pre></td></tr></table></figure>\n<p>材质的颜色与照相机与该物体的角度相关，我们只改变照相机位置，就可以观察两个角度的颜色变化。</p>\n<h2 id=\"20-材质的纹理贴图\"><a href=\"#20-材质的纹理贴图\" class=\"headerlink\" title=\"20.材质的纹理贴图\"></a>20.材质的纹理贴图</h2><p>导入图像作为纹理贴图，并添加到相应的材质中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//单张图像应用于长方体</span><br><span class=\"line\">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var material = new THREE.MeshLambertMaterial(&#123;</span><br><span class=\"line\">    map: texture</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//可以用回调函数的方式来命令渲染：</span><br><span class=\"line\"></span><br><span class=\"line\">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;, &#123;&#125;, function() &#123;</span><br><span class=\"line\">    renderer.render(scene, camera);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">var material = new THREE.MeshLambertMaterial(&#123;</span><br><span class=\"line\">    map: texture</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>六个面应用不同的图像示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var materials = [];</span><br><span class=\"line\">for (var i = 0; i &lt; 6; ++i) &#123;</span><br><span class=\"line\">    materials.push(new THREE.MeshBasicMaterial(&#123;</span><br><span class=\"line\">        map: THREE.ImageUtils.loadTexture(&apos;../img/&apos; + i + &apos;.png&apos;,</span><br><span class=\"line\">                &#123;&#125;, function() &#123;</span><br><span class=\"line\">                    renderer.render(scene, camera);</span><br><span class=\"line\">                &#125;),</span><br><span class=\"line\">        overdraw: true</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var cube = new THREE.Mesh(new THREE.CubeGeometry(5, 5, 5),</span><br><span class=\"line\">        new THREE.MeshFaceMaterial(materials));</span><br><span class=\"line\">scene.add(cube);</span><br></pre></td></tr></table></figure></p>\n<p>棋盘格（复制渲染）：</p>\n<p>原图片：<br><img src=\"http://www.ituring.com.cn/download/01YdRC86nAUx\" alt=\"pt\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//导入材质</span><br><span class=\"line\">var texture = THREE.ImageUtils.loadTexture(&apos;../img/chess.png&apos;, &#123;&#125;, function() &#123;</span><br><span class=\"line\">    renderer.render(scene, camera);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//可是，棋盘格是8横8纵64个小方格组成的，那应该怎么办呢？</span><br><span class=\"line\"></span><br><span class=\"line\">//首先，我们需要指定重复方式为两个方向（wrapS和wrapT）都重复：</span><br><span class=\"line\">texture.wrapS = texture.wrapT = THREE.RepeatWrapping;</span><br><span class=\"line\"></span><br><span class=\"line\">//然后，设置两个方向上都重复4次，由于我们的图像本来是有2行2列，所以重复4次即为8行8列：</span><br><span class=\"line\">texture.repeat.set(4, 4);</span><br></pre></td></tr></table></figure>\n<p>最后就得到了棋盘格：<br><img src=\"http://www.ituring.com.cn/download/01YdRCMAK2Xq\" alt=\"pt\"></p>\n<h2 id=\"21-网格\"><a href=\"#21-网格\" class=\"headerlink\" title=\"21.网格\"></a>21.网格</h2><p>而网格的创建非常简单，只要把几何形状与材质传入其构造函数。最常用的物体是网格（Mesh），它代表包含点、线、面的几何体，其构造函数是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mesh = new THREE.Mesh(geometry, material);</span><br></pre></td></tr></table></figure></p>\n<p>在网格被创建后，也能对材质进行修改：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mesh.material = new THREE.MeshLambertMaterial(&#123;</span><br><span class=\"line\">    color: 0xff0000</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>位置、缩放、旋转:</p>\n<p>位置、缩放、旋转是物体三个常用属性。由于THREE.Mesh基础自THREE.Object3D，因此包含scale、rotation、position三个属性。它们都是THREE.Vector3实例，因此修改其值的方法是相同的，这里以位置为例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mesh.position.z = 1;</span><br><span class=\"line\">或</span><br><span class=\"line\">mesh.position.set(1.5, -0.5, 0);</span><br></pre></td></tr></table></figure>\n<h2 id=\"22-动画\"><a href=\"#22-动画\" class=\"headerlink\" title=\"22.动画\"></a>22.动画</h2><p>setInterval方法与requestAnimationFrame方法的区别较为微妙。一方面，最明显的差别表现在setInterval可以手动设定FPS，而requestAnimationFrame则会自动设定FPS；但另一方面，即使是setInterval也不能保证按照给定的FPS执行，在浏览器处理繁忙时，很可能低于设定值。当浏览器达不到设定的调用周期时，requestAnimationFrame采用跳过某些帧的方式来表现动画，虽然会有卡滞的效果但是整体速度不会拖慢，而setInterval会因此使整个程序放慢运行，但是每一帧都会绘制出来；</p>\n<p>总而言之，requestAnimationFrame适用于对于时间较为敏感的环境（但是动画逻辑更加复杂），而setInterval则可在保证程序的运算不至于导致延迟的情况下提供更加简洁的逻辑（无需自行处理时间）。</p>\n<p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function draw() &#123;</span><br><span class=\"line\">    mesh.rotation.y = (mesh.rotation.y + 0.01) % (Math.PI * 2);</span><br><span class=\"line\">    renderer.render(scene, camera);</span><br><span class=\"line\">    id = requestAnimationFrame(draw);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ps:可以使用stat.js记录FPS</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stats.setMode(0);//监测FPS</span><br><span class=\"line\">stats.setMode(1);//监测渲染时间</span><br></pre></td></tr></table></figure>\n<p>详情请见：(使用stat.js记录FPS)[<a href=\"http://www.ituring.com.cn/book/miniarticle/53353]\" target=\"_blank\" rel=\"noopener\">http://www.ituring.com.cn/book/miniarticle/53353]</a></p>\n<h2 id=\"23-外部导入\"><a href=\"#23-外部导入\" class=\"headerlink\" title=\"23.外部导入\"></a>23.外部导入</h2><p>Three.js有一系列导入外部文件的辅助函数，是在three.js之外的，使用前需要额外下载，在(loaders)[<a href=\"https://github.com/mrdoob/three.js/tree/master/examples/js/loaders]可以找到。\" target=\"_blank\" rel=\"noopener\">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders]可以找到。</a></p>\n<p>.obj是最常用的模型格式，导入.obj文件需要OBJLoader.js；</p>\n<p>导入带.mtl材质的.obj文件需要MTLLoader.js以及OBJMTLLoader.js。另有PLYLoader.js、STLLoader.js等分别对应不同格式的加载器，可以根据模型格式自行选择。</p>\n<p>导入过程：<a href=\"http://www.ituring.com.cn/book/miniarticle/53865\" target=\"_blank\" rel=\"noopener\">无材质的模型</a><br>         <a href=\"http://www.ituring.com.cn/book/miniarticle/53881\" target=\"_blank\" rel=\"noopener\">有材质的模型</a></p>\n<h2 id=\"24-环境光\"><a href=\"#24-环境光\" class=\"headerlink\" title=\"24.环境光\"></a>24.环境光</h2><p>环境光是指场景整体的光照效果，是由于场景内若干光源的多次反射形成的亮度一致的效果，通常用来为整个场景指定一个基础亮度。因此，环境光没有明确的光源位置，在各处形成的亮度也是一致的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var light = new THREE.AmbientLight(0xffffff);</span><br><span class=\"line\">scene.add(light);</span><br></pre></td></tr></table></figure></p>\n<p>环境光并不在乎物体材质的color属性，而是在乎ambient属性。ambient属性的默认值是0xffffff。</p>\n<p>ambient为0x00ff00的长方体被渲染成了黑色。这是因为不透明物体的颜色其实是其反射光的颜色，而ambient属性表示的是物体反射环境光的能力。对于0x00ff00的物体，红色通道是0，而环境光是完全的红光，因此该长方体不能反射任何光线，最终的渲染颜色就是黑色；而对于0xffffff的白色长方体，红色通道是0xff，因而能反射所有红光，渲染的颜色就是红色。</p>\n<p>前面我们看到，当环境光不是白色或灰色的时候，渲染的效果往往会很奇怪。因此，环境光通常使用白色或者灰色，作为整体光照的基础。</p>\n<h2 id=\"25-点光源\"><a href=\"#25-点光源\" class=\"headerlink\" title=\"25.点光源\"></a>25.点光源</h2><p>点光源是不计光源大小，可以看作一个点发出的光源。点光源照到不同物体表面的亮度是线性递减的，因此，离点光源距离越远的物体会显得越暗。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.PointLight(hex, intensity, distance);</span><br><span class=\"line\"></span><br><span class=\"line\">//应用示例：</span><br><span class=\"line\"></span><br><span class=\"line\">var light = new THREE.PointLight(0xffffff, 2, 100);</span><br><span class=\"line\">light.color = &quot;#ccffcc&quot;;    //设置光源颜色</span><br><span class=\"line\">light.intensity = 1;    //光的强度</span><br><span class=\"line\">light.position.set(0, 1.5, 2);  //设置光源位置</span><br><span class=\"line\">light.distance = 100;   //光源照射距离（默认为0，也就是说光线亮度不会随着距离增加而递减）</span><br><span class=\"line\">light.visible = true;   //光源是否开启</span><br><span class=\"line\">scene.add(light);</span><br></pre></td></tr></table></figure>\n<p>其中，hex是光源十六进制的颜色值；intensity是亮度，缺省值为1，表示100%亮度；distance是光源最远照射到的距离，缺省值为0。</p>\n<h2 id=\"26-平行光\"><a href=\"#26-平行光\" class=\"headerlink\" title=\"26.平行光\"></a>26.平行光</h2><p>我们都知道，太阳光常常被看作平行光，这是因为相对地球上物体的尺度而言，太阳离我们的距离足够远。对于任意平行的平面，平行光照射的亮度都是相同的，而与平面所在位置无关。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.DirectionalLight(hex, intensity);</span><br><span class=\"line\"></span><br><span class=\"line\">//示例：</span><br><span class=\"line\">var light = new THREE.DirectionalLight();</span><br><span class=\"line\">light.position.set(2, 5, 3);</span><br><span class=\"line\">scene.add(light);</span><br></pre></td></tr></table></figure>\n<p>注意，这里设置光源位置并不意味着所有光从(2, 5, 3)点射出（如果是的话，就成了点光源），而是意味着，平行光将以矢量(-2, -5, -3)的方向照射到所有平面。因此，平面亮度与平面的位置无关，而只与平面的法向量相关。只要平面是平行的，那么得到的光照也一定是相同的。</p>\n<h2 id=\"27-聚光灯\"><a href=\"#27-聚光灯\" class=\"headerlink\" title=\"27.聚光灯\"></a>27.聚光灯</h2><p>可以看出，聚光灯是一种特殊的点光源，它能够朝着一个方向投射光线。聚光灯投射出的是类似圆锥形的光线，这与我们现实中看到的聚光灯是一致的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THREE.SpotLight(hex, intensity, distance, angle, exponent)</span><br></pre></td></tr></table></figure>\n<p>相比点光源，多了angle和exponent两个参数。angle是聚光灯的张角，缺省值是Math.PI / 3，最大值是Math.PI / 2；exponent是光强在偏离target的衰减指数（target需要在之后定义，缺省值为(0, 0, 0)），缺省值是10。</p>\n<p>在调用构造函数之后，除了设置光源本身的位置，一般还需要设置target：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">light.position.set(x1, y1, z1);</span><br><span class=\"line\">light.target.position.set(x2, y2, z2);</span><br></pre></td></tr></table></figure>\n<p>除了设置light.target.position的方法外，如果想让聚光灯跟着某一物体移动（就像真的聚光灯！），可以target指定为该物体：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),</span><br><span class=\"line\">                    new THREE.MeshLambertMaterial(&#123;color: 0x00ff00&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">var light = new THREE.SpotLight(0xffff00, 1, 100, Math.PI / 6, 25);</span><br><span class=\"line\">light.target = cube;</span><br></pre></td></tr></table></figure>\n<h2 id=\"28-半球光\"><a href=\"#28-半球光\" class=\"headerlink\" title=\"28.半球光\"></a>28.半球光</h2><p>创建出更加贴近自然的户外光照效果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var hemiLight = new THREE.HemisphereLight(0x0000ff,0x00ff00,0.6);   //参数分别是天空发出的颜色、地面发出的颜色、光线照射强度</span><br><span class=\"line\"></span><br><span class=\"line\">hemiLight.position.set(0,500,0);</span><br><span class=\"line\">scene.add(hemiLight);</span><br></pre></td></tr></table></figure>\n<h2 id=\"29-平面光（略）\"><a href=\"#29-平面光（略）\" class=\"headerlink\" title=\"29.平面光（略）\"></a>29.平面光（略）</h2><p>定义一个发光的矩形</p>\n<h2 id=\"30-镜头眩光\"><a href=\"#30-镜头眩光\" class=\"headerlink\" title=\"30.镜头眩光\"></a>30.镜头眩光</h2><p>当你直接朝着太阳拍照时就会出现镜头眩光</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lensFlare = new THREE.LensFlare(texture,350,0.5,THREE.AdditiveBlending,flareColor);</span><br><span class=\"line\">//参数分别是眩光的材质，眩光尺寸(-1就表示用材质本身的尺寸)，光源(0)到相机(1)的距离，融合模式，颜色</span><br><span class=\"line\"></span><br><span class=\"line\">lensFlare.add(texture,60,0.6,THREE.AdditiveBlending);</span><br><span class=\"line\">//增加眩光</span><br></pre></td></tr></table></figure>\n<h2 id=\"31-阴影\"><a href=\"#31-阴影\" class=\"headerlink\" title=\"31.阴影\"></a>31.阴影</h2><p>在Three.js中，能形成阴影的光源只有THREE.DirectionalLight与THREE.SpotLight；而相对地，能表现阴影效果的材质只有THREE.LambertMaterial与THREE.PhongMaterial。因而在设置光源和材质的时候，一定要注意这一点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//首先，我们需要在初始化时，告诉渲染器渲染阴影：</span><br><span class=\"line\">renderer.shadowMapEnabled = true;</span><br><span class=\"line\"></span><br><span class=\"line\">//然后，对于光源以及所有要产生阴影的物体调用：</span><br><span class=\"line\">xxx.castShadow = true;</span><br><span class=\"line\"></span><br><span class=\"line\">//对于接收阴影的物体调用：</span><br><span class=\"line\">xxx.receiveShadow = true;</span><br></pre></td></tr></table></figure>\n<p>对于聚光灯，需要设置shadowCameraNear、shadowCameraFar、shadowCameraFov三个值，类比我们在第二章学到的透视投影照相机，只有介于shadowCameraNear与shadowCameraFar之间的物体将产生阴影，shadowCameraFov表示张角。</p>\n<p>对于平行光，需要设置shadowCameraNear、shadowCameraFar、shadowCameraLeft、shadowCameraRight、shadowCameraTop以及shadowCameraBottom六个值，相当于正交投影照相机的六个面。同样，只有在这六个面围成的长方体内的物体才会产生阴影效果。</p>\n<p>为了看到阴影照相机的位置，通常可以在调试时开启light.shadowCameraVisible = true。</p>\n<p>至此，阴影效果已经能正常显示了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">light.shadowCameraNear = 2;</span><br><span class=\"line\">light.shadowCameraFar = 10;</span><br><span class=\"line\">light.shadowCameraFov = 30;</span><br><span class=\"line\">light.shadowCameraVisible = true;</span><br><span class=\"line\"></span><br><span class=\"line\">light.shadowMapWidth = 1024;</span><br><span class=\"line\">light.shadowMapHeight = 1024;</span><br><span class=\"line\">light.shadowDarkness = 0.3;</span><br></pre></td></tr></table></figure>\n<h2 id=\"32-通过拉伸创建几何体\"><a href=\"#32-通过拉伸创建几何体\" class=\"headerlink\" title=\"32.通过拉伸创建几何体\"></a>32.通过拉伸创建几何体</h2><p>把二维图形拉伸成三维图形</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//沿着Z轴拉伸</span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    amount:10,//图形可以拉多高</span><br><span class=\"line\">    bevelThickness:2,//斜角厚度</span><br><span class=\"line\">    bevelSize:1,//斜角尺寸</span><br><span class=\"line\">    bevelSegments:3,//斜角分段数</span><br><span class=\"line\">    bevelEnabled:true,//是否用斜角</span><br><span class=\"line\">    curveSegments:12,//曲线分段数</span><br><span class=\"line\">    steps:1//拉伸体段数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">shape = createMesh(new THREE.ExtrudeGeometry(drawShape(),options));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//SVG图像2d变3d</span><br><span class=\"line\">function drawShape()&#123;</span><br><span class=\"line\">    var svgStr = $(&apos;#svg1&apos;).attr(&apos;d&apos;);</span><br><span class=\"line\">    var shape = transformSVGPathExposed(svgStr);    //transformSVGPathExposed这个函数是d3-ThreeD库提供的</span><br><span class=\"line\">    return shape;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    amount:10,//图形可以拉多高</span><br><span class=\"line\">    bevelThickness:2,//斜角厚度</span><br><span class=\"line\">    bevelSize:1,//斜角尺寸</span><br><span class=\"line\">    bevelSegments:3,//斜角分段数</span><br><span class=\"line\">    bevelEnabled:true,//是否用斜角</span><br><span class=\"line\">    curveSegments:12,//曲线分段数</span><br><span class=\"line\">    steps:1//拉伸体段数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">shape = createMesh(new THREE.ExtrudeGeometry(drawShape(),options));</span><br></pre></td></tr></table></figure>\n<h2 id=\"33-粒子\"><a href=\"#33-粒子\" class=\"headerlink\" title=\"33.粒子\"></a>33.粒子</h2><h2 id=\"34-相机控件（详情参见THREE-JS开发指南p181）\"><a href=\"#34-相机控件（详情参见THREE-JS开发指南p181）\" class=\"headerlink\" title=\"34.相机控件（详情参见THREE.JS开发指南p181）\"></a>34.相机控件（详情参见THREE.JS开发指南p181）</h2><h2 id=\"35-为物品添加多种材质\"><a href=\"#35-为物品添加多种材质\" class=\"headerlink\" title=\"35.为物品添加多种材质\"></a>35.为物品添加多种材质</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mesh = THREE.SceneUtils.createMultiMaterialObject(geometry,materials);</span><br><span class=\"line\">//参数1是几何体，参数2是一个包含多个材质对象的数组</span><br></pre></td></tr></table></figure>\n<h2 id=\"36-着色器（略）\"><a href=\"#36-着色器（略）\" class=\"headerlink\" title=\"36.着色器（略）\"></a>36.着色器（略）</h2>","prev":{"title":"web缓存","slug":"web缓存"},"next":{"title":"web性能优化","slug":"web性能优化"}}