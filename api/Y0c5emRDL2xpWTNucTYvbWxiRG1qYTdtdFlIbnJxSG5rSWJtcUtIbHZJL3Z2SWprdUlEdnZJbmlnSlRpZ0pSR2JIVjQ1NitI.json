{"title":"前端数据流管理模式（一）——Flux篇","date":"2018-04-21T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1524648952685&di=704d5f613a2434f1088f7027eb9f7bd1&imgtype=0&src=http%3A%2F%2Fwww.th7.cn%2Fd%2Ffile%2Fp%2F2016%2F01%2F26%2F86b2f73591bcfebc44ef33a9336a9c99.jpg","excerpt":"","slug":"前端数据流管理模式（一）——Flux篇","comments":true,"dropcap":false,"tags":["js","前端数据流"],"categories":["js"],"updated":"2018-04-26T11:15:48.414Z","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前端主流的数据流管理现阶段已衍生出三种管理模式，分别是：</p>\n<ul>\n<li>单向数据流派Flux，代表框架有Redux、Vuex。</li>\n<li>响应式的双向绑定流派MVVM，代表框架有MobX。</li>\n<li>响应式的流式流派，代表框架有RxJs。</li>\n</ul>\n<p>整个系列一共有五篇文章，主要介绍了上述三个流派在前端数据流管理上的模式阐述、框架实现，并对它们三者进行了比较。本系列旨在加深对前端数据流的管理的认识，希望对你我都有所帮助(●’◡’●)。</p>\n<h2 id=\"Flux模式\"><a href=\"#Flux模式\" class=\"headerlink\" title=\"Flux模式\"></a>Flux模式</h2><p>Flux是什么？Flux不是某一个具体框架的名称，它是一种前端数据流的管理模式，核心是单向数据流，近年来诞生的很多js库就是这种思想的实现，例如Redux,Vuex等等。它用于构建客户端 Web 应用，规范数据在 Web 应用中的流动方式。</p>\n<h3 id=\"Flux各部分职能：\"><a href=\"#Flux各部分职能：\" class=\"headerlink\" title=\"Flux各部分职能：\"></a>Flux各部分职能：</h3><ul>\n<li>Action：这一块有个生成器叫Action Creator，它负责把type（自定义的用于标志特定action常量）和payload（负载的信息）封装成一个action，创建好之后就会把它传递给Dispatcher。</li>\n<li>Dispatcher：它是一个负责派发action的派发器，它保存着包含所有的store的一个列表，接收到action之后再传给所有store，也就是说store并不是订阅某些action，而是聆听每一个action，从中过滤筛选出它关心的来做出反应。</li>\n<li>Store：保存着整个应用的状态。它从dispatcher中接收到action后，使用一个switch语句判断action的类型，决定是否对这个action作出响应，如果store关心这个action，就会根据action找出需要变化的部分，更新state。只要state做出了变化，就会触发change事件，通知视图状态变化。</li>\n<li>View：将state渲染给用户，并接受用户的输入,操作。view不能直接修改应用状态，只能触发action。View也分为Control-View和各个子View（类似于react中的智能组件和木偶组件），对于非Control-View的子View来说，所有数据都来源于Control-View传来的props。</li>\n</ul>\n<hr>\n<h3 id=\"Flux流程：\"><a href=\"#Flux流程：\" class=\"headerlink\" title=\"Flux流程：\"></a>Flux流程：</h3><p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png\" alt=\"Flux流程示意图\"><br>一、初始化</p>\n<ol>\n<li>创建store，store告诉dispatcher只要有action产生就告诉它。</li>\n<li>Control-View从store获取到初始的state，并传递给各个子view去渲染。</li>\n<li>Control-View让store在state变化更新的时候告诉它。</li>\n</ol>\n<p>二、触发数据流</p>\n<ol>\n<li>Control-View向Action-Creator触发一个action。</li>\n<li>Action Creator做好action后将其发送给dispatcher。</li>\n<li>dispatcher按顺序将action传给所有store，store自行对actionn进行判断，看是否对它作出响应。</li>\n<li>store根据接受的action，对state进行更新，更新完毕后就通知订阅了该store的Control-View。</li>\n<li>Control-View收到通知后，就会向store请求更新了的state。</li>\n<li>Control-View获得了新的state之后，让子view渲染新的state。</li>\n</ol>\n<hr>\n<h3 id=\"Flux优缺点：\"><a href=\"#Flux优缺点：\" class=\"headerlink\" title=\"Flux优缺点：\"></a>Flux优缺点：</h3><p>优点：</p>\n<ol>\n<li>视图组件变薄，只包含触发action和渲染数据这两个职责。</li>\n<li>view对于数据层的只读使得数据是可预测的。</li>\n<li>要想知道一个store可能的状态变化，只要看它注册了哪些actions回调即可。</li>\n<li>每次有状态变化都会从dispatcher流过，这让所有状态变化都留下了一笔记录，有利于debug还有时间旅行。</li>\n<li>dispatcher派发action是同步行为，这防止同一份数据有多个地方同时在写，使得数据变乱。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>冗余代码太多，出现很多类似的样板代码。每个应用中都要手动创建dispatcher实例，还有就是一个应用包含多个store来管理数据。</li>\n</ol>\n","prev":{"title":"前端数据流管理模式（二）——Redux篇","slug":"前端数据流管理模式（二）——Redux篇"},"next":{"title":"CSS世界学习笔记","slug":"css世界学习笔记"}}