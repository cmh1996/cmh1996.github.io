{"title":"web性能优化","date":"2017-08-04T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1521386244318&di=ba515e2ee8cde9353d2688b418293892&imgtype=0&src=http%3A%2F%2Fimg.dongqiudi.com%2Fuploads9%2Fallimg%2F160125%2F492-160125122514317.jpg","excerpt":"","slug":"web性能优化","comments":true,"dropcap":true,"tags":["性能优化"],"categories":["web"],"updated":"2018-07-29T10:30:56.306Z","content":"<h3 id=\"web性能优化\"><a href=\"#web性能优化\" class=\"headerlink\" title=\"web性能优化\"></a>web性能优化</h3><h3 id=\"一、资源加载\"><a href=\"#一、资源加载\" class=\"headerlink\" title=\"一、资源加载\"></a>一、资源加载</h3><ol>\n<li><p>CDN（存放静态资源的CDN域名和主域名要不一样，因为这便于CDN业务独立，能够独立配置缓存，抛开无用cookie，减小带宽占用。CDN域名与主站域名不同，DNS解析CDN域名还需要花费额外的时间，增加网络延迟。不过可以用DNS Prefetch。）</p>\n</li>\n<li><p>减少http请求</p>\n</li>\n<li><p>图像优化（不要在HTML里缩放图像，雪碧图，字体图标，使用WebP）</p>\n</li>\n<li><p>将 CSS 样式放在页面的上方，将脚本移动到底部（包括内联的）</p>\n</li>\n<li><p>可以给 JavaScript 加上 async 标记，表示 JavaScript 的执行不会读取 DOM ，JavaScript 可以不被 CSS 阻塞，可以在空闲时间立刻执行。（正常来说在浏览器没有下载并解析完成使用 link 引入的 CSS 文件之前，JavaScript 是不会执行的）（defer 跟 async 非常相似，不会阻塞页面加载，但会等到 HTML 完成解析后再执行，并且会按出现的次序执行。）</p>\n</li>\n<li><p>预加载，预渲染：增加 rel=”prefetch”,rel=”dns-prefetch”，或者 rel=”prerender” 标记，详情：（<a href=\"http://web.jobbole.com/84256/）\" target=\"_blank\" rel=\"noopener\">http://web.jobbole.com/84256/）</a></p>\n</li>\n<li><p>懒加载</p>\n</li>\n<li><p>合理使用缓存，localstorage,sessionstorage</p>\n</li>\n<li><p>启用Http2</p>\n</li>\n<li><p>service workers做离线缓存</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"二、文件体积\"><a href=\"#二、文件体积\" class=\"headerlink\" title=\"二、文件体积\"></a>二、文件体积</h3><ol>\n<li><p>Gzip（不要对图片文件进行Gzip压缩！适得其反）</p>\n</li>\n<li><p>webpack打包优化<br><img src=\"/2017/08/05/web性能优化/1.jpg\" alt=\"web性能优化\"><br><img src=\"/2017/08/05/web性能优化/2.jpg\" alt=\"web性能优化\"></p>\n</li>\n</ol>\n<hr>\n<h3 id=\"三、浏览器渲染运行\"><a href=\"#三、浏览器渲染运行\" class=\"headerlink\" title=\"三、浏览器渲染运行\"></a>三、浏览器渲染运行</h3><ol>\n<li><p>WebAssembly（体积小，解析时间短，更接近于机器码执行快，类型是确定的因此不需要JIT作重优化，垃圾回收是手动的）</p>\n</li>\n<li><p>防抖和节流</p>\n</li>\n<li><p>减少 DOM 操作的次数，避免不必要的重排和重绘</p>\n</li>\n<li><p>动画合理使用translate3d,opacity来启用单独图层渲染，硬件加速</p>\n</li>\n<li><p>使用 requestAnimationFrame 来更新页面</p>\n</li>\n<li><p>各种组件，例如轮播图。请等页面加载完毕20ms后再渲染，提升用户体验。</p>\n</li>\n<li><p>通过切换class或者使用元素的style.csstext属性去批量操作元素样式。</p>\n</li>\n<li><p>图片在渲染前指定大小：因为img元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"四、代码编写优化\"><a href=\"#四、代码编写优化\" class=\"headerlink\" title=\"四、代码编写优化\"></a>四、代码编写优化</h3><ol>\n<li><p>CSS不要过多使用*，因为他的选择器匹配原则是从右到左</p>\n</li>\n<li><p>避免过多的css表达式，例如width=3*4px</p>\n</li>\n<li><p>避免js重复脚本。尽量少建立变量，耗费内存空间</p>\n</li>\n<li><p>eslint统一风格，优化代码结构</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"五、服务器端\"><a href=\"#五、服务器端\" class=\"headerlink\" title=\"五、服务器端\"></a>五、服务器端</h3><ol>\n<li><p>负载均衡，nginx搭建反向代理</p>\n</li>\n<li><p>Node.js处理IO密集型请求</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"六、前端框架优化：\"><a href=\"#六、前端框架优化：\" class=\"headerlink\" title=\"六、前端框架优化：\"></a>六、前端框架优化：</h3><ol>\n<li><p>按需加载</p>\n</li>\n<li><p>异步组件</p>\n</li>\n<li><p>骨架屏，做必要的加载错误提示和必要的loading框</p>\n</li>\n<li><p>同构，服务端渲染</p>\n</li>\n<li><p>使用 prerender-spa-plugin 预渲染首屏（先指定 dist 目录和要渲染的路径。插件在 dist 目录中开启一个静态服务器，并且使用无头浏览器（puppeteer）访问对应的路径，执行 JS，抓取对应路径的 html。把抓到的内容写入 html，这样即使没有做服务器端渲染，也能达到跟服务器端渲染几乎相同的作用（不考虑动态数据的话））</p>\n</li>\n<li><p>使用动态 polyfill</p>\n</li>\n<li><p>react用pure-component做componentShouldUpdate的优化</p>\n</li>\n</ol>\n","prev":{"title":"Three.js开发指南笔记","slug":"Three.js开发指南笔记"},"next":{"title":"jQuery源码学习——笔记","slug":"jQuery源码学习笔记"}}