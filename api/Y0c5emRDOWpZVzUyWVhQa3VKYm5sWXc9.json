{"title":"canvas世界","date":"2018-10-28T16:00:00.000Z","author":"Chambers","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1540477799004&di=8b668a37713046a600ba0aa96d78bbe9&imgtype=0&src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F01cb53573ec92532f8757cb9111985.jpg%402o.jpg","excerpt":"","slug":"canvas世界","comments":true,"dropcap":false,"tags":["canvas"],"categories":["canvas"],"updated":"2018-10-25T11:42:38.125Z","content":"<h2 id=\"一、基础详解\"><a href=\"#一、基础详解\" class=\"headerlink\" title=\"一、基础详解\"></a>一、基础详解</h2><h3 id=\"1-画线\"><a href=\"#1-画线\" class=\"headerlink\" title=\"1.画线\"></a>1.画线</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;canvas id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;500&quot; &gt;&lt;/canvas&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var canvas1 = document.getElementById(&quot;canvas&quot;);</span><br><span class=\"line\">var ctx = canvas1.getContext(&apos;2d&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">ctx.moveTo(100,100);</span><br><span class=\"line\">ctx.lineTo(300,300);</span><br><span class=\"line\">ctx.lineTo(400,300);</span><br><span class=\"line\">ctx.lineWidth = 10; //线粗</span><br><span class=\"line\">ctx.strokeStyle = &apos;green&apos;;  //stroke的颜色</span><br><span class=\"line\">ctx.stroke();</span><br></pre></td></tr></table></figure>\n<p>moveto和lineto方法可以多次使用。最后，还可以使用closePath方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。</p>\n<hr>\n<h3 id=\"2-要想独立开每个图形，可以用beginPath-来声明新路径的开始，否则，后面的状态会覆盖前面的状态\"><a href=\"#2-要想独立开每个图形，可以用beginPath-来声明新路径的开始，否则，后面的状态会覆盖前面的状态\" class=\"headerlink\" title=\"2.要想独立开每个图形，可以用beginPath()来声明新路径的开始，否则，后面的状态会覆盖前面的状态\"></a>2.要想独立开每个图形，可以用beginPath()来声明新路径的开始，否则，后面的状态会覆盖前面的状态</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.beginPath();</span><br><span class=\"line\">...</span><br><span class=\"line\">ctx.stroke();</span><br><span class=\"line\">ctx.beginPath();</span><br><span class=\"line\">...</span><br><span class=\"line\">ctx.stroke();</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3-绘制封闭的多边形，用beginPath-和closePath\"><a href=\"#3-绘制封闭的多边形，用beginPath-和closePath\" class=\"headerlink\" title=\"3.绘制封闭的多边形，用beginPath()和closePath();\"></a>3.绘制封闭的多边形，用beginPath()和closePath();</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.beginPath();</span><br><span class=\"line\">...</span><br><span class=\"line\">ctx.closePath();</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"4-填充颜色\"><a href=\"#4-填充颜色\" class=\"headerlink\" title=\"4.填充颜色\"></a>4.填充颜色</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.fillStyle = &apos;green&apos;;</span><br><span class=\"line\">ctx.fill();</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"5-矩形绘制\"><a href=\"#5-矩形绘制\" class=\"headerlink\" title=\"5.矩形绘制\"></a>5.矩形绘制</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.rect(x,y,width,height);   //(左上角x坐标，左上角y坐标，宽，高)</span><br><span class=\"line\"></span><br><span class=\"line\">//下面更加方便的，上面的还要stroke或者fill：</span><br><span class=\"line\">ctx.fillRect(x,y,width,height);</span><br><span class=\"line\">ctx.strokeRect(x,y,width,height);</span><br><span class=\"line\"></span><br><span class=\"line\">//清除</span><br><span class=\"line\">ctx.clearRect(x,y,width,height);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"6-线帽\"><a href=\"#6-线帽\" class=\"headerlink\" title=\"6.线帽\"></a>6.线帽</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.lineCap = &apos;butt&apos;;     //一般，不突出</span><br><span class=\"line\">ctx.lineCap = &apos;round&apos;;    //圆形</span><br><span class=\"line\">ctx.lineCap = &apos;square&apos;;   //方形</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"7-虚线\"><a href=\"#7-虚线\" class=\"headerlink\" title=\"7.虚线\"></a>7.虚线</h3><p>用 setLineDash 方法和 lineDashOffset 属性来制定虚线样式. setLineDash 方法接受一个数组，来指定线段与间隙的交替；lineDashOffset属性设置起始偏移量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.setLineDash([20, 5]);  // [实线长度, 间隙长度]</span><br><span class=\"line\">ctx.lineDashOffset = -0;</span><br><span class=\"line\">ctx.strokeRect(50, 50, 210, 210);</span><br><span class=\"line\"></span><br><span class=\"line\">ps：</span><br><span class=\"line\">getLineDash(); //返回一个包含当前虚线样式，长度为非负偶数的数组。</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"8-线条交界处的表现形式\"><a href=\"#8-线条交界处的表现形式\" class=\"headerlink\" title=\"8.线条交界处的表现形式\"></a>8.线条交界处的表现形式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.lineJoin=&quot;miter|bevel|round&quot;;//（尖角(默认)，斜角，圆角）</span><br><span class=\"line\">ctx.miterLimit = 10;//（限制尖角的延伸，超过10就变成斜角）</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"9-图形变换（效果会叠加）\"><a href=\"#9-图形变换（效果会叠加）\" class=\"headerlink\" title=\"9.图形变换（效果会叠加）\"></a>9.图形变换（效果会叠加）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.translate(x,y);   //左上角的原点移动到（x,y）处</span><br><span class=\"line\">ctx.rotate(deg);  //旋转</span><br><span class=\"line\">ctx.scale(sx,sy); //缩放（它不仅放大宽高，他还放大坐标、线宽！！）</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"10-设置变换矩阵（略）\"><a href=\"#10-设置变换矩阵（略）\" class=\"headerlink\" title=\"10.设置变换矩阵（略）\"></a>10.设置变换矩阵（略）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.transform(a,b,c,d,e,f);</span><br><span class=\"line\">ctx.setTransform(a,b,c,d,e,f);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"11-状态保存还原\"><a href=\"#11-状态保存还原\" class=\"headerlink\" title=\"11.状态保存还原\"></a>11.状态保存还原</h3><p>save方法用于保存上下文环境，restore方法用于恢复到上一次保存的上下文环境。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.save();</span><br><span class=\"line\"></span><br><span class=\"line\">ctx.shadowOffsetX = 10;</span><br><span class=\"line\">ctx.shadowOffsetY = 10;</span><br><span class=\"line\">ctx.shadowBlur = 5;</span><br><span class=\"line\">ctx.shadowColor = &apos;rgba(0,0,0,0.5)&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">ctx.fillStyle = &apos;#CC0000&apos;;</span><br><span class=\"line\">ctx.fillRect(10,10,150,100);</span><br><span class=\"line\"></span><br><span class=\"line\">ctx.restore();</span><br><span class=\"line\"></span><br><span class=\"line\">ctx.fillStyle = &apos;#000000&apos;;</span><br><span class=\"line\">ctx.fillRect(180,10,150,100);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码先用save方法，保存了当前设置，然后绘制了一个有阴影的矩形。接着，使用restore方法，恢复了保存前的设置，绘制了一个没有阴影的矩形。</p>\n<hr>\n<h3 id=\"12-渐变\"><a href=\"#12-渐变\" class=\"headerlink\" title=\"12.渐变\"></a>12.渐变</h3><p>线性渐变<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var grd = ctx.createLinearGradient(xstart,ystart,xend,yend);      //创建线性渐变</span><br><span class=\"line\">grd.addColorStop(stop,color);     //在某个位置创建某种颜色</span><br></pre></td></tr></table></figure></p>\n<p>径向渐变<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var grd = ctx.createRadialGradient(x0,y0,r0,x1,y1,r1);      //创建径向渐变</span><br><span class=\"line\">grd.addColorStop(stop,color);     //在某个位置创建某种颜色</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"13-创建样式\"><a href=\"#13-创建样式\" class=\"headerlink\" title=\"13.创建样式\"></a>13.创建样式</h3><p>图片型样式，第一个参数是一个img或者canvas或者video，第二个参数是’no-repeat’’repeat-x’’repeat-y’’repeat’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = createPattern(type,repeat-style);</span><br><span class=\"line\">ctx.fillStyle = pattern;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"14-圆弧\"><a href=\"#14-圆弧\" class=\"headerlink\" title=\"14.圆弧\"></a>14.圆弧</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.arc(圆心x，圆心y，r，起始度数，结束度数，顺时针为false|逆时针为true)</span><br><span class=\"line\">ctx.moveTo(x0,y0);</span><br><span class=\"line\">ctx.arcTo(x1,y1,x2,y2,r);     //x0,y0是起始点，x1,y1是控制点，x2,y2是结束点</span><br><span class=\"line\"></span><br><span class=\"line\">//顺逆时针分别画圆</span><br><span class=\"line\">function draw(ctx, x) &#123;</span><br><span class=\"line\">    ctx.clearRect(0, 0, 500, 500);</span><br><span class=\"line\">    if (x &lt; Math.PI*2) &#123;</span><br><span class=\"line\">        x += 0.05;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        x = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.beginPath();</span><br><span class=\"line\">    ctx.strokeStyle = &apos;#ff4444&apos;;</span><br><span class=\"line\">    ctx.arc(80, 80, 50, 0, x, false); // 顺时针</span><br><span class=\"line\">    ctx.stroke();</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.beginPath();</span><br><span class=\"line\">    ctx.strokeStyle = &apos;#000&apos;;</span><br><span class=\"line\">    ctx.arc(200, 80, 50, 0, Math.PI*2 - x, true); // 逆时针</span><br><span class=\"line\">    ctx.stroke();</span><br><span class=\"line\"></span><br><span class=\"line\">    requestAnimationFrame(function () &#123;</span><br><span class=\"line\">        draw(ctx, x);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">draw(ctx, 0);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"15-弯月示例\"><a href=\"#15-弯月示例\" class=\"headerlink\" title=\"15.弯月示例\"></a>15.弯月示例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.arc(400,400,300,0.5*Math.PI,1.5*Math.PI,true);  //月亮的外弯</span><br><span class=\"line\">ctx.moveTo(400,100);</span><br><span class=\"line\">ctx.arcTo(1200,400,400,700,(400-100)*dis(400,100,1200,400)/(1200-400));     //月亮的内弯</span><br><span class=\"line\">ctx.stroke();</span><br><span class=\"line\">function dis(x1,y1,x2,y2)&#123;</span><br><span class=\"line\">    return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));</span><br><span class=\"line\">&#125;   //计算内弯半径</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"16-用贝塞尔曲线绘制\"><a href=\"#16-用贝塞尔曲线绘制\" class=\"headerlink\" title=\"16.用贝塞尔曲线绘制\"></a>16.用贝塞尔曲线绘制</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.moveTo(x0,y0);</span><br><span class=\"line\"></span><br><span class=\"line\">//贝塞尔二次曲线，x0,y0是起始点，x1,y1是控制点，x2,y2是结束点</span><br><span class=\"line\">ctx.quadraticCurveTo(x1,y1,x2,y2);  </span><br><span class=\"line\"></span><br><span class=\"line\">//贝塞尔三次曲线，x0,y0是起始点，x1,y1是控制点，x2,y2是控制点，x3,y3是结束点  </span><br><span class=\"line\">ctx.bezierCurveTo(x1,y1,x2,y2,x3,y3);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"17-文字\"><a href=\"#17-文字\" class=\"headerlink\" title=\"17.文字\"></a>17.文字</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var pattern = ctx.createPattern(img,&apos;repeat&apos;);</span><br><span class=\"line\">ctx.fillStyle = pattern;      //这样可以把图片样式应用在文字上</span><br><span class=\"line\">ctx.font = &apos;normal|italic|oblique     //font-style:普通，斜体字，倾斜字体</span><br><span class=\"line\">            normal|small-caps         //font-variant:普通，字母样式改变</span><br><span class=\"line\">            normal|lighter|bold|bolder    //font-weight:普通，细，加粗，更粗（但是浏览器渲染只有normal和bold两种表现形式）</span><br><span class=\"line\">            40px </span><br><span class=\"line\">            Arial&apos;;</span><br><span class=\"line\">ctx.textAlign = &apos;left|center|right&apos;;  //文本左右对齐</span><br><span class=\"line\">ctx.textBaseline = &apos;top|middle|bottom|alphabetic|ideographic&apos;;  //文本上下对齐</span><br><span class=\"line\">ctx.fillText(string,x,y,maxWidth);</span><br><span class=\"line\">ctx.strokeText(string,x,y,maxWidth);</span><br><span class=\"line\">ctx.measureText(string).width;    //度量传入字符串在页面中渲染出来的宽度</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"18-阴影\"><a href=\"#18-阴影\" class=\"headerlink\" title=\"18.阴影\"></a>18.阴影</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.shadowColor = &apos;black&apos;;    //阴影颜色</span><br><span class=\"line\">ctx.shadowOffsetX = 20;       //阴影水平偏移</span><br><span class=\"line\">ctx.shadowOffsetY = 20;       //阴影垂直偏移</span><br><span class=\"line\">ctx.shadowBlur = 10;          //阴影模糊度</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"19-全局透明度\"><a href=\"#19-全局透明度\" class=\"headerlink\" title=\"19.全局透明度\"></a>19.全局透明度</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.globalAlpha = 0.6;  //1是默认不透明</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"20-覆盖时产生的效果\"><a href=\"#20-覆盖时产生的效果\" class=\"headerlink\" title=\"20.覆盖时产生的效果\"></a>20.覆盖时产生的效果</h3><p>我们总是将一个图形画在另一个之上，对于其他更多的情况，仅仅这样是远远不够的。比如，对合成的图形来说，绘制顺序会有限制。不过，我们可以利用 globalCompositeOperation 属性来改变这种状况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//默认后面的覆盖前面的|前面的覆盖后面的（还有很多，详情上网看）</span><br><span class=\"line\">ctx.globalCompositeOperation = &apos;source-over|destination-over&apos;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"21-裁剪\"><a href=\"#21-裁剪\" class=\"headerlink\" title=\"21.裁剪\"></a>21.裁剪</h3><p>把已经创建的路径转换成裁剪路径。裁剪路径的作用是遮罩。只显示裁剪路径内的区域，裁剪路径外的区域会被隐藏。ps：clip()只能遮罩在这个方法调用之后绘制的图像，如果是clip()方法调用之前绘制的图像，则无法实现遮罩。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.clip();</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"22-利用非零环绕原则实现剪纸效果\"><a href=\"#22-利用非零环绕原则实现剪纸效果\" class=\"headerlink\" title=\"22.利用非零环绕原则实现剪纸效果\"></a>22.利用非零环绕原则实现剪纸效果</h3><p>（从需要判断的区域射一条线到外面，经过的线条方向不一致那就是属于图形外，否则就是图形内）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.beginPath();</span><br><span class=\"line\">ctx.arc(400,400,300,0,Math.PI*2,false);</span><br><span class=\"line\">ctx.arc(400,400,150,0,Math.PI*2,true);</span><br><span class=\"line\">ctx.closePath();</span><br><span class=\"line\">ctx.fillStyle = &apos;#058&apos;;</span><br><span class=\"line\">ctx.shadowColor = &apos;grey&apos;;</span><br><span class=\"line\">ctx.shadowOffsetX = 10;</span><br><span class=\"line\">ctx.shadowOffsetY = 10;</span><br><span class=\"line\">ctx.shadowBlur = 10;</span><br><span class=\"line\">ctx.fill();</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"23-判断鼠标所在位置是否在指定目标中\"><a href=\"#23-判断鼠标所在位置是否在指定目标中\" class=\"headerlink\" title=\"23.判断鼠标所在位置是否在指定目标中\"></a>23.判断鼠标所在位置是否在指定目标中</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x = e.clientX - canvas.getBoundingClientRect().left;  //获取鼠标在canvas中的x位置</span><br><span class=\"line\">var y = e.clientY - canvas.getBoundingClientRect().top;   //获取鼠标在canvas中的y位置</span><br><span class=\"line\">ctx.isPointInPath(x,y);   //在绘制图形内就为true，否则为false</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"24-扩展context\"><a href=\"#24-扩展context\" class=\"headerlink\" title=\"24.扩展context\"></a>24.扩展context</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CanvasRenderingContext2D.prototype.fillStar = function()&#123;...&#125;</span><br><span class=\"line\">//可以这样来记录上一个moveTo的点的地方</span><br><span class=\"line\">var originalMoveTo = CanvasRenderingContext2D.prototype.moveTo;</span><br><span class=\"line\">CanvasRenderingContext2D.prototype.lastMoveToLoc = &#123;&#125;;</span><br><span class=\"line\">CanvasRenderingContext2D.prototype.moveTo = function(x,y)&#123;</span><br><span class=\"line\">  originalMoveTo.apply(this,[x,y]);</span><br><span class=\"line\">  this.lastMoveToLoc.x = x;    </span><br><span class=\"line\">  this.lastMoveToLoc.y = y; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"25-IE6-7-8的兼容问题\"><a href=\"#25-IE6-7-8的兼容问题\" class=\"headerlink\" title=\"25.IE6,7,8的兼容问题\"></a>25.IE6,7,8的兼容问题</h3><p>用explorecanvas</p>\n<hr>\n<h3 id=\"26-Canvas图形库\"><a href=\"#26-Canvas图形库\" class=\"headerlink\" title=\"26.Canvas图形库\"></a>26.Canvas图形库</h3><p>canvasplus：https:code.google.com/p/canvasplus/</p>\n<p>artisan js：http:artisanjs.com/</p>\n<p>Rgraph：https:roopons.com.au/wp-content/plugins/viral-optins/js/rgraph/</p>\n<hr>\n<h3 id=\"27-获取图像像素\"><a href=\"#27-获取图像像素\" class=\"headerlink\" title=\"27.获取图像像素\"></a>27.获取图像像素</h3><p>getImageData方法可以用来读取Canvas的内容，返回一个对象，包含了每个像素的信息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var imageData = ctx.getImageData(x,y,w,h);</span><br><span class=\"line\">imageData.width;</span><br><span class=\"line\">imageData.height;</span><br><span class=\"line\">imageData.data;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"28-置入图像数据\"><a href=\"#28-置入图像数据\" class=\"headerlink\" title=\"28.置入图像数据\"></a>28.置入图像数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.putImageData(imageData,dx,dy,dirtyX,dirtyY,dirtyW,dirtyH)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"29-把图像画入画布\"><a href=\"#29-把图像画入画布\" class=\"headerlink\" title=\"29.把图像画入画布\"></a>29.把图像画入画布</h3><p>由于图像的载入需要时间，drawImage方法只能在图像完全载入后才能调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var image = new Image();</span><br><span class=\"line\"></span><br><span class=\"line\">image.onload = function() &#123;</span><br><span class=\"line\">  var canvas = document.createElement(&apos;canvas&apos;);</span><br><span class=\"line\">  canvas.width = image.width;</span><br><span class=\"line\">  canvas.height = image.height;</span><br><span class=\"line\">  canvas.getContext(&apos;2d&apos;).drawImage(image, 0, 0);</span><br><span class=\"line\">  // 插入页面底部</span><br><span class=\"line\">  document.body.appendChild(image);</span><br><span class=\"line\">  return canvas;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">image.src = &apos;image.png&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var imageData = ctx.createImageData(w,h);</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"30-导出生成图片\"><a href=\"#30-导出生成图片\" class=\"headerlink\" title=\"30.导出生成图片\"></a>30.导出生成图片</h3><p>对图像数据做出修改以后，可以使用toDataURL方法，将Canvas数据重新转化成一般的图像文件形式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function convertCanvasToImage(canvas) &#123;</span><br><span class=\"line\">  var image = new Image();</span><br><span class=\"line\">  image.src = canvas.toDataURL(&apos;image/png&apos;);</span><br><span class=\"line\">  return image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码将Canvas数据，转化成PNG data URI。</p>\n<hr>\n<h2 id=\"二、性能优化\"><a href=\"#二、性能优化\" class=\"headerlink\" title=\"二、性能优化\"></a>二、性能优化</h2><h3 id=\"31-离屏渲染\"><a href=\"#31-离屏渲染\" class=\"headerlink\" title=\"31.离屏渲染\"></a>31.离屏渲染</h3><p>我们可以把离屏 Canvas 理解为一个预渲染的机制，我们通过先绘制好整块图案，之后在局部区域时就不需要再进行反复的图片渲染，在 drawImage 中可以直接对图片进行裁剪。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var m_canvas = document.createElement(&apos;canvas&apos;);</span><br><span class=\"line\">m_canvas.width = 64;    // 渲染整体</span><br><span class=\"line\">m_canvas.height = 64;</span><br><span class=\"line\">var m_context = m_canvas.getContext(‘2d’);</span><br><span class=\"line\">draw(m_context);</span><br><span class=\"line\">function render() &#123;</span><br><span class=\"line\">  context.drawImage(m_canvas, 0, 0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"32-一次绘制\"><a href=\"#32-一次绘制\" class=\"headerlink\" title=\"32.一次绘制\"></a>32.一次绘制</h3><p>绘制操作会消耗比较多的资源，所以最好是一次绘制，将命令全部存储到缓冲区中。</p>\n<p>优化前：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var i = 0; i &lt; points.length - 1; i++) &#123;</span><br><span class=\"line\">  var p1 = points[i];</span><br><span class=\"line\">  var p2 = points[i+1];</span><br><span class=\"line\">  context.beginPath();</span><br><span class=\"line\">  context.moveTo(p1.x, p1.y);</span><br><span class=\"line\">  context.lineTo(p2.x, p2.y);</span><br><span class=\"line\">  context.stroke();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>优化后：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.beginPath();</span><br><span class=\"line\">for (var i = 0; i &lt; points.length - 1; i++) &#123;</span><br><span class=\"line\">  var p1 = points[i];</span><br><span class=\"line\">  var p2 = points[i+1];</span><br><span class=\"line\">  context.moveTo(p1.x, p1.y);</span><br><span class=\"line\">  context.lineTo(p2.x, p2.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">context.stroke();</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"33-避免浮点数坐标\"><a href=\"#33-避免浮点数坐标\" class=\"headerlink\" title=\"33.避免浮点数坐标\"></a>33.避免浮点数坐标</h3><p>浏览器为了抗锯齿会对浮点数进行额外的处理，可以通过数学类函数进行取整操作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.drawImage(myImage, Math.floor(0.3), Math.floor(0.5));</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"34-使用多个画布渲染复杂的场景\"><a href=\"#34-使用多个画布渲染复杂的场景\" class=\"headerlink\" title=\"34.使用多个画布渲染复杂的场景\"></a>34.使用多个画布渲染复杂的场景</h3><p>对于一些复杂的场景，可以将不变的场景和变化的物体进行区分渲染，下面是一段 demo，这样需要变更并渲染的像素更小：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;stage&quot;&gt;</span><br><span class=\"line\">  &lt;canvas id=&quot;ui-layer&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt;</span><br><span class=\"line\">  &lt;canvas id=&quot;game-layer&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt;</span><br><span class=\"line\">  &lt;canvas id=&quot;background-layer&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  #stage &#123;</span><br><span class=\"line\">    width: 480px;</span><br><span class=\"line\">    height: 320px;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    border: 2px solid black</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  canvas &#123; position: absolute; &#125;</span><br><span class=\"line\">  #ui-layer &#123; z-index: 3 &#125;</span><br><span class=\"line\">  #game-layer &#123; z-index: 2 &#125;</span><br><span class=\"line\">  #background-layer &#123; z-index: 1 &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"35-如果不用透明度的话，可以关闭透明度\"><a href=\"#35-如果不用透明度的话，可以关闭透明度\" class=\"headerlink\" title=\"35.如果不用透明度的话，可以关闭透明度\"></a>35.如果不用透明度的话，可以关闭透明度</h3><p>如果你的游戏使用画布而且不需要透明，当使用 HTMLCanvasElement.getContext() 创建一个绘图上下文时把 alpha 选项设置为 false 。这个选项可以帮助浏览器进行内部优化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ctx = canvas.getContext(&apos;2d&apos;, &#123; alpha: false &#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"36-有动画，请使用window-requestAnimationFrame-而不是window-setInterval\"><a href=\"#36-有动画，请使用window-requestAnimationFrame-而不是window-setInterval\" class=\"headerlink\" title=\"36.有动画，请使用window.requestAnimationFrame() 而不是window.setInterval()\"></a>36.有动画，请使用window.requestAnimationFrame() 而不是window.setInterval()</h3><hr>\n<h3 id=\"37-尽量利用CSS\"><a href=\"#37-尽量利用CSS\" class=\"headerlink\" title=\"37.尽量利用CSS\"></a>37.尽量利用CSS</h3><p>背景图</p>\n<p>如果有大的静态背景图，直接绘制到 canvas可能并不是一个很好的做法，如果可以，将这个大背景图作为 background-image 放在一个 DOM元素上(例如，一个div)，然后将这个元素放到 canvas后面，这样就少了一个canvas的绘制渲染。</p>\n<p>transform变幻</p>\n<p>CSS的 transform性能优于 canvas的 transfomr API，因为前者基于可以很好地利用 GPU，所以如果可以，transform变幻请使用 CSS来控制。</p>\n<hr>\n","prev":{"title":"该学学TypeScript了","slug":"该学学TypeScript了"},"next":{"title":"深入浅出Rxjs学习笔记","slug":"深入浅出Rxjs学习笔记"}}